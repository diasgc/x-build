#!/bin/bash
# ................................................
# Commons 1.2.0-dev 2021-diasgc
# Definition constants and functions
# ................................................

function trap_sigint {
  tput cnorm
  cd "$(dirname $0)"
  local l
  [ -f "${log_file}" ] && l="  Log available at ${log_file}\n"
  echo -e "\n\n${CY1}  Interrupted by user${C0}\n${l}\n"
  trap - SIGINT
  exit 1
}

shopt -s extglob
trap trap_sigint SIGINT

vsh='1.2.0-main'

#b="\u25ba"
b="\u2605"
c="\u2714"

# box chars
BX0="\u2502" BX1="\u251C" BX2="\u250C" BX3="\u2514" BX4="\u252C" BX5="\u2500"
BXH="${BX1}${BX5}${BX4}${BX5}${CY1}" BXL="${BX0} ${BX1}${BX5}${CY2}" BXE="${BX0} ${BX3}${BX5}${CY1}"

# def theme colors
C0="\e[0m" CW="\e[97m"  CD="\e[90m" CW2="\e[38;5;234m" CW3="\e[38;5;238m" CW4="\e[38;5;242m"  CW5="\e[38;5;246m" CW6="\e[38;5;250m"
CR0="\e[31m" CR1="\e[91m" CR2="\e[38;5;52m" CR3="\e[38;5;88m" CR4="\e[38;5;124m" CR5="\e[38;5;160m"  CR6="\e[38;5;196m"
CY0="\e[33m" CY1="\e[93m" CY2="\e[38;5;58m" CY3="\e[38;5;94m" CY4="\e[38;5;136m" CY5="\e[38;5;178m"  CY6="\e[38;5;220m"
CG0="\e[32m" CG1="\e[92m" CG2="\e[38;5;40m" CG3="\e[38;5;46m" CG4="\e[38;5;82m" CG5="\e[38;5;118m"  CG6="\e[38;5;154m"
CC0="\e[36m" CC1="\e[96m" CC2="\e[38;5;49m" CC3="\e[38;5;85m" CC4="\e[38;5;122m" CC5="\e[38;5;123m"  CC6="\e[38;5;195m"
CB0="\e[34m" CB1="\e[94m" CB2="\e[38;5;26m" CB3="\e[38;5;69m" CB4="\e[38;5;111m" CB5="\e[38;5;152m"  CB6="\e[38;5;153m"
CM0="\e[35m" CM1="\e[95m" CM2="\e[38;5;54m" CM3="\e[38;5;91m" CM4="\e[38;5;126m" CM5="\e[38;5;162m"  CM6="\e[38;5;198m"

CO0="\e[38;5;130m" CO1="\e[38;5;166m" CO2="\e[38;5;202m" CO3="\e[38;5;208m"  CO4="\e[38;5;214m" CO5="\e[38;5;220m" CO6="\e[38;5;223m"
CF0="\e[38;5;53m"  CF1="\e[38;5;89m"  CF2="\e[38;5;125m" CF3="\e[38;5;161m"  CF4="\e[38;5;197m" CF5="\e[38;5;211m" CF6="\e[38;5;219m"
CL0="\e[38;5;34m" CL1="\e[38;5;72m" CL2="\e[38;5;114m" CL3="\e[38;5;120m"  CL4="\e[38;5;156m" CL5="\e[38;5;192m" CL6="\e[38;5;230m"

# theme colors
CT0=$CM0 CT1=$CM1 CS0=$CR0 CS1=$CR1 SSB=$C0

: "${shell_dstack:=}"

# Logger
logtime_start=
export dir_root=$(pwd)
export PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;95m\]\u@\e[0;95m\h\[\033[00m\]:\[\033[01;96m\]\w\[\033[00m\]\$ '

function splash {
  echo
  printf "${CB6}THE ▀▄ ▄▀   █▀▀▄ █  █ ▀█▀ █   █▀▀▄\n"
  printf "${CB1}     ▄▀▄ ▀▀ █▀▀▄ █  █  █  █   █  █\n"
  printf "${CB0}    ▀   ▀   ▀▀▀  ▀▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ \n\n"
  printf "${CW}   A cross complile build system\n\n${C0}"
}

function show_banner {
	echo -ne "\n\n${CW}Cross Build scripts ${vsh} for Linux${C0}\n"
  [ -n $(command -v lsb_release) ] && echo -ne "$(lsb_release -sd) "
  if [ -n "$(uname -r | grep 'microsoft')" ];then
    echo -ne "WSL2 "
  elif [ -n "$(uname -r | grep 'Microsoft')" ];then
    echo -ne "WSL "
  fi
  echo -e "$(uname -o) $(uname -m) ${C0} kernel $(uname -r)"
  echo -e "${CW}$(hwinfoCountCoresReadable) $(hwinfoProcessor)${C0}"
  is_running=true
}

function get_source {
  
  # test internet connection
	wget -q --spider http://google.com
	[ ! $? -eq 0 ] && exit_err 'No Internet Connection. Aborting...'

	# check whether to custom get source
	if fn_defined 'source_get'; then
		fn_log 'get' source_get
		unset sty
    return 0
  fi
  
  # check if source is already a tarball
  case "${src}" in
    *.tar.gz)      curl_targz "${src}" "${lib}" && return 0;;
    *.tar.*|*.zip) curl_tar "${src}" "${lib}" && return 0;;
  esac
  
  # git sub command requires git to apply
  test -n "${sub}" && src_rel=false
  if ${src_rel}; then
    if fn_defined 'latest_release'; then
      latest_release
    else
      case "${src}" in
        *github.com*) github_get_latest_tarball "${src}" "${lib}" && return 0;;
        *gitlab.com*) gitlab_get_latest_tarball "${src}" "${lib}" && return 0;;
        *googlesource.com*) googlesource_get_latest_tarball "${src}" "${lib}" && return 0;;
        *.git)        git_clone ${src} ${lib} ${src_opt} && return 0;;
      esac
    fi
	elif [ -n "${git}" ]; then
		git_clone "${git}" "${lib}" "${src_opt}"
		return 0
	elif [ -n "${svn}" ]; then
		svn_clone "${svn}" "${lib}"
		return 0
	elif [ -n "${hg}" ]; then
    hg_clone "${hg}" "${lib}"
    return 0
  fi
	case "${src}" in
			*.tar.*|*.tgz) curl_tar  "${src}" "${lib}";;
			*.git|*git*)   git_clone "${src}" "${lib}" "${src_opt}";;
			*svn.*)        svn_clone "${src}" "${lib}";;
			*)             exit_err "Unknown source type for ${src}";;
  esac
}

# git_clone <source> <libname/destfolder> <options>
function git_clone {
  local t="git"
	echo -ne "${CD}${t}"
	logf git clone --progress --verbose ${src} ${lib} ${src_opt}
	git clone --progress --verbose ${src} ${lib} ${src_opt} |& tr '\r' '\n' | prt_git_progress
	logok "${t}"
	test -d "${lib}" && cd ${lib} || err
	if [ -n "${bra}" ]; then
		do_log ${bra} git checkout ${bra}
		unset bra
	elif [ -n "${vrs}" ]; then
		do_log ${vrs} git checkout tags/${vrs}
	fi
	if [ -n "${sub}" ];then
		do_log 'sub' git ${sub} |& tr '\r' '\n' | prt_git_progress
	fi
  vrs="$(git tag -l | tail -n1)"
  echo -ne "${CT0}[${vrs}]${CD} "
	cd ..
}

function svn_clone {
	request_cmd svn subversion || err
	do_log 'svn' svn checkout $1 $2
}

function hg_clone {
	request_cmd hg mercurial || err
	do_log 'clone' hg clone $1 $2
}

# usage: github_get_latest_tarball <git-url> <dest-dir>
# result: from the git-url, set vrs to the latest release
# and downloads + extracts tarball to dest-dir
function github_get_latest_tarball {
  echo "$(date): $@" >> "${log_file}"
  local s="$(sed 's,https://github\.com/,,;s,\.git$,,' <<<${1})"
  local json=$(curl --silent "https://api.github.com/repos/${s}/releases/latest")
  local tarball_url=$(jq -r .tarball_url <<<${json})
  if [ "${tarball_url}" = "null" ]; then
    json=$(curl -sL "https://api.github.com/repos/${s}/tags")
    tarball_url=$(jq -r .[0].tarball_url <<<${json})
    if [ "${tarball_url}" = "null" ]; then
      git_clone ${src} ${lib} ${src_opt}
      return 0
    fi
    vrs=$(jq -r .[0].name <<<${json})
  else
    vrs=$(jq -r .tag_name <<<${json})
  fi
	dir_src="${dir_sources}/${2}"
  local tag="get ${vrs}"
  echo -ne "${CD}${tag}${C0}"
  test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
	curl -sL ${tarball_url} -w %{url_effective} 2>>"${log_file}" | tar -xz -C ${dir_src} --strip-components=1 2>>"${log_file}"
	logok "${tag}"
}

function gitlab_get_latest_tarball {
  vrs="$(git_version_remote ${src})"
  src="${src%%\.git}/-/archive/${v}/${vrs}.tar.gz"
  curl_tar ${src} ${lib}
}

function googlesource_get_latest_tarball {
  vrs="$(git_version_remote ${1})"
  src="${src%%\.git}/+archive/${vrs}.tar.gz"
  curl_tar ${src} ${lib}
}

function curl_tar {
	local tag="get"
	local args=
	dir_src="${dir_sources}/${2}"
	echo -ne "${CD}${tag}${C0}"
	echo "$(date): $@" >> "${log_file}"
	
	case "${1}" in
		*.tar.lz)        request_cmd 'lzip' && args='--lzip -xv';;
		*.tar.gz|*.tgz)  args="-xz";;
		*.tar.xz)        args="-xJ";;
		*.tar.bz2)       args="-xj";;
	esac
	
	test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
	curl -sL "${1}" 2>>"${log_file}" | tar "${args}" -C ${dir_src} --strip-components=1 2>>"${log_file}"
	
	logok "${tag}"
}

function curl_targz {
  local tag="get"
	dir_src="${dir_sources}/${lib}"
	echo -ne "${CD}${tag}${C0}"
	echo "$(date): $@" >> "${log_file}"
  test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
	curl -sL "${1}" 2>>"${log_file}" | tar -xz -C ${dir_src} --strip-components=1 2>>"${log_file}"
	logok "${tag}"
}

# git_latest_tgz <git-url>
function git_latest_tgz {
  local src="${1}"
	case "${src}" in
		*github.*)
			local dst="$(sed 's,.git$,,' <<<${src})"
			local url=$(curl -ILs -o /dev/null -w %{url_effective} "${dst}/releases/latest")
			local file=$(curl -s ${url} | grep -Po '(?<=>)[^<]*' | grep -Po '.*tar.gz$')
			echo "${url}/${file}"
		;;
		*gitlab.*|*code.videolan.org*)
			local v="$(git_version_remote ${src})"
			echo "${src%%\.git}/-/archive/${v}/${lib}-${v}.tar.gz"
		;;
		*.googlesource.*)
			local tag="$(git -c 'versionsort.suffix=-' ls-remote --refs --sort='v:refname' ${src} | tail -n1 | cut -f1)"
			echo "${src}/+archive/${tag}.tar.gz"
		;;
	esac
}

function git_version_local(){
  pushd ${dir_src} > /dev/null
  local v=$(git describe --tags)
  local out=$(grep -oP '[0-9]+\.[0-9]+\.[0-9]+' <<<${v})
  test -z "${out}" && out=$(grep -oP '[0-9]+\.[0-9]+' <<<${v})
  test -z "${out}" && out=${v}
  echo "${out}"
  popd > /dev/null
}

function git_version_remote {
  local out="$(git ls-remote --tags --refs --sort="v:refname" ${1} 2>/dev/null | tail -n1)"
  echo "${out##*\/}"
}

git_remote_version(){
  local out="$(git ls-remote --tags --refs --sort="v:refname" ${1} 2>/dev/null | tail -n1)"
  echo "${out##*\/}"
  #echo $(git ls-remote --tags --refs --sort="v:refname" ${1} 2>/dev/null | head -n1 | sed 's/.*\///')
}

# usage: github_set_src_release <git_url> <prefix> <ext>
#   git_url: https://github.com/user/repo.git
#   prefix: prefix for name of source file (default none)
#   ext: extension for source file (default tar.gz)
function github_set_src_release {
  local git_id="$(sed 's,https://github.com/,,;s,.git$,,' <<<${1})"
  local pfx="${2}"
  local ext="${3}"
  if [ -n "${git_id}" ]; then
    test -z "${ext}" && ext="tar.gz"
    vrs="$(github_latest_release ${git_id})"
    test -n "${vrs}" && src="https://github.com/${git_id}/archive/refs/tags/${pfx}${vrs}.${ext}"
  fi
  return 0
}

# TODO
function gitlab_set_src_release {
  vrs=''
  src="https://gitlab.com/${git_id}/-/archive/${vrs}/lilv-${vrs}.${ext}"
}

# usage github_latest_release <user/repo id> or <git url>
function github_latest_release {
  # extract id from url, in case it is not already given
  local s="$(sed 's,https://github\.com/,,;s,\.git$,,' <<<${1})"
  # get version tag name
	echo $(curl --silent "https://api.github.com/repos/${s}/releases/latest" | jq -r .tag_name)
}

git_getversion(){
  [ -d "${1}" ] && git --git-dir=${1}/.git --work-tree=${1} describe --abbrev=0 --tags || git describe --abbrev=0 --tags
}


# usage: search_configfile <config-file> (ex. CMakeLists.txt, configure, meson.build)
# returns: nearest source root location of config file
search_configfile(){
  local cmd="${1}"
  local dest="$(find ${dir_src} -name ${cmd} -printf "%d %p\n"|sort -n|head -n1)"
  dest="$(sed 's,.*'${dir_src}'/,,;s,/'${cmd}',,' <<<${dest})"
  echo "${dir_src}/${dest}"
}

function config_guess {
  if [ -f "${dir_config}/meson.build" ]; then
    build_system="meson"
    cfg="meson"
  elif [ -f "${dir_config}/CMakeLists.txt" ]; then
    build_system="cmake"
    cfg="cmake"
  elif [ -n "$(ls ${dir_config}/configure* 2>/dev/null)" ]; then
    build_system="automake"
    cfg='ac'
    if [ -f "${dir_config}/autogen.sh" ]; then
      cfg_cmd="${dir_config}/autogen.sh"
	    cfg='ag'
    elif [ -f "${dir_config}/bootstrap.sh" ]; then
      cfg_cmd="${dir_config}/bootstrap.sh"
    elif [ -f "${dir_config}/bootstrap" ]; then
      cfg_cmd="${dir_config}/bootstrap"
	  elif [ -f "${dir_config}/configure.ac"]; then
	    cfg='ar'		
    elif [ ! -f "${dir_config}/configure" ]; then
      cfg_cmd="autoreconf -fiv ${dir_config}/bootstrap"
    else
      return 1
    fi
  else
    return 1
  fi
  return 0
}

function cmake_set_buildlink {
  : "${cmake_static:=BUILD_STATIC_LIBS}"
  : "${cmake_shared:=BUILD_SHARED_LIBS}"
  case "${cmake_shared}" in
    -D*=*) ${build_shared} && CSH="${cmake_shared}";;
    *) CSH="-D${cmake_shared}=$(bool2str ${build_shared} ON OFF)";;
  esac
  case "${cmake_static}" in
    -D*=*) ${build_static} && CSH="${cmake_static}";;
    *) CSH="-D${cmake_static}=$(bool2str ${build_static} ON OFF) ${CSH}";;
  esac
  if [ -n "${cmake_bin}" ]; then
    case "${cmake_bin}" in
      -D*=*) ${build_bin} && CBN="${cmake_bin}";;
      *) CBN="-D${cmake_bin}=$(bool2str ${build_bin} ON OFF)";;
    esac
  fi
}

function am_set_buildlink {
  : "${ac_static:=static}"
  : "${ac_shared:=shared}"
  CSH="--$(bool2str ${build_shared} enable disable)-${ac_shared})"
  CSH="--$(bool2str ${build_static} enable disable)-${ac_static}) ${CSH}"
  if [ -n "${ac_bin}" ]; then
    case "${ac_bin}" in
      --enable-*) CBN="${ac_bin}=$(bool2str ${build_bin} 1 0)";;
      able-*)     CBN="--$(bool2str ${build_bin} en dis)${ac_bin}";;
      with-*)     CBN="--$(bool2str ${build_bin} without-${ac_bin:5} ${ac_bin})";;
      *)          CBN="--enable-${ac_bin}=$(bool2str ${build_bin} 1 0)";;
    esac
  fi
}

function meson_set_buildlink {
  : "${meson_static:=-Ddefault_library=static}"
  : "${meson_shared:=-Ddefault_library=shared}"
  if ${build_static} && ${build_shared}; then
    CSH="-Ddefault_library=both"
  elif ${build_static}; then
    CSH="${meson_static}"
  elif ${build_shared}; then
    CSH="${meson_shared}"
  fi
}

# check build system and set defaults - static and shared build options
function config_init {

	# if no cfg provided, try to guess
	test -z "${cfg}" && config_guess
	test -z "${cfg}" && exit_err 'No build system found. Exiting.'
	
	case "${cfg}" in
		cm|ccm|cmake|ccmake)
			build_system=cmake
      cmake_set_buildlink
			;;
		ab|am|ac|ar|ag|auto*)
			build_system=automake
      am_set_buildlink
			;;
		meson)
			build_system=meson
			meson_set_buildlink
			;;
		mk|make) build_system=make;;
		other) build_system=other;;
		*) unset build_system;;
	esac

	if [ -z "${CBN}" ];then
		$build_bin && CBN="${cb1}" || CBN="${cb0}"
	fi
}

config_init_old(){
  # check build type and set defaults if no cst0 cst1 csh0 or csh1 value provided
case $cfg in
	cm|ccm|cmake|ccmake) build_system=cmake

		[ -n "$cstk" ] && cst0="-D${cstk}=OFF" cst1="-D${cstk}=ON"
		[ -n "$cshk" ] && csh0="-D${cshk}=OFF" csh1="-D${cshk}=ON"
		
		! $build_shared && [ -z "$cst1" ] && cst1="-DBUILD_SHARED_LIBS=OFF"
		[ -z "$csh1" ] && csh1="-DBUILD_SHARED_LIBS=ON"
		
		$build_static && ! $build_shared && CSH="${cst1} ${csh0}"
		$build_shared && ! $build_static && CSH="${csh1} ${cst0}"
		$build_static && $build_shared && CSH="${cst1} ${csh1}"
		
		[ -n "$cbk" ] && cb0="-D${cbk}=OFF" cb1="-D${cbk}=ON"

		;;
	ab|am|ac|ar|ag|auto*) build_system=automake
		[ -z "$cst0" ] && cst0="--disable-static"
		[ -z "$cst1" ] && cst1="--enable-static"
		[ -z "$csh0" ] && csh0="--disable-shared"
		[ -z "$csh1" ] && csh1="--enable-shared"
		$build_static && ! $build_shared && CSH="${cst1} ${csh0}"
		$build_shared && ! $build_static && CSH="${csh1} ${cst0}"
		$build_static && $build_shared && CSH="${cst1} ${csh1}"
		[ -n "$cbk" ] && {
		case $cbk in
			--enable-*) cb0="${cbk}=0"; cb1="${cbk}=1";;
			able-*) cb0="--dis${cbk}"; cb1="--en${cbk}";;
			with-*) cb0="--without-${cbk:5}"; cb1="--${cbk}";;
			*) cb0="--enable-${cbk}=0" cb1="--enable-${cbk}=1";;
		esac
		}
		;;
	meson) build_system=meson
		test -z "${meson_static}" && meson_static="-Ddefault_library=static"
		$build_static && ! $build_shared && CSH="${meson_static}"
		test -z "${meson_shared}" && meson_shared="-Ddefault_library=shared"
		$build_shared && ! $build_static && CSH="${meson_shared}"
		$build_static && $build_shared && CSH="-Ddefault_library=both"
		;;
	mk|make) build_system=make;;
	other) build_system=other;;
	*) unset build_system;;
esac
if [ -z "${CBN}" ];then
	$build_bin && CBN="${cb1}" || CBN="${cb0}"
fi
}


#usage build_pkgconfig [--filename=lib.pc][--prefix=install_dir]...[--libs=-la,-lb,-lc,...]
function build_pkgconfig {

	local pkgconfig_file="${lib}.pc"
	local pkgconfig_prefix=${dir_install}
	local pkgconfig_exec_prefix="\${prefix}"
	local pkgconfig_libdir="\${prefix}/lib"
	local pkgconfig_includedir="\${prefix}/include"
	local pkgconfig_description="${dsc}"
	local pkgconfig_url="${url}"
	local pkgconfig_version="${vrs}"
	local pkgconfig_requires=
	local pkgconfig_requires_private=
	local pkgconfig_libs="-l${lib/lib/}"
	local pkgconfig_libs_private=
	local pkgconfig_cflags="-I\${includedir}"

	while [ -n "${1}" ]; do
		case "${1}" in
			--name=*) pkgconfig_file="${1#*=}.pc";;
			--filename=*) pkgconfig_file="${1#*=}";;
			--prefix=*) pkgconfig_prefix="${1#*=}";;
			--exec_prefix=*) pkgconfig_exec_prefix="${1#*=}";;
			--libdir=*) pkgconfig_libdir="${1#*=}";;
			--includedir=*) pkgconfig_includedir="${1#*=}";;
			--description=*) pkgconfig_description="${1#*=}";;
			--url=*) pkgconfig_url="${1#*=}";;
			--version=*) pkgconfig_version="${1#*=}";;
			--requires=*) pkgconfig_requires="${1#*=}";;
			--requires-private=*) pkgconfig_requires_private="${1#*=}";;
			--libs=*) pkgconfig_libs="${1#*=}";;
			--libs-private=*) pkgconfig_libs_private="${1#*=}";;
			--cflags=*) pkgconfig_cflags="${1#*=}";;
		esac
		shift
	done
	
	pkgconfig_libs="-L\${libdir} ${pkgconfig_libs//,/ }"
	pkgconfig_file="${dir_install_pc}/${pkgconfig_file}"
	test -f "${pkgconfig_file}" && rm -f "${pkgconfig_file}"

	cat <<-EOF >"${pkgconfig_file}"
		prefix=${pkgconfig_prefix}
		exec_prefix=${pkgconfig_exec_prefix}
		libdir=${pkgconfig_libdir}
		includedir=${pkgconfig_includedir}

		Name: ${lib}
		Description: ${pkgconfig_description}
		URL: ${pkgconfig_url}
		Version: ${pkgconfig_version}
		Requires: ${pkgconfig_requires//,/ }
		Requires.private: ${pkgconfig_requires_private//,/ }
		Libs: ${pkgconfig_libs//,/ }
		Libs.private: ${pkgconfig_libs_private//,/ }
		Cflags: ${pkgconfig_cflags}

		EOF
}

# usage create_pkgconfig_file <pkg>.pc [llibds][INSTALL_DIR]
function create_pkgconfig_file_old {
	[ -z "${1}" ] && pc_file=${lib} || pc_file=${1}
	[ -z "${2}" ] && pc_llib="-l${pc_file}" || pc_llib=${2}
	[ -z "${3}" ] && pc_prefix=${dir_install} || pc_prefix=${3}
	[ "${pc_llib}" == "null" ] && pc_llib=''
	[ -z "$pc_libdir" ] && pc_libdir="/lib"
	[ -z "$pc_incdir" ] && pc_incdir="/include"
	[ -z "$pc_cflags" ] && pc_cflags="-I\${includedir}"
	[ -z "$pc_libs" ] && pc_libs="-L\${libdir}"
	[ -z "$pc_url" ] && pc_url=$(dirname $src)
	fn_defined 'get_version' && get_version && pc_vrs=$vrs
	[ -z "$pc_vrs" ] && {
	[ -d "${dir_src}/.git" ] && pc_vrs=$(git_getversion ${dir_src}) || pc_vrs=$vrs
	}
	cat <<-EOF >${dir_install_pc}/${pc_file}.pc
		prefix=${pc_prefix}
		exec_prefix=\${prefix}
		libdir=\${exec_prefix}${pc_libdir}
		includedir=\${prefix}${pc_incdir}

		Name: ${lib}
		Description: ${dsc}
		URL: ${pc_url}
		Version: ${pc_vrs}
		Requires: ${pc_requires}
		Requires.private: ${pc_requiresprivate}
		Libs: ${pc_libs} ${pc_llib}
		Libs.private: ${pc_libsprivate}
		Cflags: ${pc_cflags}

		EOF
	pc_filelist="${pc_file}.pc ${pc_filelist}"
	unset pc_libdir pc_incdir pc_cflags pc_libs pc_url
}

function log_unused1 {
	echo -ne "$CD$@$C0"
}

# usage: log <logfile> [--noerr|--progress] <label> <commands....>
function log_unused2 {
  local noerr=false
  local progress=false
  while $(str_starts $1 '--');do
    case $1 in
      --noerr) noerr=true;;
      --progress) progress=true;;
    esac
    shift
  done
	local label=$1; shift
	echo -ne "${CD}${label}${C0}"
	echo -e "\n$(time_elapsed): $@" >> "$logfile"
  if $progress; then
	  ("$@" |& log_progress) || err "in ${act}:\n\n...\n$(tail -n5 ${logfile}${C0})"
  else
	  "$@" 2>> "$logfile" 1>> "$logfile" || err
  fi
	echo -ne "\e[${#label}D${CT0}${label}${C0} "
}

function logf {
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
}

function logok {
	echo -ne "\e[${#1}D${CT0}${1}${C0} "
}

# usage logver /path/to/pkgconfigfile.pc
function logver {
	if [ -f ${1} ]; then
		echo -ne "${CT1}version $(pkg-config --modversion ${1})${C0}"
	else
		echo -ne "${CS0} missing ${1} ${C0}"
	fi
}

function log_vars {
	local t;
	while [ -n "$1" ]; do
		echo "$1=${!1}" >>"${log_file}" 2>&1
		shift
	done
	echo >>"${log_file}"
}

function log_info {
  echo -e "${CD}${ind}${CT0}${1}${C0} "
}

function log_start {
	logtime_start=$(date +%s)
	if ! ${inline}; then
		echo -ne "${CD}${inde}${C0}$(date '+%H:%M')"
		[ $eta ] && echo -ne "-${CW}$(date '+%H:%M' --date="$eta seconds")"
		printf " ${CT1}%-10s ${CT1}%-21s${CD} " ${lib} ${arch}
	fi
	echo $(date) >"${log_file}"
}

function log_end {
	if ! $inline && [ -n "${logtime_start}" ]; then
		logtime_end=$(date +%s)
		local secs=$((${logtime_end} - ${logtime_start}))
		local msg="${CT1} done ${CD}in $(secs2time ${secs})"
		[ ${secs} -gt 60 ] && msg="${msg} (${secs}s)"
		echo -e "${msg}"
	fi
}

function log_this {
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	"$@" 2>> "${log_file}" 1>> "${log_file}" || err
	logok
}

function log_progress {
  printf "%-6s"
  local sln
  IFS=$'\n'
  while read -r ln; do
    # $has_logfile && \
    printf "%-6s: %s\n" $(time_elapsed) $ln >>${logfile}
    str_contains $ln 'error: ' && printf $CR1
    sln=$(grep -oP '\d+%' <<< $ln)
    [ -n "$sln" ] && printf "\e[5D%-5s" $sln
  done
  printf "\e[6D"
  unset IFS
}

function exit_err {
	echo -e "${CR1}  Error: ${CR0}${1}${C0}\n\n"
	if [ -f "${log_file}" ];then
		if [ -f "${dir_build}/CMakeFiles/CMakeError.log" ];then
		  echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> "${log_file}"
		  cat "${dir_build}/CMakeFiles/CMakeError.log" >> "${log_file}"
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "${openlog}" != "n" ] && nano "${log_file}"
	fi
	exit 1
}

function err {
	if [ -n "${logtime_start}" ]; then
		logtime_end=$(date +%s)
		echo -e "${CR1} fail ${CR0}[$(secs2time $((${logtime_end}-${logtime_start})))]${C0}\n"
	fi
	if [ -f "${log_file}" ];then
		if [ -f "${dir_build}/CMakeFiles/CMakeError.log" ];then
		  echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> "${log_file}"
		  cat "${dir_build}/CMakeFiles/CMakeError.log" >> "${log_file}"
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "${openlog}" != "n" ] && nano ${log_file}
	fi
	echo
	exit 1
}

function print_vars {
	while test -n "${1}"; do
		printf "${CC0}%-20s: ${C0}%s\n" "  ${1}" ${!1}
		shift
	done
}

function do_quietly {
	local var
  var="${1}"
  shift
	echo -ne "${CD}${var}${C0}"
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	"$@" >/dev/null 2>&1
	logok "${var}"
}

function do_log {
	local var
  var="${1}"
  shift
	echo -ne "${CD}${var}${C0}"
	log_this $@
	logok "${var}"
}

function do_progress {
	local var
  var="${1}"
  shift
	echo -ne "${CD}${var}"
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	("$@" |& tee -a ${log_file} | topct) || exit_err "in ${var}:\n\n...\n$(tail -n5 ${log_file})${C0}"
	logok "${var}"
}

function topct {
	local sln
	local grp
	tput civis
	printf "build_system: %10s; make: %7s" ${build_system} ${MAKE_EXECUTABLE} >>${log_file}
	if [ "${build_system}" == "cmake" ] && [ "$(basename ${MAKE_EXECUTABLE})" == "make" ]; then
		printf "%-6s"
		while read -r ln; do
			str_contains "${ln}" 'error: ' && printf $CR1
			sln=$(grep -oP '\d+%' <<< $ln)
			[ -n "$sln" ] && printf "\e[5D%-5s" $sln
		done
		printf "\e[6D"
	elif [ "$(basename ${MAKE_EXECUTABLE})" == "ninja" ]; then
		printf "%-12s"
		while read -r ln; do
			str_contains $ln 'error: ' && printf $CR1
			sln=$(grep -oP '\[\d+/\d+\]' <<< $ln)
			[ -n "$sln" ] && printf "\e[11D%-11s" $sln
		done
		printf "\e[12D"
	else
		printf "%-6s"
		while read -r ln; do
			sln+="." # ·
			[ ${#sln} -eq 5 ] && sln=''
			[ -n "$sln" ] && printf "\e[5D%-5s" $sln
		done
		printf "\e[6D"
	fi
	tput cnorm
}








# usage: sourceforge_json <projectname>
sourceforge_json(){
  curl -qsL "https://sourceforge.net/projects/${1}/best_release.json"
}







color_table(){
  local i=16
  while [ $i -lt 52 ]; do
    j=$i
    k=0
    until [ $k == 7 ]; do
      printf "\e[38;5;%dm\u25cf %03d   " ${j} ${j}
      j=$(((j+36)%256))
      k=$((k+1))
    done
    i=$((i+1))
    printf '\r\n'
  done
}

color_vars(){
	local v
	local box=
	for c in R Y G C B M O F L; do
		for i in 0 1 2 3 4 5 6; do
			v="C${c}${i}"
			printf "${!v}\u2605${v}\u2605   "
		done
		printf "\n"
	done
	echo
}

hwinfoCountCoresReadable(){
  case $(nproc) in
    "1") echo "Single-Core";;
    "2") echo "Dual-Core";;
    "4") echo "Quad-Core";;
    "6") echo "Hexa-Core";;
    "8") echo "Octa-Core";;
    *) echo "$(nproc)-Core";;
  esac
}

hwinfoProcessor(){
  local i=$(cat /proc/cpuinfo | grep -Po '^.odel.*: \K(.*)' | tail -n1)
  [ -z "$i" ] && i=$(cat /proc/cpuinfo | grep -Po '^.ardware.*: \K(.*)' | tail -n1)
  [ -z "$i" ] && i=Unknown
  echo $i
}

banner(){
    echo -ne "\n\n  ${CW}${1} for X-Build ${vsh}${C0}\n  "
    echo -ne "Running on $(uname -m) $(uname -o) "
    [ -n $(command -v lsb_release) ] && echo -ne "$(lsb_release -sd) "
    if [ -n "$(uname -r | grep 'microsoft')" ];then
        echo -ne "${CD}WSL2 "
    elif [ -n "$(uname -r | grep 'Microsoft')" ];then
        echo -ne "${CD}WSL "
    else
        echo -ne "${CD} "
    fi
    echo -e "$(uname -r)${C0}"
    echo -e "${CW}  $(hwinfoCountCoresReadable) $(hwinfoProcessor)${C0}"
}

function fn_defined {
  [ -n "${1}" ] && [ "$(type -t $1)" = 'function' ]
}

function fn_undef {
  unset -f $1
}

function fn_log {
  test -z "${1}" && ${2} || do_log "${1}" ${2}
  unset -f $2
}

array_join(){
  local IFS="${1}" && shift
  echo "$@"
}

#usage: str_concat 'sep' [arg_list]
str_concat(){
  local IFS="$1" && shift
  echo "$*"
}

# usage: str_contains str1 substr2
str_contains(){
   [ -z "${1##*${2}*}" ]
}

# usage: str_starts str1 substr2
str_starts(){
   [ "${1#${2}}" != "${1}" ]
}

str_ends(){
   [ "${1%${2}}" != "${1}" ]
}

str_lowercase(){
  echo ${1} | tr '[:upper:]' '[:lower:]'
}

str_uppercase(){
  echo ${1} | tr '[:lower:]' '[:upper:]'
}

defvar(){
  local k
  while [ -n "${1}" ]; do
    k=${1%=*}
    [ -z ${k+x} ] && eval $k=${1#*=}
  done
}

pushv(){
  while [ -n "${1}" ]; do
    shell_vstack+=("$1")
    shift
  done
  return 0
}

popv(){
  if [ -z "${1}" ]; then
    local n=${#shell_vstack[@]}
    if [ $n -gt 0 ]; then
      echo ${shell_vstack[n-1]}
      unset shell_vstack[-1]
    fi
  else while [ -n "${1}" ]; do
    eval "$1"="'$(popv)'"
    shift
    done
  fi
  return 0
}

clearv(){
  unset shell_vstack
}

pushdir(){
  case $SHELL in
    *bash) pushd $1 >/dev/null 2>&1;;
    *) pushvar_f shell_dstack $1; cd $1;;
  esac
}

popdir(){
  case $SHELL in
    *bash) popd >/dev/null 2>&1;;
    *) local d=$(popvar_f shell_dstack); [ -n "$d" ] && cd $d;;
  esac
}

# usage: set_bool <condition> <value_true> <value_false>
set_bool(){
  $1 && echo $2 || echo $3
}

inc_tab(){
  export indent=$((indent+2))
  export inds="${ind}┬─"
  export inde="${ind}└─"
  export ind+="│ "
  #echo "inctab: $indent $ind............"
}

dec_tab(){
  export indent=$((indent-2))
  [ ${#ind} -gt 1 ] && export ind="${ind::-2}"
  #echo "dectab: $indent $ind............"
}


# exclusive variable add substrings left var_xaddl <var> <substrings...>
# appends substrings to the left/start of var iff main doesnt contains substring
var_xaddl(){
  local v=$1; shift
    while [ -n "$1" ];do
        [ -z "${!v##*${1}*}" ] || eval $v=\"${1} ${!v}\"
        shift
    done
}

# exclusive variable add substrings right var_xaddl <var> <substrings...>
# appends substrings to the right/end of var variable iff main doesnt contains substring
var_xaddr(){
    local v=$1; shift
    while [ -n "$1" ];do
        [ -z "${!v##*${1}*}" ] || eval $v=\"${!v} ${1} \"
        shift
    done
}

var_addr(){
    local v=$1; shift; eval $v=\"${!v} $@\"
}

var_addl(){
    local v=$1; shift; eval $v=\"$@ ${!v}\"
}

# vercomp v1 v2 returns 0: v1=v2, 1: v1>v2, 2: v1<v2
vercomp () {
    test "$1" = "$2" && return 0
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        test -z "${ver2[i]}" && ver2[i]=0
        if ((10#${ver1[i]} > 10#${ver2[i]})); then return 1; fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then return 2; fi
    done
    return 0
}

rm_quiet(){
  rm -rf $@ 2>&1 >/dev/null
}

rm_log(){
  local log=$1; shift
  [ -f "${log}" ] && [ -n "$@" ] && rm -rf $@ 2>&1 >>${log}
}


time_elapsed(){
  if [ -n "${log_timestart}" ] && [ ${log_timestart} -gt 0 ];then
    local dt=$(($(date +%s) - ${log_timestart}))
    printf "+%-10s" $(date -u -d @${dt} +"%m:%S")
  else
    printf " --:-- "
  fi
}

url_dom(){
  echo "$1" | awk -F/ '{print $3}'
}


git_vendor(){
  echo "$1" | awk -F/ '{print $4}'
}

# usage: git_get_version srcdir
git_local_version(){
  local out;
  if [ -d "${1}/.git" ];then
    local d=$(pwd)
    cd ${1}
    out=$(git describe --abbrev=0 --tags 2>/dev/null)
    cd ${d}
  fi
  echo $out
}

git_api_tojson(){
  local s=$(echo "$1" | sed 's/https:\/\///g; s/\// /g; s/\.git$//')
  set -- $s
  case ${1} in
    github*) echo -e "$(curl https://api.github.com/repos/${2}/${3} 2>/dev/null)";;
    gitlab*) echo -e "$(curl -XGET -H "Content-Type: application/json" "https://${1}/api/v4/projects/${2}%2F${3}" 2>/dev/null)";;
    *) echo;;
  esac
}

get_latest_release() {
  local s=$(echo "$1" | sed 's/https:\/\///g; s/\// /g; s/\.git$//')
  set -- $s
  #echo -ne "$1: $2/$3"
  case $1 in
    github*) echo -e "$(curl --silent "https://api.github.com/repos/${2}/${3}/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')";;
  esac                                # Pluck JSON value
}

wget_untar(){
  local args
  case $1 in
    *.tar.lz) 
      [ -z $(command -v lzip) ] || exit 1
      args="--lzip -xv"
      ;;
    *.tar.gz|*.tgz) args="-xvz";;
    *.tar.xz) args="-xvJ";;
  esac
  [ -d "tmp" ] && rm -rf tmp
  mkdir tmp
  wget -qO- $1 2>/dev/null | tar --transform 's/^dbt2-0.37.50.3/dbt2/' $args -C tmp >/dev/null 2>&1 || exit 1
  cd tmp
  mv * $2 && mv $2 ..
  cd ..
  rm -rf tmp
}

gitlab_licence(){
  local s=$(echo "$1" | sed 's/https:\/\///g; s/\// /g; s/\.git$//')
  set -- $s
  if [ "$1" == "github.com" ];then
    echo -e "$(curl https://api.github.com/repos/${2}/${3} 2>/dev/null)"
  elif [ "${1}" != "${1#gitlab}" ];then
    local json=$(curl -XGET -H "Content-Type: application/json" "https://${1}/api/v4/projects/${2}%2F${3}" 2>/dev/null)
    local id=$(echo "$json" | jq .id)
    echo ${id} "curl --request GET https://${1}/api/v4/licence/${id}"
  else
    echo
  fi
}

github_json_desc(){
  echo "${1}" | jq .description | sed 's/"//g'
}

github_jq(){
  echo "${1}" | jq "${2}" | sed 's/"//g'
}

#usage: arch_fromid out_arm64 out_arm out_x86 out_x64
arch_fromid(){
  local xid=$(expr "$cpu_id" % 4)
  local args=("$@")
  echo "${args[${xid}]}"
}

#usage: arch_fromid out_android out_linux out_windows
os_fromid(){
  local xid=$(expr "$cpu_id" / 4 % 3)
  local args=("$@")
  echo "${args[${xid}]}"
}

load_hostfeats(){
  case $host_cpuid in
    0) arch="${arch_list[0]}"; host_arm=true; host_arm64=true; LIBSDIR+="${ldir_list[0]}";;
    1) arch="${arch_list[1]}"; host_arm=true; host_arm32=true; LIBSDIR+="${ldir_list[1]}";;
    2) arch="${arch_list[2]}"; host_x86=true; LIBSDIR+="${ldir_list[2]}";;
    3) arch="${arch_list[3]}"; host_x64=true; host_cross=false; LIBSDIR+="${ldir_list[3]}";;
  esac
}

format_pathlist(){
  local sep=$2
  local prf=$3
  local out=
  for a in $1; do
    out+="${prf}${a}${sep}"
  done
  echo "${out}"
}

# usage: patch_fromremote <base_url> patch1,...,...
patch_fromremote(){
  local baseUrl=$1; shift
  while [ -n "$1" ]; do
    wget -qO- ${baseUrl}/$1 | patch
    shift
  done
}

# usage: wget_source <src-url> <dst-dir>
wget_source(){
    local fn=$(basename $1) || exit_err "Invalid source url '$1'"
    [ -z "$2" ] && local dn=$(pwd) || local dn=$2
    case $fn in
      *.zip);;
      *.tar.lz|*.tlz) args="--lzip -xv";;
      *.tar.gz|*.tgz) args="-xvz";;
      *.tar.xz|*.txz) args="-xvJ";;
    esac
}

# usage: wget_pkg_termux <lib-name> <aarch64|arm|i686|x86_64> <dst-dir>
wget_pkg_termux(){
  [ -z "$1" ] || [ -z "$2" ] || [ ! -d "$3" ] && return 1
  echo -ne "searching for ${1}"
  local rname=$(wget -qO- http://termux.net/dists/stable/main/binary-${2}/ | grep -o ${1}_.*\.${2}\.deb\" | tail -n1)
  [ -z "${rname}" ] && echo -e " ${CR0}not found: aborting" && return 1
  rname=${rname:0:-1}
  echo -ne "${CY0}:found $rname"
  local od=$(pwd); cd ${3}
  [ -d "tmp" ] && rm -rf tmp
  mkdir -p tmp && cd tmp
  local url="http://termux.net/dists/stable/main/binary-${2}/${rname}"
  echo -ne " >download"
  wget -q $url
  [ ! -f "$rname" ] && echo -e "${CR1}:fail to download $url\n${C0}" && return 1
  echo -ne " >extract"
  ar -x $rname && tar -x -f data.tar.xz
  echo -ne " >fix paths"
  sed -i "s;/data/data/com.termux/files/usr;${3};g" data/data/com.termux/files/usr/lib/pkgconfig/*.pc 2>/dev/null
  cp -rf data/data/com.termux/files/usr/* ..
  cd .. && rm -rf tmp
  echo -e "${CG1} :done${C0}"
  cd $od
  return 0
}

#usage wget_pkg_debian [--list] <pkg-name> <filename-prefix> <arm64|armhf|armel|i386|amd64> dst-dir
wget_pkg_debian(){
  local lst=false
  local p_arch
  [ "$1" == "--list" ] && lst=true && shift
  case $3 in
    aarch64*) p_arch="arm64";;
    arm*hf)   p_arch="armhf";;
    arm*eabi) p_arch="armel";;
    i686*)    p_arch="i386";;
    x86_64*)  p_arch="amd64";;
    *) echo -e "${CR0} unknown $3${C0}"; return 1;;
  esac
  [ "${1::3}" == "lib" ] && local ldir=${1::4} || local ldir=${1::1}
  local url="http://ftp.debian.org/debian/pool/main/${ldir}/${1}/"
  echo $url
  if $lst; then
    local uris=$(curl -l ${url} 2>/dev/null | grep -o \>${2}_.*_${p_arch}.deb)
    for u in $uris; do
      echo ${url}${u:1}
    done
  else
    local od=$(pwd)
    if [ ! -d "$4" ];then
      mkdir -p $4 || return 1
    fi
    cd $4
    [ -d "tmp" ] && rm -rf tmp
    mkdir -p tmp && cd tmp
    local u=$(curl -l $url 2>/dev/null | grep -o \>${2}_.*_${p_arch}.deb | tail -n1)
    url="${url}${u:1}"
    echo $url
    wget -q $url
    ar -x $(basename ${url}) && tar -x -f data.tar.xz
    mv usr/lib/${3}/* usr/lib && rm -rf usr/lib/${3}
    sed -i "s|lib/${3}|lib|g;s|/usr|${4}|g" usr/lib/pkgconfig/*.pc 2>/dev/null
    cp -rf usr/* ..
    cd .. && rm -rf tmp
    echo -e "${CG1} :done${C0}"
    cd $od
  fi
}

libname_2_packagename(){
  if [ -n $(command -v apt) ]; then
    pkglist=$(apt-cache search --names-only ${lib})
  fi
}

list_pkgs(){
  local pd="${dir_root}/builds"
  case $1 in
    *-android*) wget -q "https://sourceforge.net/projects/packages-${1}/rss?path=/" -O - | grep -Po '<title><!\[CDATA\[.*</title>' | grep -Po '/.*tar.gz' | sed 's|/||'> ${pd}/$1_pkglist.txt;;
    *) return 1;;
  esac
}

get_link_pkg(){
  local pd="${dir_root}/builds"
  #[ -f "${pd}/${arch}_pkglist.txt" ] || list_pkgs ${arch}
  #local fn=$(cat "${pd}/${arch}_pkglist.txt" | grep "${lib}.*${arch}.tar.gz" | tail -n1)
  [ -z "${fn}" ] && [ -n "${dev_vrs}" ] && fn="${lib}_${dev_vrs}_${arch}.tar.gz"
  [ -n "${fn}" ] && echo "https://sourceforge.net/projects/packages-${arch}/files/${fn}"
  return 0
}

version_parse(){
  local IFS='.|-|_'
  export arrv=()
  for f in $1; do
    if [ ${#arrv[@]} -lt 3 ]; then
      f=$(echo $f | grep -o '[0-9]*')
    fi
    if [ -n "$f" ]; then
      arrv+=($f)
    fi
  done
  echo "${arrv[@]:0:3}" | sed 's/ /./g'
}

git_vremote(){
  local vrs_exclude='alpha|beta'
  local lgit=$(git ls-remote $src)
  local v=$(echo "${lgit}" | grep -oP '\d+\.\d+\.\d+.*' | grep -vP $vrs_exclude | tail -n1)
  [ -z "${v}" ] && v=$(echo "${lgit}" | grep -oP '\d+\.\d+.*' | grep -vP $vrs_exclude | tail -n1)
  if [ -n "${v}" ]; then
    echo "${v}"
  fi
  return 0
  awk -v vv="${lgit}" ss="${src}" -f - << 'EOF'
BEGIN {
  FS = "[ /^]+"
  while ("echo " vv "| sort -Vk2" | getline) {
    if (!sha)
      sha = substr($0, 1, 7)
    tag = $3
  }
  while ("curl -s " ss "/releases/tag/" tag | getline)
    if ($3 ~ "commits")
      com = $2
  printf com ? "%s-%s-g%s\n" : "%s\n", tag, com, sha
}
EOF
}

get_patch(){
  local match=$(grep -oP "(?<=^<<').*?(?=')" $1)
  local out
  if [ -n "${match}" ]; then
    out=${match}
    local block=$(awk '/^<<.'"$match"'./{flag=1; next} /^'"$match"'/{flag=0} flag' $1)
    out+="\n${block}"
  fi
  echo ${out}
}

test_c0(){
  #set -x
  local wdir="${dir_src}/${1}"
  if [ -d "${wdir}" ]; then
    local od="$(pwd)"
    cd $wdir
    echo -e "${2}" > testfile.c
    [ -n "$(command -v clang)" ] && cc=clang || cc=gcc
    $cc -c testfile.c && $cc -o testfile testfile.o && rm *.o
    ./testfile
    cd $od
  fi
  #set +x
  return 0
}

c_printf(){
  #set -x
  local wdir="${dir_src}/${1}"
  if [ -d "${wdir}" ]; then
    local od="$(pwd)"
    cd $wdir
    local hfile=$2
    local printf_expr=$3
    local cc
    if [ ! -f "testfile" ]; then
      cat <<-testfile >>testfile.c
				#include <stdio.h>
				#include "${hfile}"
				int main(){
				  printf(${printf_expr});
				}
				testfile
      [ -n "$(command -v clang)" ] && cc=clang || cc=gcc
      $cc -c testfile.c && $cc -o testfile testfile.o && rm *.o
    fi
    ./testfile
    cd $od
  fi
  #set +x
  return 0
}


# .language
# .homepage
# .size
# .licence.key
# .licence.name
# .licence.spdx_id