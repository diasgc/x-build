#!/bin/bash
# ................................................
# Commons 1.2.0-dev 2021-diasgc
# Definition constants and functions
# ................................................

function trap_sigint_common {
  tput cnorm
  cd "$(dirname $0)"
  local l
  [ -f "${log_file}" ] && l="  Log available at ${log_file}\n"
  echo -e "\n\n${CY1}  trap_sigint@common: Interrupted by user${C0}\n${l}\n"
  trap - SIGINT
  exit 1
}

shopt -s extglob
trap trap_sigint_common SIGINT

vsh='1.2.0-main'

#b="\u25ba"
b="\u2605"
c="\u2714"

# box chars
BX0="\u2502" BX1="\u251C" BX2="\u250C" BX3="\u2514" BX4="\u252C" BX5="\u2500"
BXH="${BX1}${BX5}${BX4}${BX5}${CY1}" BXL="${BX0} ${BX1}${BX5}${CY2}" BXE="${BX0} ${BX3}${BX5}${CY1}"

# def theme colors
C0="\e[0m" CW="\e[97m"  CD="\e[90m" CW2="\e[38;5;234m" CW3="\e[38;5;238m" CW4="\e[38;5;242m"  CW5="\e[38;5;246m" CW6="\e[38;5;250m"
CR0="\e[31m" CR1="\e[91m" CR2="\e[38;5;52m" CR3="\e[38;5;88m" CR4="\e[38;5;124m" CR5="\e[38;5;160m"  CR6="\e[38;5;196m"
CY0="\e[33m" CY1="\e[93m" CY2="\e[38;5;58m" CY3="\e[38;5;94m" CY4="\e[38;5;136m" CY5="\e[38;5;178m"  CY6="\e[38;5;220m"
CG0="\e[32m" CG1="\e[92m" CG2="\e[38;5;40m" CG3="\e[38;5;46m" CG4="\e[38;5;82m" CG5="\e[38;5;118m"  CG6="\e[38;5;154m"
CC0="\e[36m" CC1="\e[96m" CC2="\e[38;5;49m" CC3="\e[38;5;85m" CC4="\e[38;5;122m" CC5="\e[38;5;123m"  CC6="\e[38;5;195m"
CB0="\e[34m" CB1="\e[94m" CB2="\e[38;5;26m" CB3="\e[38;5;69m" CB4="\e[38;5;111m" CB5="\e[38;5;152m"  CB6="\e[38;5;153m"
CM0="\e[35m" CM1="\e[95m" CM2="\e[38;5;54m" CM3="\e[38;5;91m" CM4="\e[38;5;126m" CM5="\e[38;5;162m"  CM6="\e[38;5;198m"

CO0="\e[38;5;130m" CO1="\e[38;5;166m" CO2="\e[38;5;202m" CO3="\e[38;5;208m"  CO4="\e[38;5;214m" CO5="\e[38;5;220m" CO6="\e[38;5;223m"
CF0="\e[38;5;53m"  CF1="\e[38;5;89m"  CF2="\e[38;5;125m" CF3="\e[38;5;161m"  CF4="\e[38;5;197m" CF5="\e[38;5;211m" CF6="\e[38;5;219m"
CL0="\e[38;5;34m" CL1="\e[38;5;72m" CL2="\e[38;5;114m" CL3="\e[38;5;120m"  CL4="\e[38;5;156m" CL5="\e[38;5;192m" CL6="\e[38;5;230m"

# theme colors
CT0=$CM0 CT1=$CM1 CS0=$CR0 CS1=$CR1 SSB=$C0

# Logger
logtime_start=
export dir_root=$(pwd)

: "${shell_dstack:=}"

case $(uname -v) in
  *Ubuntu*)
    apt_install='apt -qq install -y'
    apt_search='apt search'
    apt_show='apt-cache show'
    export PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;95m\]\u@\e[0;95m\h\[\033[00m\]:\[\033[01;96m\]\w\[\033[00m\]\$ '
    ;;
  *) exit_err "Unknown $(uname -v) os, please provide package-install command in .common (line 48)";;
esac




# functions

# splash and banner
function splash {
  echo
  printf "${CB6}THE ▀▄ ▄▀   █▀▀▄ █  █ ▀█▀ █   █▀▀▄\n"
  printf "${CB1}     ▄▀▄ ▀▀ █▀▀▄ █  █  █  █   █  █\n"
  printf "${CB0}    ▀   ▀   ▀▀▀  ▀▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ \n\n"
  printf "${CW}   A cross complile build system\n\n${C0}"
}

function show_banner {
	echo -ne "\n\n${CW}Cross Build scripts ${vsh} for Linux${C0}\n"
  [ -n "$(command -v lsb_release)" ] && echo -ne "$(lsb_release -sd) "
  if [ -n "$(uname -r | grep 'microsoft')" ];then
    echo -ne "WSL2 "
  elif [ -n "$(uname -r | grep 'Microsoft')" ];then
    echo -ne "WSL "
  fi
  echo -e "$(uname -o) $(uname -m) ${C0} kernel $(uname -r)"
  echo -e "${CW}$(hwinfoCountCoresReadable) $(hwinfoProcessor)${C0}"
  is_running=true
}

function usage {
  printf "\n\n${CW}Usage: ${0} ${CC1}<host> ${CC1}<library-link> ${CB1}<builder-options> ${CM1}<other-options>${C0}\n\n"
  printf "${CW}host:${C0}native|[a-android|l-linux|w-windows][a-arm|x-x86][hf-armhf|7-armv7|8-armv8|86-x86|64-x64]\n"
  printf "          ${CC1}eg. aa8, lx64, wa64)\n\n"
  printf "${CC2}library:    --static* --shared | --both\n"
  printf "          --bin*|--no-bin \n\n"
  printf "${CB1}system:  --api <api> --cmake  --ndkcmake  --ccmake\n"
  printf "          --dist --strip --dirbuild <dir> \n\n"
  printf "${CB1}compiler: --clang*|--gcc --cpus\n"
  printf "          --tune <tune> --mcpu <mcpu> --mtune <mtune> \n\n"
  printf "          --update --upd-all --refresh --retry --force --clear\n"
  printf "          --patch <add|make|get> --diff --opts\n\n"
  printf "${CM1}control:  --desc --get --list --checkPkg --libName --var <var> \n\n"
  printf "${CM1}other:    --skip --goto \n\n"
  printf "Example targeting android armv8 build shared libs and executable:\n\n\n  ${CW}${0} aa8 --shared --bin --no-strip --no-dist\n\n\n${C0}"
}



# utils

# usage bool2int <condition>
# returns 1 for true and 0 for false
function bool2int {
	$1 && echo 1 || echo 0
}

# usage bool2str <condition> <string-true> <string-false>
# returns string-true for true and string-false for false
function bool2str {
	${1} && echo "${2}" || echo "${3}"
}

function safe_cd {
  cd "${1}" || exit_err "Could not find directory ${1}"
}

function safe_rm {
  while [ ${1} ]; do
    if [ -d "${1}" ]; then
      rm -rf "${1}" 2>/dev/null || exit_err "Could not delete dir ${1}"
    elif [ -f "${1}" ]; then
      rm -f "${1}" 2>/dev/null || exit_err "Could not delete file ${1}"
    fi
    shift
  done
}

function safe_mkdir {
  while [ ${1} ]; do
    if [ ! -d "${1}" ]; then
      mkdir -p "${1}" 2>/dev/null || exit_err "Could not create dir ${1}"
    fi
    shift
  done
}

function request_cmd {
	local c1=${1}
	local c2=${2}
	test -z "${c2}" && c2=${c1}
  if [ -z $(command -v ${c1}) ]; then
    ${sudo} ${apt_install} ${1} -y >/dev/null 2>&1 
  fi
	#test -z $(command -v ${c1}) && apt_install ${c2}
	return 0
}

function apt_install {
	while [ "$1" != "" ];do
		#echo -ne "  ${CT0}install $1${C0}"
		#echo -n " "
		stty size | {
		read y x
		echo -ne "${CY1}"
		tput sc
		tput cup "$((y - 1))" 0
		$sudo apt -qq install ${1} -y >/dev/null 2>&1
		echo -ne "${C0}"
		tput rc
		}
		#echo -ne "${C0} ok"
		shift
	done
}

function check_pkg_deb {
  for p in $@; do
    test -n $(apt search $p | grep -o "${p}") && echo "${p}" && break
  done
}

#usage xbuild --new <github_url>
function generate_script {
  test -z "${1}" && exit_err "Usage: xbuild --new <git-url>"
  
  local giturl="${1/\.git}"
  local libname="${giturl##*/}" && libname="${libname,,}"
  local scriptname="${dir_root}/${libname}.sh"
  
  cp "${dir_root}/utils/script.template" ${scriptname}
  chmod +x "${scriptname}"

  sed -i 's,@src@,'${giturl}',g;s,@lib@,'${libname}',g' ${scriptname}
  local pkgname="$(check_pkg_deb lib${libname//lib/}-dev ${libname}.-dev ${libname})"
  sed -i 's,@pkg_deb@,'${pkgname}',g' ${scriptname}

  case ${giturl} in
		*github*)
			local json=$(github_json $srcname)
			local libdesc=$(cat ${json} | jq .description | xargs)
			local lic=$(cat ${json} | jq .license.name | xargs)
			test -n "${libdesc}" && libdesc=${libdesc%%\. *} && sed -i 's/@desc@/'"${libdesc}"'/g' ${scriptname}
			test -n "${lic}" && sed -i 's/@lic@/'"${lic}"'/g' ${scriptname};;
	esac

  echo -e "${CD}${ind}${CD}    Done.New script generated: \e[4m${scriptname}\e[24m${C0}\n\n"
}

#usage xbuild --new <github_url>
generate_script_old(){
	test -z "${1}" && exit_err "Usage: xbuild --new <git-url>"
	local giturl="${1}"
	local srcname="${giturl/\.git/}"
	local libname="${srcname##*/}"
	libname="${libname,,}"
	case ${libname} in *.git) libname=${libname/\.git/};; esac
	local scriptname="${dir_root}/${libname}.sh"
	cp "${dir_root}/utils/script.template" ${scriptname}
	chmod +x "${scriptname}"
	sed -i 's,@src@,'${giturl}',g;s,@lib@,'${libname}',g' ${scriptname}
	local pkgname="lib${libname//lib/}-dev"
	test -z "$(apt-cache show ${pkgname} 2>/dev/null | grep ${pkgname})" && pkgname=
	sed -i 's,@pkg_deb@,'${pkgname}',g' ${scriptname}
	case $giturl in
		*github*)
			local json=$(github_json $srcname)
			local libdesc=$(cat ${json} | jq .description | xargs)
			local lic=$(cat ${json} | jq .license.name | xargs)
			test -n "${libdesc}" && libdesc=${libdesc%%\. *} && sed -i 's/@desc@/'"${libdesc}"'/g' ${scriptname}
			test -n "${lic}" && sed -i 's/@lic@/'"${lic}"'/g' ${scriptname};;
	esac
}


function get_source {
  
  # test internet connection
	wget -q --spider http://google.com
	[ ! $? -eq 0 ] && exit_err 'No Internet Connection. Aborting...'

	# check whether to custom get source
	if fn_defined 'source_get'; then
		fn_log 'get' source_get
		unset source_get
    return 0
  fi
  
  # check if source is already a tarball
  case "${src}" in
    *.tar.gz)      curl_targz "${src}" "${lib}" && return 0;;
    *.tar.*|*.zip) curl_tar "${src}" "${lib}" && return 0;;
  esac
  
  # git sub command requires git to apply
  test -n "${sub}" && src_rel=false
  
  if ${src_rel}; then
    if fn_defined 'on_src_release'; then
      on_src_release
    else
      case "${src}" in
        *github.com*) github_get_latest_tarball "${src}" "${lib}" && return 0;;
        *gitlab.com*) gitlab_get_latest_tarball "${src}" "${lib}" && return 0;;
        *googlesource.com*) googlesource_get_latest_tarball "${src}" "${lib}" && return 0;;
        *.git)        git_clone ${src} ${lib} ${src_opt} && return 0;;
      esac
    fi
	elif [ -n "${git}" ]; then
		git_clone "${git}" "${lib}" "${src_opt}"
		return 0
	elif [ -n "${svn}" ]; then
		svn_clone "${svn}" "${lib}"
		return 0
	elif [ -n "${hg}" ]; then
    hg_clone "${hg}" "${lib}"
    return 0
  fi
	case "${src}" in
			*.tar.*|*.tgz) curl_tar  "${src}" "${lib}";;
			*.git|*git*)   git_clone "${src}" "${lib}" "${src_opt}";;
			*svn.*)        svn_clone "${src}" "${lib}";;
			*)             exit_err "Unknown source type for ${src}";;
  esac
}


function github_jinfo {
  local id="$(sed 's,https://github\.com/,,;s,\.git$,,' <<<${1})"
}


# usage: github_set_src_release <git_url>
#   git_url: https://github.com/user/repo.git
#   prefix: prefix for name of source file (default none)
#   ext: extension for source file (default tar.gz)
function github_set_src_release {
  local id="$(sed 's,https://github\.com/,,;s,\.git$,,' <<<${1})"
  local json="$(curl -s https://api.github.com/repos/${id}/releases/latest)"
  test -z "${json}" && return 0
  local tarball_url=$(jq -r .tarball_url <<<${json})
  if [ "${tarball_url}" = "null" ]; then
    json=$(curl -sL "https://api.github.com/repos/${s}/tags")
    tarball_url=$(jq -r .[0].tarball_url <<<${json})
    if [ "${tarball_url}" = "null" ]; then
      git_clone ${src} ${lib} ${src_opt}
      return 0
    fi
    vrs=$(jq -r .[0].name <<<${json})
  else
    vrs=$(jq -r .tag_name <<<${json})
  fi
	dir_src="${dir_sources}/${2}"
  local tag="get ${vrs}"
  echo -ne "${CD}${tag}${C0}"
  test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
	curl -sL ${tarball_url} -w %{url_effective} 2>>"${log_file}" | tar -xz -C ${dir_src} --strip-components=1 2>>"${log_file}"
	logok "${tag}"
}

# git_clone <source> <libname/destfolder> <options>
function git_clone {
  local t="git"
	echo -ne "${CD}${t}"
	logf git clone --progress --verbose ${src} ${lib} ${src_opt}
	git clone --progress --verbose ${src} ${lib} ${src_opt} |& tr '\r' '\n' | prt_git_progress
	logok "${t}"
	test -d "${lib}" && cd ${lib} || err
	if [ -n "${bra}" ]; then
		do_log ${bra} git checkout ${bra}
		unset bra
	elif [ -n "${vrs}" ]; then
		do_log ${vrs} git checkout tags/${vrs}
	fi
	if [ -n "${sub}" ];then
		do_log 'sub' git ${sub} |& tr '\r' '\n' | prt_git_progress
	fi
  vrs="$(git tag -l | tail -n1)"
  echo -ne "${CT0}[${vrs}]${CD} "
	cd ..
}

function prt_git_progress {
	tput civis
	printf "%-8s"
	local s0
	local s1
	local n1=0
	while read -r ln; do
		if ! [ "${ln%\'...}" == "${ln}" ]; then
		printf "\e[7D"
		printf "%-40s\e[40D"
		s1=${ln#*\'}
		s1=${s1##*/}
		s1=${s1%\'...}
		printf "\e[${n1}D"
		n1=${#s1}
		[ $n1 -gt 0 ] && printf " %-${n1}s" $s1
		printf "%-6s"
		else
		s0=$(grep -oP '\d+%' <<< $ln)
		[ -n "$s0" ] && printf "\e[5D%-5s" $s0
		fi
	done
	[ $n1 -gt 0 ] && printf "\e[${n1}D"
	printf "\e[7D"
	tput cnorm
}

function svn_clone {
	request_cmd svn subversion || err
	do_log 'svn' svn checkout $1 $2
}

function hg_clone {
	request_cmd hg mercurial || err
	do_log 'clone' hg clone $1 $2
}


# usage: github_get_latest_tarball <git-url> <dest-dir>
# result: from the git-url, set vrs to the latest release
# and downloads + extracts tarball to dest-dir
function github_get_latest_tarball {
  local s="$(sed 's,https://github\.com/,,;s,\.git$,,' <<<${1})"
  local json="$(curl -s https://api.github.com/repos/${s}/releases/latest)"
  local tarball_url=$(jq -r .tarball_url <<<${json})
  if [ "${tarball_url}" = "null" ]; then
    json=$(curl -sL "https://api.github.com/repos/${s}/tags")
    tarball_url=$(jq -r .[0].tarball_url <<<${json})
    if [ "${tarball_url}" = "null" ]; then
      git_clone ${src} ${lib} ${src_opt}
      return 0
    fi
    vrs=$(jq -r .[0].name <<<${json})
  else
    vrs=$(jq -r .tag_name <<<${json})
  fi
	dir_src="${dir_sources}/${2}"
  local tag="get ${vrs}"
  echo -ne "${CD}${tag}${C0}"
  test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
	curl -sL ${tarball_url} -w %{url_effective} 2>>"${log_file}" | tar -xz -C ${dir_src} --strip-components=1 2>>"${log_file}"
	logok "${tag}"
}

function gitlab_get_latest_tarball {
  vrs="$(git_version_remote ${src})"
  src="${src%%\.git}/-/archive/${v}/${vrs}.tar.gz"
  curl_tar ${src} ${lib}
}

function googlesource_get_latest_tarball {
  vrs="$(git_version_remote ${1})"
  src="${src%%\.git}/+archive/${vrs}.tar.gz"
  curl_tar "${src}" "${lib}"
}

#usage tar_version <url-dir> <prefix>
function tar_version {
    curl -sL "${1}" | grep -oP "${2}[0-9\.]+.tar.gz" | sed "s,${2},,;s,.tar.gz,," | sort -rV | head -n1
}

function curl_tar {
	local tag="get"
	local args=
	dir_src="${dir_sources}/${2}"
	echo -ne "${CD}${tag}${C0}"
	echo "$(date): $@" >> "${log_file}"
	
	case "${1}" in
		*.tar.lz)        request_cmd 'lzip' && args='--lzip -xv';;
		*.tar.gz|*.tgz)  args="-xz";;
		*.tar.xz)        args="-xJ";;
		*.tar.bz2)       args="-xj";;
	esac
	
	test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
	curl_tar_simple ${1} ${args}
	
	logok "${tag}"
}

function curl_tar_simple {
  local args=(${2:=-xz})
  if ${tar_stripcomponents}; then
    args+=('-C' "${dir_src}" '--strip-components=1')
  else
    args+=("--one-top-level=${dir_src}")
  fi
  curl -sL "${1}" 2>>"${log_file}" | tar ${args[@]} 2>>"${log_file}"
}

function curl_targz {
  local tag="get"
	dir_src="${dir_sources}/${lib}"
	echo -ne "${CD}${tag}${C0}"
	echo "$(date): $@" >> "${log_file}"
  test -d "${dir_src}" && rm -rf "${dir_src}"
	mkdir "${dir_src}"
  if ${tar_stripcomponents}; then
    curl -sL "${1}" 2>>"${log_file}" | tar -xz -C ${dir_src} --strip-components=1 2>>"${log_file}"
  else
	  curl -sL "${1}" 2>>"${log_file}" | tar -xz --one-top-level=${dir_src} 2>>"${log_file}"
  fi
	logok "${tag}"
}

# git_latest_tgz <git-url>
function git_latest_tgz {
  local src="${1}"
	case "${src}" in
		*github.*)
			local dst="$(sed 's,.git$,,' <<<${src})"
			local url=$(curl -ILs -o /dev/null -w %{url_effective} "${dst}/releases/latest")
			local file=$(curl -s ${url} | grep -Po '(?<=>)[^<]*' | grep -Po '.*tar.gz$')
			echo "${url}/${file}"
		;;
		*gitlab.*|*code.videolan.org*)
			local v="$(git_version_remote ${src})"
			echo "${src%%\.git}/-/archive/${v}/${lib}-${v}.tar.gz"
		;;
		*.googlesource.*)
			local tag="$(git -c 'versionsort.suffix=-' ls-remote --refs --sort='v:refname' ${src} | tail -n1 | cut -f1)"
			echo "${src}/+archive/${tag}.tar.gz"
		;;
	esac
}

function git_version_local(){
  pushd ${dir_src} > /dev/null
  local v=$(git describe --tags)
  local out=$(grep -oP '[0-9]+\.[0-9]+\.[0-9]+' <<<${v})
  test -z "${out}" && out=$(grep -oP '[0-9]+\.[0-9]+' <<<${v})
  test -z "${out}" && out=${v}
  echo "${out}"
  popd > /dev/null
}

function git_version_remote {
  local out="$(git ls-remote --tags --refs --sort="v:refname" ${1} 2>/dev/null | tail -n1)"
  echo "${out##*\/}"
}

# usage github_latest_release <user/repo id> or <git url>
function github_latest_release {
  # extract id from url, in case it is not already given
  local s="$(sed 's,https://github\.com/,,;s,\.git$,,' <<<${1})"
  # get version tag name
	echo $(curl --silent "https://api.github.com/repos/${s}/releases/latest" | jq -r .tag_name)
}

git_getversion(){
  [ -d "${1}" ] && git --git-dir=${1}/.git --work-tree=${1} describe --abbrev=0 --tags || git describe --abbrev=0 --tags
}

function package_showinfo {
	${banner} || return 0
	local dp=
	local vs=
	local longdesc=$(package_longdesc)
	[ -z "$(echo ${longdesc} | xargs 2>/dev/null)" ] && unset longdesc

	# Main Description
	[ -n "${dsc}" ] && echo -e "\n${CD}${inds}${CW}\e[1m${lib^^} - ${C0}${dsc}\e[0m"
	[ -n "${longdesc}" ] && echo -e "${CD}${longdesc}" | sed 's|\*|\u2605|g; s|\..\..|. |g' # sed 's|^|'${ind}|g'

	# see links
	echo -e "${CD}${ind}${CD}"
	echo -e "${CD}${ind}${CD}see log   : \e[4m${log_file}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}    script: \e[4m${0}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}    source: \e[4m${dir_src}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}    build : \e[4m${dir_install}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}"

	# Licence
	echo -ne "${CD}${ind}${CT0}Licence ${C0}$lic "

	# Build Tools
	if [ -n "${tls}" ]; then
		echo -ne "${CT0}build deps: "
		tput sc; echo -ne "${CD}$tls "; tput rc
		for t in ${tls}; do
			request_cmd ${t}
		shift
		done
	fi

	# Build Deps
	[ -n "${dep}" ] && dp="${dp}${CT0}lib deps: ${C0}${dep}"

	if [ -n "${vrs}" ]; then
		log_info "version: ${vrs}"
	elif [ -d "${dir_src}/.git" ]; then
		local gitloc="$(git_version_local ${dir_src})"
		local gitrem="$(git_version_remote ${src})"
		if [ "${gitloc}" = "${gitrem}" ]; then
			gitrem="updated"
		else
			gitrem="latest: ${gitrem}"
		fi
		log_info "version: ${C0}${gitloc} (${gitrem})"
	elif str_contains ${src} "git"; then
		local gitrem="$(git_version_remote ${src} | head -n1)"
		log_info "version: ${C0}${gitrem}"
	fi
}

function package_longdesc {
	if [ -n "${pkg_deb}" ]; then
		echo -e $(apt-cache show ${pkg_deb} 2>/dev/null | \
		grep -E "Description-..^|^ " | \
		sed $'s/\*/\u2605/g' | \
		sed '/^ *This package contains.*\./d') | fold -s -w120 | sed 's/^/'"${ind}"'/g'
	fi
	return 0
}

function check_tools {
	while [ -n "$1" ]; do
		toolname=${1}
		toolpkg=${1}
		case "${1}" in
			rust )      installRust && continue;;
			libtool )   toolname=libtoolize;;
			texinfo )   toolname=makeinfo;;
		esac
		request_cmd ${toolname} ${toolpkg}
		shift
	done
}

function patch_fromfilelist {
  pushd "${dir_src}" 2>&1 >/dev/null
  local f
  for p in ${patch[@]}; do
    f="${dir_root}/patches/${p}.patch"
    test -f "${f}" && patch -p0 <"${f}" 2>&1 >"${log_file}"
  done
  popd 2>&1 >/dev/null
}

function install_rustc {
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
  source $HOME/.cargo/env
}

function install_cargo_cbuild {
  cargo install cargo-c --features=vendored-openssl  
}

# usage: search_configfile <config-file> (ex. CMakeLists.txt, configure, meson.build)
# returns: nearest source root location of config file
search_configfile(){
  local cmd="${1}"
  local dest="$(find ${dir_src} -name ${cmd} -printf "%d %p\n"|sort -n|head -n1)"
  if [ -n "${dest}" ]; then
    dest="$(sed 's,.*'${dir_src}'/,,;s,/'${cmd}',,' <<<${dest})"
    echo "${dir_src}/${dest}"
  else
    echo
  fi
}


function show_build_opts {
  : "${dir_src:=${dir_root}/sources/${lib}}"
  test ! -d "${dir_src}" && exit_err "${dir_src} does not exist. Download source first."
	local cf
  local d
	# search meson
	cf="$(search_configfile meson_options.txt)"
	if [ -n "${cf}" ]; then
    d="${dir_root}/builds/${lib}_meson.opts"
		cat "${cf}" | tr '\n' ' ' | sed 's/  */ /g;s/option(/\n/g;s/)/\n/g;s/'feature'/enabled|disabled/g;s/'boolean'/true|false/g;s/,/\n/g' >"${d}"
		echo -e "\n\t${CY0}Found meson options: ${d}\n"
	fi
	# search cmake
	cf="$(search_configfile CMakeLists.txt)"
	if [ -n "${cf}" ]; then
    d="${dir_root}/builds/${lib}_cmake.opts"
		cmake ${cf} -LA 2>/dev/null | awk '{if(f)print} /-- Cache values/{f=1}' >"${d}"
		echo -e "\n\t${CY0}Found cmake options: ${d}\n"
	fi
	# search automake
	cf="$(search_configfile configure)"
	if [ -n "${cf}" ]; then
    d="${dir_root}/builds/${lib}_am.opts"
		${cf} --help | grep -o '\-\-.*' >"${d}"
		echo -e "\n\t${CY0}Found automake options: ${d}\n"
	fi
}

function am_config_guess {
  if [ -f "${dir_config}/autogen.sh" ]; then
    do_am_autogen ${dir_config} --noconfigure
  elif [ -f "${dir_config}/bootstrap.sh" ]; then
    do_log 'bootstrap' ${dir_config}/boostrap.sh
  elif [ -f "${dir_config}/bootstrap" ]; then
    do_log 'bootstrap' ${dir_config}/boostrap
  elif [ -f "${dir_config}/configure.ac" ]; then
    do_am_autoreconf ${dir_config}
  elif [ -f "${dir_config}/configure" ]; then
    cfg='ac'
  else
    exit_err "No automake configure file. Exiting..."
  fi
}

function do_am_autogen {
	local tag='autoreconf'
	echo -ne "${CD}${tag}${C0}"
	pushdir ${1} && shift
	case ${1} in
		--noerr ) ./autogen.sh >>${log_file} 2>&1;;
		--noconfigure ) NOCONFIGURE=1 log_this ./autogen.sh;;
		* ) log_this ./autogen.sh;;
	esac
	popdir
	logok ${tag}
}

function do_am_autoreconf {
	local tag='autoreconf'
	echo -ne "${CD}${tag}${C0}"
	pushdir ${1}
	log_this autoreconf -fiv
	popdir
	logok ${tag}
}

function config_guess {
  if [ -f "${dir_config}/meson.build" ]; then
    build_system="meson"
    cfg="meson"
  elif [ -f "${dir_config}/CMakeLists.txt" ]; then
    build_system="cmake"
    cfg="cmake"
  elif [ -n "$(ls ${dir_config}/configure* 2>/dev/null)" ]; then
    build_system="automake"
    cfg='ac'
    if [ -f "${dir_config}/autogen.sh" ]; then
      cfg_cmd="${dir_config}/autogen.sh"
	    cfg='ag'
    elif [ -f "${dir_config}/bootstrap.sh" ]; then
      cfg_cmd="${dir_config}/bootstrap.sh"
    elif [ -f "${dir_config}/bootstrap" ]; then
      cfg_cmd="${dir_config}/bootstrap"
	  elif [ -f "${dir_config}/configure.ac" ]; then
	    cfg='ar'		
    elif [ ! -f "${dir_config}/configure" ]; then
      cfg_cmd="autoreconf -fiv ${dir_config}/bootstrap"
    else
      return 1
    fi
  else
    return 1
  fi
  return 0
}

function setup_cmake_config {
  # build: make
  
  : "${cmake_builddir:=${dir_config}}"
  : "${cfg_cmd:=${CMAKE_EXECUTABLE}}"
  : "${cmake_shared:=BUILD_SHARED_LIBS}"
  
  cfg_args=("${cmake_builddir}" "-DCMAKE_INSTALL_PREFIX=${dir_install}" "-DCMAKE_BUILD_TYPE=${cmake_build_type}")
  
  if ${host_cross}; then
    [ -z "${cmake_toolchain_file}" ] && cmake_create_toolchain "${dir_build}"
    [ -f "${cmake_toolchain_file}" ] && cfg_args+=( "-DCMAKE_TOOLCHAIN_FILE=${cmake_toolchain_file}" )
  fi

  test -n "${cmake_config}" && cfg_args+=( "${cmake_config}" )

  case "${cmake_shared}" in
    -D*=*) ${build_shared} && cfg_args+=( "${cmake_shared}" );;
    *)     cfg_args+=( "-D${cmake_shared}=$(bool2str ${build_shared} ON OFF)" );;
  esac
  if [ -z "${cmake_static}" ]; then
    cmake_static="$(grep -oP 'BUILD_STATIC_LIBS' ${dir_config}/CMakeLists.txt | head -n1)"
  fi
  if [ -n "${cmake_static}" ]; then
    case "${cmake_static}" in
      -D*=*) ${build_static} && cfg_args+=( "${cmake_static}" );;
      *)     cfg_args+=( "-D${cmake_static}=$(bool2str ${build_static} ON OFF) ${lib_link}");;
    esac
  fi
  if [ -n "${cmake_bin}" ]; then
    case "${cmake_bin}" in
      -D*=*) ${build_bin} && cfg_args+=( "${cmake_bin}" );;
      *) cfg_args+=( "-D${cmake_bin}=$(bool2str ${build_bin} ON OFF)" );;
    esac
  fi
  test -n "${CPACK}" && cfg_args+=( "${CPACK}" )
  cfg_args+=( -Wno-dev )

  : "${build_cmd:=${MAKE_EXECUTABLE}}"
  : "${install_cmd:=${MAKE_EXECUTABLE}}"
  : "${make_install:=install}"
  : "${install_args:=${make_install}}" 

  test -n "${make_args}" && build_args+=( "${make_args}")
  build_args+=( "-j${HOST_NPROC}")
  build_tag="make"
  
  
  #do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
  #case ${cfg} in ccm|ccmake) tput sc; ccmake ..; tput rc;; esac
}

function setup_am_config {

  # use autotools and configure executable to create makefile
  ${ac_reconf} && autoreconf -fi 2>/dev/null >>${log_file}

  cfg_cmd="${dir_config}/configure"

	if [ -n "${ac_opts}" ]; then
		for opt in $(echo ${ac_opts}); do
			case $opt in
				--update-config_sub)
					logf 'Apply --update-config_sub'
					local fpath=$(find ${dir_src} -name 'config.sub')
					test -f "${fpath}" && cp -f /usr/share/automake*/config.sub ${fpath}
					;;
				--update-config_guess)
					logf 'Apply --update-config_guess'
					local fpath=$(find ${dir_src} -name 'config.guess')
					test -f "${fpath}" && cp -f /usr/share/automake*/config.guess ${fpath}
					;;
				--no-sysroot)
					am_nosysroot=true
					;;
				--no-pic)
					am_nopic=true
					;;
				--no-host)
					am_nohost=true
					;;
			esac
		done
	fi

  cfg_args=("--prefix=${dir_install}")

  if ! ${am_nohost} && ${host_cross} && [ -n "$(grep '\-\-host' ${cfg_cmd})" ]; then 
    ${am_nohost} || cfg_args+=( "--host=${arch}" )
  fi

	if ! ${am_nosysroot}; then
		if [ -n "$(grep '\-\-with-sysroot' ${cfg_cmd})" ]; then
			cfg_args+=( "--with-sysroot=${SYSROOT}" )
		elif [ -n "$(grep '\-\-sysroot' ${cfg_cmd})" ]; then
			cfg_args+=( "--sysroot=${SYSROOT}" )
		fi
	fi

	if ! ${am_nopic} && ! ${host_mingw} && [ -n "$(grep '\-\-with-pic' ${cfg_cmd})" ]; then
		cfg_args+=( "--with-pic" )
	fi
	
  # find static build option
  : "${am_static:=static}"
  cfg_args+=( "--$(bool2str ${build_static} enable disable)-${am_static}" )
  
  #if ${build_static}; then
  #  if [ -n "${am_static}" ]; then
  #    cfg_args+=( "${am_static}" )
  #  elif [ -n "$(grep '\-\-enable-static' ${cfg_cmd})" ]; then
  #    cfg_args+=( "--enable-static")
  #  fi
  #fi

  # find shared build option
  : "${am_shared:=shared}"
  cfg_args+=( "--$(bool2str ${build_shared} enable disable)-${am_shared}" )

  #if ${build_shared}; then
  #  if [ -n "${am_shared}" ]; then
  #    cfg_args+=( "${am_shared}" )
  #  elif [ -n "$(grep '\-\-enable-shared' ${cfg_cmd})" ]; then
  #    cfg_args+=( "--enable-shared")
  #  fi
  #fi
  
  if [ -n "${am_bin}" ]; then
    case "${am_bin}" in
      --*) cfg_args+=( "${am_bin}" );;
      *)   cfg_args+=( "--$(bool2str ${build_bin} enable disable)-${am_bin}");;
    esac
  fi
  test -n "${am_config}" && cfg_args+=( "${am_config}" )

  : "${build_cmd:=${MAKE_EXECUTABLE}}"
  : "${install_cmd:=${MAKE_EXECUTABLE}}"
  : "${make_install:=install}"
  : "${install_args:=${make_install}}" 
  test -n "${make_args}" && build_args+=( "${make_args}")
  build_args+=( "-j${HOST_NPROC}")
  build_tag="make"
}

# see https://mesonbuild.com/Commands.html for command line options
function setup_meson_config {
  
  : "${build_cmd:=ninja}"
  : "${install_cmd:=ninja}"
  : "${install_args:=install}"
  build_tag="ninja"
  test -n "${make_args}" && build_args+=( "${make_args}")
  build_args+=( "-j${HOST_NPROC}" )

  cfg_cmd='meson'
  cfg_args=('setup' '--buildtype=release' "--prefix=${dir_install}")
  
  if ${host_cross}; then
    local cfg_file="${dir_config}/${arch}.meson"
    meson_create_toolchain ${cfg_file}
    cfg_args+=("--cross-file=${cfg_file}")
  fi

  ${host_clang} || LD="bfd"
  
  : "${meson_static:=-Ddefault_library=static}"
  : "${meson_shared:=-Ddefault_library=shared}"

  if ${build_static} && ${build_shared}; then
    cfg_args+=( '-Ddefault_library=both' )
  elif ${build_static}; then
    cfg_args+=( "${meson_static}" ' --prefer-static')
  elif ${build_shared}; then
    cfg_args+=( "${meson_shared}" )
  fi

  if [ -n "${meson_bin}" ]; then
    case "${meson_bin}" in
      bool:*)
        meson_bin="${meson_bin#bool:*}"
        cfg_args+=( "-D${meson_bin}=$(bool2str ${build_bin} 'true' 'false')" )
        ;;
      *)
        meson_bin="${meson_bin#*:*}"
        cfg_args+=( "-D${meson_bin}=$(bool2str ${build_bin} enabled disabled)" )
        ;;
    esac
  fi
  
  test -n "${meson_config}" && cfg_args+=( "${meson_config}" )
}

# check build system and set defaults - static and shared build options
function config_init {

	# if no cfg provided, try to guess
	test -z "${cfg}" && config_guess
	test -z "${cfg}" && exit_err 'No build system found. Exiting.'
	
	case "${cfg}" in
		cm|ccm|cmake|ccmake)
			build_system=cmake
			;;
		ab|am|ac|ar|ag|auto*)
			build_system=automake
			;;
		meson)
			build_system=meson
			;;
    bazel)
      build_system=bazel
      ;;
    cargo)
      build_system=cargo
      lib_link="--library-type=$(bool2str ${build_static} staticlib dylib)"
      ;;
		mk|make) build_system=make;;
		other) build_system=other;;
		*) unset build_system;;
	esac
}


#usage build_pkgconfig [--filename=lib.pc][--prefix=install_dir]...[--libs=-la,-lb,-lc,...]
function build_pkgconfig {

	local pkgconfig_file="${lib}.pc"
	local pkgconfig_prefix=${dir_install}
	local pkgconfig_exec_prefix="\${prefix}"
	local pkgconfig_libdir="\${prefix}/lib"
	local pkgconfig_includedir="\${prefix}/include"
	local pkgconfig_description="${dsc}"
	local pkgconfig_url="${url}"
	local pkgconfig_version="${vrs}"
	local pkgconfig_requires=
	local pkgconfig_requires_private=
	local pkgconfig_libs="-l${lib/lib/}"
	local pkgconfig_libs_private=
	local pkgconfig_cflags="-I\${includedir}"

	while [ -n "${1}" ]; do
		case "${1}" in
			--name=*) pkgconfig_file="${1#*=}.pc";;
			--filename=*) pkgconfig_file="${1#*=}";;
			--prefix=*) pkgconfig_prefix="${1#*=}";;
			--exec_prefix=*) pkgconfig_exec_prefix="${1#*=}";;
			--libdir=*) pkgconfig_libdir="${1#*=}";;
			--includedir=*) pkgconfig_includedir="${1#*=}";;
			--description=*) pkgconfig_description="${1#*=}";;
			--url=*) pkgconfig_url="${1#*=}";;
			--version=*) pkgconfig_version="${1#*=}";;
			--requires=*) pkgconfig_requires="${1#*=}";;
			--requires-private=*) pkgconfig_requires_private="${1#*=}";;
			--libs=*) pkgconfig_libs="${1#*=}";;
			--libs-private=*) pkgconfig_libs_private="${1#*=}";;
			--cflags=*) pkgconfig_cflags="${1#*=}";;
		esac
		shift
	done
	
	pkgconfig_libs="-L\${libdir} ${pkgconfig_libs//,/ }"
	pkgconfig_file="${dir_install_pc}/${pkgconfig_file}"
	test -f "${pkgconfig_file}" && rm -f "${pkgconfig_file}"

	cat <<-EOF >"${pkgconfig_file}"
		prefix=${pkgconfig_prefix}
		exec_prefix=${pkgconfig_exec_prefix}
		libdir=${pkgconfig_libdir}
		includedir=${pkgconfig_includedir}

		Name: ${lib}
		Description: ${pkgconfig_description}
		URL: ${pkgconfig_url}
		Version: ${pkgconfig_version}
		Requires: ${pkgconfig_requires//,/ }
		Requires.private: ${pkgconfig_requires_private//,/ }
		Libs: ${pkgconfig_libs//,/ }
		Libs.private: ${pkgconfig_libs_private//,/ }
		Cflags: ${pkgconfig_cflags}

		EOF
}

# usage create_pkgconfig_file <pkg>.pc [llibds][INSTALL_DIR]
function create_pkgconfig_file_old {
	[ -z "${1}" ] && pc_file=${lib} || pc_file=${1}
	[ -z "${2}" ] && pc_llib="-l${pc_file}" || pc_llib=${2}
	[ -z "${3}" ] && pc_prefix=${dir_install} || pc_prefix=${3}
	[ "${pc_llib}" == "null" ] && pc_llib=''
	[ -z "$pc_libdir" ] && pc_libdir="/lib"
	[ -z "$pc_incdir" ] && pc_incdir="/include"
	[ -z "$pc_cflags" ] && pc_cflags="-I\${includedir}"
	[ -z "$pc_libs" ] && pc_libs="-L\${libdir}"
	[ -z "$pc_url" ] && pc_url=$(dirname $src)
	fn_defined 'get_version' && get_version && pc_vrs=$vrs
	[ -z "$pc_vrs" ] && {
	[ -d "${dir_src}/.git" ] && pc_vrs=$(git_getversion ${dir_src}) || pc_vrs=$vrs
	}
	cat <<-EOF >${dir_install_pc}/${pc_file}.pc
		prefix=${pc_prefix}
		exec_prefix=\${prefix}
		libdir=\${exec_prefix}${pc_libdir}
		includedir=\${prefix}${pc_incdir}

		Name: ${lib}
		Description: ${dsc}
		URL: ${pc_url}
		Version: ${pc_vrs}
		Requires: ${pc_requires}
		Requires.private: ${pc_requiresprivate}
		Libs: ${pc_libs} ${pc_llib}
		Libs.private: ${pc_libsprivate}
		Cflags: ${pc_cflags}

		EOF
	pc_filelist="${pc_file}.pc ${pc_filelist}"
	unset pc_libdir pc_incdir pc_cflags pc_libs pc_url
}

function log {
	echo -ne "$CD$@$C0"
}

# usage: log <logfile> [--noerr|--progress] <label> <commands....>
function log_unused2 {
  local noerr=false
  local progress=false
  while $(str_starts $1 '--');do
    case $1 in
      --noerr) noerr=true;;
      --progress) progress=true;;
    esac
    shift
  done
	local label=$1; shift
	echo -ne "${CD}${label}${C0}"
	echo -e "\n$(time_elapsed): $@" >> "$logfile"
  if $progress; then
	  ("$@" |& log_progress) || err "in ${act}:\n\n...\n$(tail -n5 ${logfile}${C0})"
  else
	  "$@" 2>> "$logfile" 1>> "$logfile" || err
  fi
	echo -ne "\e[${#label}D${CT0}${label}${C0} "
}

function logf {
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
}

function logok {
	echo -ne "\e[${#1}D${CT0}${1}${C0} "
}

# usage logver /path/to/pkgconfigfile.pc
function logver {
	if [ -f ${1} ]; then
		echo -ne "${CT1}version $(pkg-config --modversion ${1})${C0}"
	else
		echo -ne "${CS0} missing ${1} ${C0}"
	fi
}

function log_vars {
	local t;
	while [ -n "$1" ]; do
		echo "$1=${!1}" >>"${log_file}" 2>&1
		shift
	done
	echo >>"${log_file}"
}

function log_info {
  echo -e "${CD}${ind}${CT0}${1}${C0} "
}

function log_start {
	logtime_start=$(date +%s)
  local timefmt='+%H:%M'
  [ ${eta} -lt 60 ] && timefmt='+%H:%M:%S'
	if ! ${inline}; then
		echo -ne "${CD}${inde}${C0}$(date ${timefmt})"
		[ ${eta} -gt 0 ] && echo -ne "-${CW}$(date ${timefmt} --date="${eta} seconds")"
		printf " ${CT1}%-10s ${CT1}%-21s${CD} " ${lib} ${arch}
	fi
	echo $(date) >"${log_file}"
}

function log_end {
	if ! ${inline} && [ -n "${logtime_start}" ]; then
		logtime_end=$(date +%s)
		local secs=$((${logtime_end}-${logtime_start}))
		eta=$(secs2time ${secs})
		echo -e "${CT1} done ${CD}in ${eta}"
		eta="$((${secs}*$(nproc)))"
	fi
}

function log_this {
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	"$@" 2>> "${log_file}" 1>> "${log_file}" || err
	logok
}

function log_progress {
  printf "%-6s"
  local sln
  IFS=$'\n'
  while read -r ln; do
    # $has_logfile && \
    printf "%-6s: %s\n" $(time_elapsed) $ln >>${logfile}
    str_contains $ln 'error: ' && printf $CR1
    sln=$(grep -oP '\d+%' <<< $ln)
    [ -n "$sln" ] && printf "\e[5D%-5s" $sln
  done
  printf "\e[6D"
  unset IFS
}

function exit_err {
	echo -e "${CR1}  Error: ${CR0}${1}${C0}\n\n"
	if [ -f "${log_file}" ];then
		if [ -f "${dir_build}/CMakeFiles/CMakeError.log" ];then
		  echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> "${log_file}"
		  cat "${dir_build}/CMakeFiles/CMakeError.log" >> "${log_file}"
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "${openlog}" != "n" ] && nano "${log_file}"
	fi
	exit 1
}

function err {
	if [ -n "${logtime_start}" ]; then
    # consider use of ${EPOCHREALTIME/.} instead
		logtime_end=$(date +%s)
		echo -e "${CR1} fail ${CR0}[$(secs2time $((${logtime_end}-${logtime_start})))]${C0}\n"
	fi
	if [ -f "${log_file}" ];then
		if [ -f "${dir_build}/CMakeFiles/CMakeError.log" ];then
		  echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> "${log_file}"
		  cat "${dir_build}/CMakeFiles/CMakeError.log" >> "${log_file}"
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "${openlog}" != "n" ] && nano ${log_file}
	fi
	echo
	exit 1
}

function secs2time {
	[ $(($1/60%60)) -eq 0 ] && printf '%ds' $(($1%60)) || printf '%dm %ds' $(($1/60%60)) $(($1%60))
}

function log_buildvars {
  printf "Build system: ${build_system}\nConfig args:\n" >>${log_file}
  printf '%s\n' "${cfg_args[@]}" >>${log_file}
}

function print_vars {
	while test -n "${1}"; do
		printf "${CC0}%-20s: ${C0}%s\n" "  ${1}" ${!1}
		shift
	done
}

function do_quietly {
	local var="${1}"; shift
	echo -ne "${CD}${var}${C0}"
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	"$@" >/dev/null 2>&1
	logok "${var}"
}

function do_log {
	local var="${1}"; shift
	echo -ne "${CD}${var}${C0}"
	log_this $@
	logok "${var}"
}

function do_progress {
	local var="${1}" && shift
	echo -ne "${CD}${var}"
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	("$@" |& tee -a ${log_file} | prt_progress) || exit_err "in ${var}:\n\n...\n$(tail -n5 ${log_file})${C0}"
	logok "${var}"
}

function prt_progress {
	local sln
	local grp
	tput civis
	printf "build_system: %10s; make: %7s" ${build_system} ${MAKE_EXECUTABLE} >>${log_file}
	if [ "${build_system}" == "cmake" ] && [ "$(basename ${MAKE_EXECUTABLE})" == "make" ]; then
		printf "%-6s"
		while read -r ln; do
			str_contains "${ln}" 'error: ' && printf ${CR1}
      str_contains "${ln}" 'warning: ' && printf ${CY6}
			sln=$(grep -oP '\d+%' <<<${ln})
			[ -n "$sln" ] && printf "\e[5D%-5s" ${sln}
		done
		printf "\e[6D"
	elif [ "$(basename ${MAKE_EXECUTABLE})" == "ninja" ]; then
		printf "%-12s"
		while read -r ln; do
			str_contains "${ln}" 'error: ' && printf ${CR1}
			sln=$(grep -oP '\[\d+/\d+\]' <<< ${ln})
			[ -n "${sln}" ] && printf "\e[11D%-11s" ${sln}
		done
		printf "\e[12D"
	else
		printf "%-6s"
		while read -r ln; do
			sln+="." # ·
			[ ${#sln} -eq 5 ] && sln=''
			[ -n "$sln" ] && printf "\e[5D%-5s" $sln
		done
		printf "\e[6D"
	fi
	tput cnorm
}

function build_packages_bin {
	set -x
	local xb_distdir=$(build_packages_getdistdir)
	if fn_defined 'create_package'; then
		fn_log 'pack' create_package ${xb_distdir}
	else
		if fn_defined 'build_make_package'; then
			fn_log 'pack' build_make_package ${xb_distdir}
		elif [ "$MAKE_EXECUTABLE" = "ninja" ];then
			DESTDIR=${xb_distdir} ninja -C ${dir_build} install
		else
			[ -z "$mkd" ] && mkd="DESTDIR=${xb_distdir} install"
			${MAKE_EXECUTABLE} $mkd
			fi
			[ -z "$mkd_suffix" ] && mkd_suffix=${dir_install}
			pushdir "${xb_distdir}${mkd_suffix}"

			# dont forget licence files
			if [ -n "${lst_lic}" ]; then
			[ -d "share/doc/${lib}" ] || mkdir -p "share/doc/${lib}"
			for f in ${lst_lic}; do
				[ -f "share/doc/${lib}/$f" ] || cp ${dir_src}/${f} "share/doc/${lib}/"
			done
		fi
		
		# also include .pc manually-built file
		if fn_defined 'build_pkgconfig_file' || [ -n "$pc_llib" ]; then
			local xb_pkgd=$(pwd)/lib/pkgconfig
			[ ! -d "${xb_pkgd}" ] && mkdir -p $xb_pkgd
			if [ -n "${pc_filelist}" ]; then
				for pp in ${pc_filelist}; do
					cp ${dir_install_pc}/${pp} ${xb_pkgd}/
				done
			else
				cp ${dir_install_pc}/${pkg}.pc ${xb_pkgd}/
			fi
			fn_undef build_pkgconfig_file
		fi

		if fn_defined 'on_editpack'; then
			fn_log 'edit' on_editpack
		fi

		build_packages_filelist
		case ${pkg_fmt} in
			tgz) tar -czvf "${xb_distdir}.tar.gz" *;;
			tbz) tar -cvjSf "${xb_distdir}.tar.bz2" *;;
			zip) zip -r "${xb_distdir}.zip" *;;
		esac
		rm -rf ${xb_distdir}
		popdir
	fi
	set +x
}

function build_packages_getdistdir {
	[ -f "${dir_install_pc}/${pkg}.pc" ] && vrs=$(pkg-config ${dir_install_pc}/${pkg}.pc --modversion)
	[ -z "$vrs" ] && set_git_version
	echo "${dir_root}/packages/${lib}_${vrs}_${arch}"
}

set_git_version(){
	pushdir ${dir_src}
	local v=$(git describe --abbrev=0 --tags 2>/dev/null)
	[ -n "$v" ] && export vrs=$v
	popdir
}

function build_packages_filelist {
	local scfile="${dir_root}/${lib}.sh"
	if [ -z "$(cat $scfile | grep '# Filelist')" ]; then
		echo -e "\n\n# Filelist\n# --------" >> $scfile
		find ./ -type f | sed 's|^./|# |g' >> $scfile
	fi
}




# usage: sourceforge_json <projectname>
sourceforge_json(){
  curl -qsL "https://sourceforge.net/projects/${1}/best_release.json"
}


# MENUS SECTION
function menu_skip_options {
	while [ -n "${1}" ] || [ -n "${1##--*}" ]; do
		case $1 in
		  dl|git|src) skip_dl=true;;
		esac
		shift
	done
}




color_table(){
  local i=16
  while [ $i -lt 52 ]; do
    j=$i
    k=0
    until [ $k == 7 ]; do
      printf "\e[38;5;%dm\u25cf %03d   " ${j} ${j}
      j=$(((j+36)%256))
      k=$((k+1))
    done
    i=$((i+1))
    printf '\r\n'
  done
}

color_vars(){
	local v
	local box=
	for c in R Y G C B M O F L; do
		for i in 0 1 2 3 4 5 6; do
			v="C${c}${i}"
			printf "${!v}\u2605${v}\u2605   "
		done
		printf "\n"
	done
	echo
}

hwinfoCountCoresReadable(){
  case $(nproc) in
    "1") echo "Single-Core";;
    "2") echo "Dual-Core";;
    "4") echo "Quad-Core";;
    "6") echo "Hexa-Core";;
    "8") echo "Octa-Core";;
    *) echo "$(nproc)-Core";;
  esac
}

hwinfoProcessor(){
  local i=$(cat /proc/cpuinfo | grep -Po '^.odel.*: \K(.*)' | tail -n1)
  [ -z "$i" ] && i=$(cat /proc/cpuinfo | grep -Po '^.ardware.*: \K(.*)' | tail -n1)
  [ -z "$i" ] && i=Unknown
  echo $i
}

banner(){
    echo -ne "\n\n  ${CW}${1} for X-Build ${vsh}${C0}\n  "
    echo -ne "Running on $(uname -m) $(uname -o) "
    [ -n $(command -v lsb_release) ] && echo -ne "$(lsb_release -sd) "
    if [ -n "$(uname -r | grep 'microsoft')" ];then
        echo -ne "${CD}WSL2 "
    elif [ -n "$(uname -r | grep 'Microsoft')" ];then
        echo -ne "${CD}WSL "
    else
        echo -ne "${CD} "
    fi
    echo -e "$(uname -r)${C0}"
    echo -e "${CW}  $(hwinfoCountCoresReadable) $(hwinfoProcessor)${C0}"
}

function fn_defined {
  [ -n "${1}" ] && [ "$(type -t $1)" = 'function' ]
}

function fn_undef {
  unset -f $1
}

function fn_log {
  test -z "${1}" && ${2} || do_log "${1}" ${2}
  unset -f $2
}

array_join(){
  local IFS="${1}" && shift
  echo "$@"
}

#usage: str_concat 'sep' [arg_list]
str_concat(){
  local IFS="$1" && shift
  echo "$*"
}

# usage: str_contains str1 substr2
str_contains(){
   [ -z "${1##*${2}*}" ]
}

# usage: str_starts str1 substr2
str_starts(){
   [ "${1#${2}}" != "${1}" ]
}

str_ends(){
   [ "${1%${2}}" != "${1}" ]
}

str_lowercase(){
  echo ${1} | tr '[:upper:]' '[:lower:]'
}

str_uppercase(){
  echo ${1} | tr '[:lower:]' '[:upper:]'
}

defvar(){
  local k
  while [ -n "${1}" ]; do
    k=${1%=*}
    [ -z ${k+x} ] && eval $k=${1#*=}
  done
}

pushv(){
  while [ -n "${1}" ]; do
    shell_vstack+=("$1")
    shift
  done
  return 0
}

popv(){
  if [ -z "${1}" ]; then
    local n=${#shell_vstack[@]}
    if [ $n -gt 0 ]; then
      echo ${shell_vstack[n-1]}
      unset shell_vstack[-1]
    fi
  else while [ -n "${1}" ]; do
    eval "$1"="'$(popv)'"
    shift
    done
  fi
  return 0
}

clearv(){
  unset shell_vstack
}

shell_dstack=

pushdir(){
  case $SHELL in
    *bash) pushd $1 >/dev/null 2>&1;;
    *) pushvar_f shell_dstack $1; cd $1;;
  esac
}

popdir(){
  case $SHELL in
    *bash) popd >/dev/null 2>&1;;
    *) local d=$(popvar_f shell_dstack); [ -n "$d" ] && cd $d;;
  esac
}

# usage: set_bool <condition> <value_true> <value_false>
set_bool(){
  $1 && echo $2 || echo $3
}

inc_tab(){
  export indent=$((indent+2))
  export inds="${ind}┬─"
  export inde="${ind}└─"
  export ind+="│ "
  #echo "inctab: $indent $ind............"
}

dec_tab(){
  export indent=$((indent-2))
  [ ${#ind} -gt 1 ] && export ind="${ind::-2}"
  #echo "dectab: $indent $ind............"
}


# exclusive variable add substrings left var_xaddl <var> <substrings...>
# appends substrings to the left/start of var iff main doesnt contains substring
var_xaddl(){
  local v=$1; shift
    while [ -n "$1" ];do
        [ -z "${!v##*${1}*}" ] || eval $v=\"${1} ${!v}\"
        shift
    done
}

# exclusive variable add substrings right var_xaddl <var> <substrings...>
# appends substrings to the right/end of var variable iff main doesnt contains substring
var_xaddr(){
    local v=$1; shift
    while [ -n "$1" ];do
        [ -z "${!v##*${1}*}" ] || eval $v=\"${!v} ${1} \"
        shift
    done
}

var_addr(){
    local v=$1; shift; eval $v=\"${!v} $@\"
}

var_addl(){
    local v=$1; shift; eval $v=\"$@ ${!v}\"
}

# vercomp v1 v2 returns 0: v1=v2, 1: v1>v2, 2: v1<v2
vercomp () {
    test "$1" = "$2" && return 0
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        test -z "${ver2[i]}" && ver2[i]=0
        if ((10#${ver1[i]} > 10#${ver2[i]})); then return 1; fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then return 2; fi
    done
    return 0
}

rm_quiet(){
  rm -rf $@ 2>&1 >/dev/null
}

rm_log(){
  local log=$1; shift
  [ -f "${log}" ] && [ -n "$@" ] && rm -rf $@ 2>&1 >>${log}
}


time_elapsed(){
  if [ -n "${log_timestart}" ] && [ ${log_timestart} -gt 0 ];then
    local dt=$(($(date +%s) - ${log_timestart}))
    printf "+%-10s" $(date -u -d @${dt} +"%m:%S")
  else
    printf " --:-- "
  fi
}

url_dom(){
  echo "$1" | awk -F/ '{print $3}'
}


git_vendor(){
  echo "$1" | awk -F/ '{print $4}'
}

# usage: git_get_version srcdir
git_local_version(){
  local out;
  if [ -d "${1}/.git" ];then
    local d=$(pwd)
    cd ${1}
    out=$(git describe --abbrev=0 --tags 2>/dev/null)
    cd ${d}
  fi
  echo $out
}

git_api_tojson(){
  local s=$(echo "$1" | sed 's/https:\/\///g; s/\// /g; s/\.git$//')
  set -- $s
  case ${1} in
    github*) echo -e "$(curl https://api.github.com/repos/${2}/${3} 2>/dev/null)";;
    gitlab*) echo -e "$(curl -XGET -H "Content-Type: application/json" "https://${1}/api/v4/projects/${2}%2F${3}" 2>/dev/null)";;
    *) echo;;
  esac
}

get_latest_release() {
  local s=$(echo "$1" | sed 's/https:\/\///g; s/\// /g; s/\.git$//')
  set -- $s
  #echo -ne "$1: $2/$3"
  case $1 in
    github*) echo -e "$(curl --silent "https://api.github.com/repos/${2}/${3}/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')";;
  esac                                # Pluck JSON value
}

wget_untar(){
  local args
  case $1 in
    *.tar.lz) 
      [ -z $(command -v lzip) ] || exit 1
      args="--lzip -xv"
      ;;
    *.tar.gz|*.tgz) args="-xvz";;
    *.tar.xz) args="-xvJ";;
  esac
  [ -d "tmp" ] && rm -rf tmp
  mkdir tmp
  wget -qO- $1 2>/dev/null | tar --transform 's/^dbt2-0.37.50.3/dbt2/' $args -C tmp >/dev/null 2>&1 || exit 1
  cd tmp
  mv * $2 && mv $2 ..
  cd ..
  rm -rf tmp
}

gitlab_licence(){
  local s=$(echo "$1" | sed 's/https:\/\///g; s/\// /g; s/\.git$//')
  set -- $s
  if [ "$1" == "github.com" ];then
    echo -e "$(curl https://api.github.com/repos/${2}/${3} 2>/dev/null)"
  elif [ "${1}" != "${1#gitlab}" ];then
    local json=$(curl -XGET -H "Content-Type: application/json" "https://${1}/api/v4/projects/${2}%2F${3}" 2>/dev/null)
    local id=$(echo "$json" | jq .id)
    echo ${id} "curl --request GET https://${1}/api/v4/licence/${id}"
  else
    echo
  fi
}

github_json_desc(){
  echo "${1}" | jq .description | sed 's/"//g'
}

github_jq(){
  echo "${1}" | jq "${2}" | sed 's/"//g'
}

#usage: arch_fromid out_arm64 out_arm out_x86 out_x64
arch_fromid(){
  local xid=$(expr "$cpu_id" % 4)
  local args=("$@")
  echo "${args[${xid}]}"
}

#usage: arch_fromid out_android out_linux out_windows
os_fromid(){
  local xid=$(expr "$cpu_id" / 4 % 3)
  local args=("$@")
  echo "${args[${xid}]}"
}

load_hostfeats(){
  case $host_cpuid in
    0) arch="${arch_list[0]}"; host_arm=true; host_arm64=true; LIBSDIR+="${ldir_list[0]}";;
    1) arch="${arch_list[1]}"; host_arm=true; host_arm32=true; LIBSDIR+="${ldir_list[1]}";;
    2) arch="${arch_list[2]}"; host_x86=true; LIBSDIR+="${ldir_list[2]}";;
    3) arch="${arch_list[3]}"; host_x64=true; host_cross=false; LIBSDIR+="${ldir_list[3]}";;
  esac
}

format_pathlist(){
  local sep=$2
  local prf=$3
  local out=
  for a in $1; do
    out+="${prf}${a}${sep}"
  done
  echo "${out}"
}

# usage: patch_fromremote <base_url> patch1,...,...
patch_fromremote(){
  local baseUrl=$1; shift
  while [ -n "$1" ]; do
    wget -qO- ${baseUrl}/$1 | patch
    shift
  done
}

# usage: wget_source <src-url> <dst-dir>
wget_source(){
    local fn=$(basename $1) || exit_err "Invalid source url '$1'"
    [ -z "$2" ] && local dn=$(pwd) || local dn=$2
    case $fn in
      *.zip);;
      *.tar.lz|*.tlz) args="--lzip -xv";;
      *.tar.gz|*.tgz) args="-xvz";;
      *.tar.xz|*.txz) args="-xvJ";;
    esac
}

# usage: wget_pkg_termux <lib-name> <aarch64|arm|i686|x86_64> <dst-dir>
wget_pkg_termux(){
  [ -z "$1" ] || [ -z "$2" ] || [ ! -d "$3" ] && return 1
  echo -ne "searching for ${1}"
  local rname=$(wget -qO- http://termux.net/dists/stable/main/binary-${2}/ | grep -o ${1}_.*\.${2}\.deb\" | tail -n1)
  [ -z "${rname}" ] && echo -e " ${CR0}not found: aborting" && return 1
  rname=${rname:0:-1}
  echo -ne "${CY0}:found $rname"
  local od=$(pwd); cd ${3}
  [ -d "tmp" ] && rm -rf tmp
  mkdir -p tmp && cd tmp
  local url="http://termux.net/dists/stable/main/binary-${2}/${rname}"
  echo -ne " >download"
  wget -q $url
  [ ! -f "$rname" ] && echo -e "${CR1}:fail to download $url\n${C0}" && return 1
  echo -ne " >extract"
  ar -x $rname && tar -x -f data.tar.xz
  echo -ne " >fix paths"
  sed -i "s;/data/data/com.termux/files/usr;${3};g" data/data/com.termux/files/usr/lib/pkgconfig/*.pc 2>/dev/null
  cp -rf data/data/com.termux/files/usr/* ..
  cd .. && rm -rf tmp
  echo -e "${CG1} :done${C0}"
  cd $od
  return 0
}

#usage wget_pkg_debian [--list] <pkg-name> <filename-prefix> <arm64|armhf|armel|i386|amd64> dst-dir
wget_pkg_debian(){
  local lst=false
  local p_arch
  [ "$1" == "--list" ] && lst=true && shift
  case $3 in
    aarch64*) p_arch="arm64";;
    arm*hf)   p_arch="armhf";;
    arm*eabi) p_arch="armel";;
    i686*)    p_arch="i386";;
    x86_64*)  p_arch="amd64";;
    *) echo -e "${CR0} unknown $3${C0}"; return 1;;
  esac
  [ "${1::3}" == "lib" ] && local ldir=${1::4} || local ldir=${1::1}
  local url="http://ftp.debian.org/debian/pool/main/${ldir}/${1}/"
  echo $url
  if $lst; then
    local uris=$(curl -l ${url} 2>/dev/null | grep -o \>${2}_.*_${p_arch}.deb)
    for u in $uris; do
      echo ${url}${u:1}
    done
  else
    local od=$(pwd)
    if [ ! -d "$4" ];then
      mkdir -p $4 || return 1
    fi
    cd $4
    [ -d "tmp" ] && rm -rf tmp
    mkdir -p tmp && cd tmp
    local u=$(curl -l $url 2>/dev/null | grep -o \>${2}_.*_${p_arch}.deb | tail -n1)
    url="${url}${u:1}"
    echo $url
    wget -q $url
    ar -x $(basename ${url}) && tar -x -f data.tar.xz
    mv usr/lib/${3}/* usr/lib && rm -rf usr/lib/${3}
    sed -i "s|lib/${3}|lib|g;s|/usr|${4}|g" usr/lib/pkgconfig/*.pc 2>/dev/null
    cp -rf usr/* ..
    cd .. && rm -rf tmp
    echo -e "${CG1} :done${C0}"
    cd $od
  fi
}

libname_2_packagename(){
  if [ -n $(command -v apt) ]; then
    pkglist=$(apt-cache search --names-only ${lib})
  fi
}

list_pkgs(){
  local pd="${dir_root}/builds"
  case $1 in
    *-android*) wget -q "https://sourceforge.net/projects/packages-${1}/rss?path=/" -O - | grep -Po '<title><!\[CDATA\[.*</title>' | grep -Po '/.*tar.gz' | sed 's|/||'> ${pd}/$1_pkglist.txt;;
    *) return 1;;
  esac
}

get_link_pkg(){
  local pd="${dir_root}/builds"
  #[ -f "${pd}/${arch}_pkglist.txt" ] || list_pkgs ${arch}
  #local fn=$(cat "${pd}/${arch}_pkglist.txt" | grep "${lib}.*${arch}.tar.gz" | tail -n1)
  [ -z "${fn}" ] && [ -n "${dev_vrs}" ] && fn="${lib}_${dev_vrs}_${arch}.tar.gz"
  [ -n "${fn}" ] && echo "https://sourceforge.net/projects/packages-${arch}/files/${fn}"
  return 0
}

version_parse(){
  local IFS='.|-|_'
  export arrv=()
  for f in $1; do
    if [ ${#arrv[@]} -lt 3 ]; then
      f=$(echo $f | grep -o '[0-9]*')
    fi
    if [ -n "$f" ]; then
      arrv+=($f)
    fi
  done
  echo "${arrv[@]:0:3}" | sed 's/ /./g'
}

test_c0(){
  #set -x
  local wdir="${dir_src}/${1}"
  if [ -d "${wdir}" ]; then
    local od="$(pwd)"
    cd $wdir
    echo -e "${2}" > testfile.c
    [ -n "$(command -v clang)" ] && cc=clang || cc=gcc
    $cc -c testfile.c && $cc -o testfile testfile.o && rm *.o
    ./testfile
    cd $od
  fi
  #set +x
  return 0
}

c_printf(){
  #set -x
  local wdir="${dir_src}/${1}"
  if [ -d "${wdir}" ]; then
    local od="$(pwd)"
    cd $wdir
    local hfile=$2
    local printf_expr=$3
    local cc
    if [ ! -f "testfile" ]; then
      cat <<-testfile >>testfile.c
				#include <stdio.h>
				#include "${hfile}"
				int main(){
				  printf(${printf_expr});
				}
				testfile
      [ -n "$(command -v clang)" ] && cc=clang || cc=gcc
      $cc -c testfile.c && $cc -o testfile testfile.o && rm *.o
    fi
    ./testfile
    cd $od
  fi
  #set +x
  return 0
}


unused_doErr(){
	echo -e "${CR1}  Error: ${CR0}${1}${C0}\n\n"
	if [ -f ${log_file} ];then
		if [ -f ${dir_build}/CMakeFiles/CMakeError.log ];then
		echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> ${log_file}
		cat ${dir_build}/CMakeFiles/CMakeError.log >> ${log_file}
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "$openlog" != "n" ] && nano ${log_file}
	fi
	exit 1
}

# usage: github_set_src_release <git_url> <prefix> <ext>
#   git_url: https://github.com/user/repo.git
#   prefix: prefix for name of source file (default none)
#   ext: extension for source file (default tar.gz)
function github_set_src_release_unused {
  local git_id="$(sed 's,https://github.com/,,;s,.git$,,' <<<${1})"
  local pfx="${2}"
  local ext="${3}"
  if [ -n "${git_id}" ]; then
    test -z "${ext}" && ext="tar.gz"
    vrs="$(github_latest_release ${git_id})"
    test -n "${vrs}" && src="https://github.com/${git_id}/archive/refs/tags/${pfx}${vrs}.${ext}"
  fi
  return 0
}

# .language
# .homepage
# .size
# .licence.key
# .licence.name
# .licence.spdx_id