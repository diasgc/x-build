#!/bin/bash

list_cmakefiles(){
	for f in *.sh; do
		if [ -f "./cmake/${f//\.sh/}.cmake" ]; then
			p="$(grep -oP 'cmake_file=.*' ${f})"
			if [ -z "${p}" ]; then
				echo "$f -> cmake_file='${f//\.sh/}'"
			else
				echo "${f} has ${p}"
			fi
		fi
	done
}





# unused
aptInstallBr(){
  while [ -n "$1" ];do
    echo -ne "${CD}${ind}${CT0}install $1${C0} "
    $sudo apt -qq install $1 -y >/dev/null 2>&1
    echo -e "${C0}ok ${CT1}done${C0} $(apt-cache show $1 | grep Version)"
    shift
  done
}

# usage: set_buildtype_key <input> <prefix> <on-val> <off-val>
set_buildtype_key(){
	local arr=(${1//|/ })
	case ${#arr[@]} in
		0) echo "${2}${3} ${2}${4}";;
		1) ;;
	esac
	return 0
}


util_add_patch(){
  for p in $(pwd)/patches/*.patch; do
    p2=$(basename $p)
    p1="${p2%-01.patch}"
    printf "${p} -> ${p1}.sh: "
    if [ -f "$(pwd)/${p1}.sh" ]; then
      if [ -z "$(grep 'patch=' "$(pwd)/${p1}.sh")" ];then
        echo "add line patch='${p1}-01' to ${p1}.sh"
        sed -i 's/cfg=.*/&\npatch="'${p1}'-01"/' "$(pwd)/${p1}.sh"
      else
        echo "ok"
      fi
    fi
  done
}



#usage xbuild --new <github_url>
generate_script(){
	#set -x
	test -z "$1" && return 0
	local giturl=$1
	local srcname=${giturl/\.git/}
	local libname="${srcname##*/}"
	libname="${libname,,}"
	case ${libname} in *.git) libname=${libname/\.git/};; esac
	local scriptname="${dir_root}/${libname}.sh"
	cp "${dir_root}/utils/script.template" ${scriptname}
	chmod +x "${scriptname}"
	sed -i 's,@src@,'${giturl}',g;s,@lib@,'${libname}',g' ${scriptname}
	local pkgname="lib${libname//lib/}-dev"
	test -z "$(apt-cache show ${pkgname} 2>/dev/null | grep ${pkgname})" && pkgname=
	sed -i 's,@pkg_deb@,'${pkgname}',g' ${scriptname} 
	case $giturl in
		*github*)
			local json=$(github_json $srcname)
			local libdesc=$(cat ${json} | jq .description | xargs)
			local lic=$(cat ${json} | jq .license.name | xargs)
			test -n "${libdesc}" && libdesc=${libdesc%%\. *} && sed -i 's/@desc@/'"${libdesc}"'/g' ${scriptname}
			test -n "${lic}" && sed -i 's/@lic@/'"${lic}"'/g' ${scriptname};;
	esac
	#set +x
}


github_latest_tgz(){
	case $src in
		*github.*)
			local dst=$(echo $src | sed -e 's|\.git||g')
			local url=$(curl -ILs -o /dev/null -w %{url_effective} "${dst}/releases/latest")
			local file=$(curl -s $url | grep -Po '(?<=>)[^<]*' | grep -Po '.*tar.gz$')
			echo "${url}/${file}"
		;;
		*gitlab.*|*code.videolan.org*)
			local dst=$(echo $src | sed -e 's|\.git||g')
			local v=$(git_version_remote $src)
			echo "$dst/-/archive/${v}/${lib}-${v}.tar.gz"
		;;
		*.googlesource.*)
			local tag=$(git -c 'versionsort.suffix=-' ls-remote --refs --sort='v:refname' $src | tail -n1 | cut -f1)
			echo "$src/+archive/${tag}.tar.gz"
		;;
	esac
}

github_repo_id(){
	local paths=( ${1//\// } )
	paths[3]=${paths[3]/\.git/}
	echo "${paths[2]}/${paths[3]}"
}

github_json(){
	local paths=( ${1//\// } )
	local url=
	case ${paths[1]} in 
		github.com) url="https://api.github.com/repos/${paths[2]}/${paths[3]}";;
		*) echo;;
	esac
	local json=${dir_root}/builds/${libname}.info
	wget -q $url -O ${json}
	echo ${json}
}

github_description(){
	local paths=( ${1//\// } )
	local url=
	case ${paths[1]} in 
		github.com) url="https://api.github.com/repos/${paths[2]}/${paths[3]}";;
		*) return 0
	esac
	local json=${dir_root}/builds/${libname}.info
	test -f ${json} || wget -q $url -O ${json}
	 echo $(cat ${json} | jq .description | xargs)
}


clearAll(){
	if [ -z "$lib" ];then
		read -p 'Clear all data? (Builds, Sources and Logs) [Y|n] ' ca
		case $ca in Y|y) rm -rf builds sources && clear;;esac
	else
		rm -rf sources/$lib
		[ -n "$arch" ] && rm -rf builds/$arch/$lib builds/$arch/$lib.log
	fi
}

checkPkg(){
	local pf="${dir_install_pc}/${pkg}.pc"
	[ -f "$pf" ] && echo $pf
	return 0
}

list_tarball(){
	local lf=$(ls -1 ${dir_pkgdist}/${lib}*${arch}.tar.gz 2>/dev/null | tail -n1)
	if [ -z "${lf}" ] || [ ! -f "${lf}" ]; then
		return 1
	fi
	tar -ztvf ${lf} | grep -e "[^/]$"
	return 0
}

# USAGE: create_patch [b64] <rel_path_oldfile> [<rel_path_newfile>]
create_patch(){  
	local od=$(pwd); cd ${dir_src} || return 1
	local b64=false
	[ "${1}" == "b64" ] && b64=true && shift
	case $# in
		0) return 1;;
		1) touch "${1}_"
		   $b64 && diff -Naur "${1}_" "${1}" >"${1}.patch" || diff -Naur "${1}_" "${1}" | base64 -w 72 >"${1}.patch"
		   ;;
		*) $b64 && diff -Naur "${1}" "${2}" >"${2}.patch" || diff -Naur "${1}" "${2}" | base64 -w 72 >"${2}.patch"
		   ;;
	esac
	cd $od
}

hwinfoCountCores(){
	echo $(nproc)
	# or cat /proc/cpuinfo | grep -Po -c 'model name\s+: \K(.*)'
}

hwinfoCountCoresReadable(){
	# How to get the number of physical cores
	local n=$(lscpu -b -p=Core,Socket | grep -v '^#' | sort -u | wc -l)
	local c=( 0 Single Dual 3 Quad 5 Hexa 7 Octa 9 Deca )
	if [ ${n} -gt 10 ]; then
		echo "${n}-Core"
	else
		echo "${c[${n}]}-Core"
	fi
	return 0
	case "${n}" in
		1) echo "Single-Core";;
		2) echo "Dual-Core";;
		4) echo "Quad-Core";;
		6) echo "Hexa-Core";;
		8) echo "Octa-Core";;
		*) echo "${n}-Core";;
	esac
}

hwinfoProcessor(){
	cat /proc/cpuinfo | grep -Po 'model name\s+: \K(.*)' | head -n1
}

prompt_remove(){
	while [ -n "${1}" ]; do
		echo -ne "\n  Are you sure you want do remove ${CY1}$(basename $1)?${C0} Type 'Yes' to proceed: "; read q
		if [ "${q}" == "Yes" ]; then
		echo -ne "  > Removing $1... " && rm -rf $1 2>/dev/null && echo -e " ${CG1}done${C0}" || echo -e "${CR1} Fail${C0}"
		else
		break
		fi
		shift
	done
	echo
}


function patch_check_patchdir {
  pushd "${dir_src}" 2>&1 >/dev/null
  local f
  for p in ${patch[@]}; do
    f="${dir_root}/patches/${p}.patch"
    test -f "${f}" && patch -p0 <"${f}" 2>&1 >"${log_file}"
  done
  popd 2>&1 >/dev/null
}

patch_check_xbpatch(){
	pushdir ${dir_root}
	local matches=( $(grep -oP "(?<=^<<').*?(?=')" $0) )
	if [ ${#matches[@]} -gt 0 ]; then
		for match in ${matches[@]}; do
			echo -ne "${CC2}${match} ${C0}"
			local block=$(awk '/^<<.'${match}'./{flag=1; next} /^'{$match}'/{flag=0} flag' $0)
			case $match in
				XB_CREATE_CMAKELISTS|CMakeLists.txt)
					echo "${block}" >${dir_src}/CMakeLists.txt
					echo -e "\ncreate CMakeLists.txt: \n$block" >>${log_file}
					;;
				XB_PATCH) pushdir ${dir_src}
					patch -p0 <<<$(echo "${block}") 2>&1 >${log_file}
					echo -e "\npatch found: \n$block" >>${log_file}
					popdir
					;;
				XB64_PATCH) pushdir ${dir_src}
					patch -p0 <<<$(echo "${block}" | base64 -d) 2>&1 >${log_file}
					popdir
					;;
				LZS_PATCH) pushdir ${dir_src}
					patch -p0 <<<$(echo "${block}" | ${dir_root}/utils/lz-string -d -) 2>&1 >${log_file}
					popdir
					;;
				*) echo -e "\nUnknown block name ${match} with this contents (ignoring):\n$block" >>${log_file}
					;;
			esac
		done
	fi
	popdir
	return 0
}

# usage libname.sh --patch a [sources/libname/]path/to/newfile [sources/libname/]path/to/oldfile
patch_append(){
	local newfile=${1}
	local oldfile
	str_starts "${newfile}" "sources/${lib}/" && newfile="${newfile//sources\/${lib}\//}"
	[ -f "sources/${lib}/${newfile}" ] || exit_err "unable to find file sources/${lib}/${newfile}"
	shift
	cd sources/${lib}
	if [ -z "${1}" ]; then
		oldfile="${newfile::-3}old"
		touch sources/${lib}/${oldfile}
	else
		oldfile=${1}
		str_starts "${oldfile}" "sources/${lib}/" && newfile="${oldfile//sources\/${lib}\//}"
		[ -f "${oldfile}" ] || exit_err "unable to find file sources/${lib}/${oldfile}"
	fi
	diff -Naur ${oldfile} ${newfile} | sed "s|${oldfile}|${newfile}|" >>${dir_root}/sources/${lib}/xbuild.patch
	cd ../..
	echo -e "\n  ${CC1}Patch file updated at:${C0} $(pwd)/sources/${lib}/xbuild.patch\n\n"
}

patch_embed(){
	if [ ! -f "sources/${lib}/xbuild.patch" ]; then
		exit_err "No sources/${lib}/xbuild.patch file to embed"
	fi
	hdr="STR_PATCH"
	case $1 in
		xb64|XB64) echo -e "\n<<'XB64_PATCH'" >>${0}
				cat "sources/${lib}/xbuild.patch" | base64 -w 90 >>${0}
				echo -e "XB64_PATCH" >>${0}
				;;
		lzs|LZS)   echo -e "\n<<'LZS_PATCH'" >>${0}
				cat "sources/${lib}/xbuild.patch" | utils/lz-string -c -w 90 - >>${0}
				echo -e "LZS_PATCH" >>${0}
				;;
	esac
}

patch_get(){
	matches=( $(grep -oP "(?<=^<<').*?(?=')" $0) )
	if [ ${#matches[@]} -gt 0 ]; then
		for match in ${matches[@]}; do
			block=$(awk '/^<<.'"$match"'./{flag=1; next} /^'"$match"'/{flag=0} flag' $0)
			case $match in
				XB64_PATCH) echo "${block}" | base64 -d;;
				LZS_PATCH)  echo "${block}" | utils/lz-string -d -;;
			esac
		done
	fi
	return 0;
}

create_diff(){
	local b64=false
	local newfile=${1}
	local oldfile
	[ -f "sources/${lib}/${newfile}" ] || exit_err "unable to find file sources/${lib}/${newfile}"
	shift
	pushdir sources/${lib}
	if [ -z "${1}" ]; then
		oldfile="${newfile::-3}old"
		touch sources/${lib}/${oldfile}
	else
		oldfile=${1}
		[ -f "${oldfile}" ] || exit_err "unable to find file sources/${lib}/${oldfile}"
	fi
	if $b64; then
		diff -Naur ${oldfile} ${newfile} | sed "s|${oldfile}|${newfile}|" | base64 -w 90 >>"${newfile}.patch"
	else
		diff -Naur ${oldfile} ${newfile} | sed "s|${oldfile}|${newfile}|" >"${newfile}.patch"
	fi
	echo -e "\n  ${CC1}Done${C0}\n"
	read -p "Open file? y|n: " yn
	case $yn in y|Y) nano "${newfile}.patch";; esac
	popdir
}


set_break(){
    case $1 in
        git)    break_on_git=true;;
        patch)  break_on_patch=true;;
        config) break_on_config=true;;
        build)  break_on_build=true;;
        make)   break_on_make=true;;
    esac
    return 0
}

menu_tune(){
	case $1 in
		smd855)   CPPFLAGS+=" -mtune=cortex-a76.cortex-a55";;
		smd865)   CPPFLAGS+=" -mtune=cortex-a77.cortex-a55";;
		smd888)   CPPFLAGS+=" -mtune=cortex-a78.cortex-a55";;
		cortex-*) CPPFLAGS+=" -mtune=$1";;
	esac
}

menu_clear(){
	while [ -n "$1" ];do
		case $1 in
			source|srclib)   prompt_remove ${dir_src};;
			allsources|sources)  prompt_remove ${dir_sources};;
			builds)   prompt_remove ${dir_install};;
			packages) prompt_remove ${dir_pkgdist};;
			wipe*)    prompt_remove ${dir_pkgdist} ${dir_install} ${dir_sources};;
		esac
		shift
	done
	return 0
}

prt_hmenu(){
	echo -e "\n${1}\n"
	shift
	local a
	local b
	while [ -n "$1" ]; do
		a="$1"; shift
		b="$1"; shift
		printf "  ${CC0}%-20s: ${C0}%s\n" "$a" "$b"
	done
	echo
}

menu_get(){
	local pkgfile="${dir_install_pc}/${pkg}.pc"
	[ -f "${pkgfile}" ] && local has_pc=true
	case $1 in
		help)		prt_hmenu "${CW}usage: $0 --get ${CC0}<opt>" \
					'cflags' 'get pkg-config --cflags' 'ldflags' 'get pkg-config --libs' 'ldstatic' 'get pkg-config --libs --static' \
					'pc-ver' 'get package version' 'pc-path|pc' 'get pkg-config file path' 'pc-name' 'get pkg-config file name without .pc' \
					'prefix' 'get prefix / install dir' 'libname' 'get the libname' 'aptname' 'get the debian package name' 'var <variable>' \
					'get <variable> value' 'vrs_remote' 'get git remote latest version' 'vrs_tag' 'get git remote latest tag' 'vrs_tags' \
					'get git remote tag list' 'vrs_local' 'get git local version' 'options|opts' 'show build options' 'log' 'edit (nano) log file' \
					'patch' 'show decoded patch included in the script'
					;;
		cflags)     [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --cflags)";;
		ldflags)    [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --libs)";;
		ldstatic)   [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --libs --static)";;
		pc-ver)     [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --modversion)";;
		pc-path|pc) echo "${pkgfile}";;
		pc-name)    echo "${pkg}";;
		prefix)     echo "${dir_install}";;
		libname)    echo "${lib}";;
		aptname)    echo "${pkg_deb}";;
		var)        shift; echo "${!1}";;
		vrs_latest) echo $(github_latest_tgz); exit 0;;
		vrs_remote) fn_defined 'vremote' && version_parse "$(vremote)" || git_version_remote $src;;
		vrs_taglist)git ls-remote --tags --refs --sort="v:refname" $src | tail -n1 | sed 's/.*\///';;
		vrs_tags)   git ls-remote --tags --sort="v:refname" $src | grep -oP 'tags/.*\d+\.\d+\.\d+.*';;
		vrs_local)  git_version_local $dir_src;;
		opt*)       showOpts "$(pwd)/sources/$lib"; exit 0;;
		log)        [ -f "${dir_install}/${lib}.log" ] && nano ${dir_install}/${lib}.log;;
		patch)      patch_get; exit 0;;
		vrs_git)    git ls-remote $src | grep 'refs/tags/' | sed 's/^.*refs\/tags\///g' | tail -n1;;
		vrs_git_n)  git ls-remote $src | grep 'refs/tags/' | sed 's/^.*refs\/tags\///g' | tail -n1 | sed 's/[a-zA-Z\-\^\{\}]//g';;
	esac
}

menu_git(){
	local b=false
	[ -z "${lib}" ] && return 0
	[ -z "${src}" ] && return 0
	case $1 in
		help)       prt_hmenu "${CW}usage: $0 --git ${CC0}<opt>" \
					'tar*' 'list current tarball contents' 'branches' 'list all local git available branches' \
					'tags' 'list all local git available branches' \
					'env' 'list toolchain environment variables' 'deps' 'list packages that depend on '${lib}''
					;;
		clone)      str_contains $src 'git' || return 0
					[ -d "sources/${lib}" ] && rm -rf sources/${lib}
					git clone $src sources/${lib}
					;;
	esac
	return 0
}


menu_list(){
	local b=false
	[ -n "${arch}" ] && [ -n "${lib}" ] && b=true
	case $1 in
		help)       prt_hmenu "${CW}usage: $0 --list ${CC0}<opt>" \
					'tar*' 'list current tarball contents' 'branches' 'list all local git available branches' \
					'tags' 'list all local git available branches' \
					'env' 'list toolchain environment variables' 'deps' 'list packages that depend on '${lib}''
					;;
		tar*)       $b && list_tarball;;
		branches)   [ -d "${dir_src}/.git" ] && git --git-dir="${dir_src}/.git" branch -a;;
		opt*)       showOpts "$(pwd)/sources/$lib"; exit 0;;
		tags)       [ -d "${dir_src}/.git" ] && git --git-dir="${dir_src}/.git" tag --list;;
		env)        $b && loadToolchain && print_vars CC CXX LD AS AR NM RANLIB STRIP ADDR2LINE OBJCOPY OBJDUMP READELF SIZE STRINGS WINDRES GCOV;;
		deps)       for f in ${dir_root}/*.sh; do
					[ -n "$(cat $f | grep -oP 'dep=.*'${lib}'.*')" ] && echo $(basename $f) | sed 's|\.sh||'
					done
					;;
	esac
	return 0
}

menu_goto(){
	case $1 in
		src|source) pushd ${dir_src};;
		bin)        pushd ${dir_install_bin};;
		lib)        pushd ${dir_install_lib};;
		include)    pushd ${dir_install_include};;
		pkgconfig)  pushd ${dir_install_pc};;
		*)          exit 0;;
	esac
#bash
}

utils_get_latest_release(){
	if fn_defined 'latest_release'; then
		latest_release && echo "${vrs}"
	elif [ -z "${src}" ]; then
		echo "Unknown source ${src}"
	else
		local paths=( ${src//\// } )
		paths[3]=${paths[3]/\.git/}
		case ${paths[1]} in
			github.com) github_latest_release "${paths[2]}/${paths[3]}"
				;;
			*) echo $(git ls-remote --tags --sort "v:refname" $src | tail -n1 | rev | awk -v FS='/' '{print $1}' | rev)
				;;
		esac
	fi
}