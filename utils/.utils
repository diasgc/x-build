#!/bin/bash

apt_install(){
	while [ "$1" != "" ];do
		#echo -ne "  ${CT0}install $1${C0}"
		#echo -n " "
		stty size | {
		read y x
		echo -ne "${CY1}"
		tput sc
		tput cup "$((y - 1))" 0
		$sudo apt -qq install $1 -y >/dev/null 2>&1
		echo -ne "${C0}"
		tput rc
		}
		#echo -ne "${C0} ok"
		shift
	done
}

# unused
aptInstallBr(){
  while [ -n "$1" ];do
    echo -ne "${CD}${ind}${CT0}install $1${C0} "
    $sudo apt -qq install $1 -y >/dev/null 2>&1
    echo -e "${C0}ok ${CT1}done${C0} $(apt-cache show $1 | grep Version)"
    shift
  done
}

function bool2int {
	$1 && echo 1 || echo 0
}

function config_guess {
  if [ -f "${dir_config}/meson.build" ]; then
    build_system="meson"
    cfg="meson"
  elif [ -f "${dir_config}/CMakeLists.txt" ]; then
    build_system="cmake"
    cfg="cmake"
  elif [ -n "$(ls ${dir_config}/configure* 2>/dev/null)" ]; then
    build_system="automake"
    cfg='ac'
    if [ -f "${dir_config}/autogen.sh" ]; then
      cfg_cmd="${dir_config}/autogen.sh"
	  cfg='ag'
    elif [ -f "${dir_config}/bootstrap.sh" ]; then
      cfg_cmd="${dir_config}/bootstrap.sh"
    elif [ -f "${dir_config}/bootstrap" ]; then
      cfg_cmd="${dir_config}/bootstrap"
	elif [ -f "${dir_config}/configure.ac"]; then
	  cfg='ar'		
    elif [ ! -f "${dir_config}/configure" ]; then
      cfg_cmd="autoreconf -fiv ${dir_config}/bootstrap"
    else
      return 1
    fi
  else
    return 1
  fi
  return 0
}

# usage: set_buildtype_key <input> <prefix> <on-val> <off-val>
set_buildtype_key(){
	local arr=(${1//|/ })
	case ${#arr[@]} in
		0) echo "${2}${3} ${2}${4}";;
		1) ;;
	esac
	return 0
}

set_git_version(){
	pushdir ${dir_src}
	local v=$(git describe --abbrev=0 --tags 2>/dev/null)
	[ -n "$v" ] && export vrs=$v
	popdir
}

build_packages_getdistdir(){
	[ -f "${dir_install_pc}/${pkg}.pc" ] && vrs=$(pkg-config ${dir_install_pc}/${pkg}.pc --modversion)
	[ -z "$vrs" ] && set_git_version
	echo "${dir_root}/packages/${lib}_${vrs}_${arch}"
}

build_packages_filelist(){
	local scfile="${dir_root}/${lib}.sh"
	if [ -z "$(cat $scfile | grep '# Filelist')" ]; then
		echo -e "\n\n# Filelist\n# --------" >> $scfile
		find ./ -type f | sed 's|^./|# |g' >> $scfile
	fi
}


build_packages_bin(){
	set -x
	local xb_distdir=$(build_packages_getdistdir)
	if fn_defined 'create_package'; then
		fn_log 'pack' create_package ${xb_distdir}
	else
		if fn_defined 'build_make_package'; then
			fn_log 'pack' build_make_package ${xb_distdir}
		elif [ "$MAKE_EXECUTABLE" = "ninja" ];then
			DESTDIR=${xb_distdir} ninja -C ${dir_build} install
		else
			[ -z "$mkd" ] && mkd="DESTDIR=${xb_distdir} install"
			${MAKE_EXECUTABLE} $mkd
			fi
			[ -z "$mkd_suffix" ] && mkd_suffix=${dir_install}
			pushdir "${xb_distdir}${mkd_suffix}"

			# dont forget licence files
			if [ -n "${lst_lic}" ]; then
			[ -d "share/doc/${lib}" ] || mkdir -p "share/doc/${lib}"
			for f in ${lst_lic}; do
				[ -f "share/doc/${lib}/$f" ] || cp ${dir_src}/${f} "share/doc/${lib}/"
			done
		fi
		
		# also include .pc manually-built file
		if fn_defined 'build_pkgconfig_file' || [ -n "$pc_llib" ]; then
			local xb_pkgd=$(pwd)/lib/pkgconfig
			[ ! -d "${xb_pkgd}" ] && mkdir -p $xb_pkgd
			if [ -n "${pc_filelist}" ]; then
				for pp in ${pc_filelist}; do
					cp ${dir_install_pc}/${pp} ${xb_pkgd}/
				done
			else
				cp ${dir_install_pc}/${pkg}.pc ${xb_pkgd}/
			fi
			fn_undef build_pkgconfig_file
		fi

		if fn_defined 'on_editpack'; then
			fn_log 'edit' on_editpack
		fi

		build_packages_filelist
		case $pkg_fmt in
			tgz) tar -czvf "${xb_distdir}.tar.gz" *;;
			tbz) tar -cvjSf "${xb_distdir}.tar.bz2" *;;
			zip) zip -r "${xb_distdir}.zip" *;;
		esac
		rm -rf ${xb_distdir}
		popdir
	fi
	set +x
}

#usage xbuild --new <github_url>
generate_script(){
	#set -x
	test -z "$1" && return 0
	local giturl=$1
	local srcname=${giturl/\.git/}
	local libname="${srcname##*/}"
	libname="${libname,,}"
	case ${libname} in *.git) libname=${libname/\.git/};; esac
	local scriptname="${dir_root}/${libname}.sh"
	cp "${dir_root}/utils/script.template" ${scriptname}
	chmod +x "${scriptname}"
	sed -i 's,@src@,'${giturl}',g;s,@lib@,'${libname}',g' ${scriptname}
	case $giturl in
		*github*)
			local json=$(github_json $srcname)
			local libdesc=$(cat ${json} | jq .description | xargs)
			local lic=$(cat ${json} | jq .license.name | xargs)
			test -n "${libdesc}" && libdesc=${libdesc%%\. *} && sed -i 's/@desc@/'"${libdesc}"'/g' ${scriptname}
			test -n "${lic}" && sed -i 's/@lic@/'"${lic}"'/g' ${scriptname};;
	esac
	#set +x
}


# usage github_latest_release <user/repo>
github_latest_release(){
	echo $(curl --silent "https://api.github.com/repos/$1/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
}

github_latest_tgz(){
	case $src in
		*github.*)
			local dst=$(echo $src | sed -e 's|\.git||g')
			local url=$(curl -ILs -o /dev/null -w %{url_effective} "${dst}/releases/latest")
			local file=$(curl -s $url | grep -Po '(?<=>)[^<]*' | grep -Po '.*tar.gz$')
			echo "${url}/${file}"
		;;
		*gitlab.*|*code.videolan.org*)
			local dst=$(echo $src | sed -e 's|\.git||g')
			local v=$(git_remote_version $src)
			echo "$dst/-/archive/${v}/${lib}-${v}.tar.gz"
		;;
		*.googlesource.*)
			local tag=$(git -c 'versionsort.suffix=-' ls-remote --refs --sort='v:refname' $src | tail -n1 | cut -f1)
			echo "$src/+archive/${tag}.tar.gz"
		;;
	esac
}

github_repo_id(){
	local paths=( ${1//\// } )
	paths[3]=${paths[3]/\.git/}
	echo "${paths[2]}/${paths[3]}"
}

github_json(){
	local paths=( ${1//\// } )
	local url=
	case ${paths[1]} in 
		github.com) url="https://api.github.com/repos/${paths[2]}/${paths[3]}";;
		*) echo;;
	esac
	local json=${dir_root}/builds/${libname}.info
	wget -q $url -O ${json}
	echo ${json}
}

github_description(){
	local paths=( ${1//\// } )
	local url=
	case ${paths[1]} in 
		github.com) url="https://api.github.com/repos/${paths[2]}/${paths[3]}";;
		*) return 0
	esac
	local json=${dir_root}/builds/${libname}.info
	test -f ${json} || wget -q $url -O ${json}
	 echo $(cat ${json} | jq .description | xargs)
}

package_showinfo(){
	$banner || return 0
	local dp=
	local vs=
	local longdesc=$(package_longdesc)
	[ -z "$(echo $longdesc | xargs 2>/dev/null)" ] && unset longdesc

	# Main Description
	[ -n "${dsc}" ] && echo -e "\n${CD}${inds}${CW}\e[1m${lib^^} - ${C0}${dsc}\e[0m"
	[ -n "${longdesc}" ] && echo -e "${CD}${longdesc}" | sed 's|\*|\u2605|g; s|\..\..|. |g' # sed 's|^|'${ind}|g'

	# see links
	echo -e "${CD}${ind}${CD}"
	echo -e "${CD}${ind}${CD}see log   : \e[4m${log_file}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}    script: \e[4m${0}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}    source: \e[4m${dir_src}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}    build : \e[4m${root_dir}/builds/${arch}\e[24m${C0}"
	echo -e "${CD}${ind}${CD}"

	# Licence
	echo -ne "${CD}${ind}${CT0}Licence ${C0}$lic "

	# Build Tools
	if [ -n "${tls}" ]; then
		echo -ne "${CT0}build deps: "
		tput sc; echo -ne "${CD}$tls "; tput rc
		for t in ${tls}; do
		if [ -z $(command -v ${t}) ];then
			apt_install ${t} || {
			echo -ne "${CR1}${t} ${C0}" && exit_err "Unable to install ${t}, aborting..."
			}
			echo -ne "${CW}${t} "
		fi
		shift
		done
	fi

	# Build Deps
	[ -n "${dep}" ] && dp="${dp}${CT0}lib deps: ${C0}$dep"

	if str_contains $src "git"; then
		local vgit=$(git_version_remote $src | head -n1)
		if [ -d ${dir_src} ];then
		local vrep=$(git_version_local ${dir_src} | head -n1)
		vs="${CT0}vrs: ${C0}$vrep "
		if str_contains $vgit $vrs; then
			vs+=" updated"
		else
			vs+=" ${CT0}latest: ${CT1}${vgit}${C0}"
		fi
		else
		vs="${CT0}vrs: ${C0}${vgit}"
		fi
	fi
	echo -e " ${vs} ${C0}"
	return 0
}

package_longdesc(){
	if [ -n "${apt}" ]; then
		echo -e $(apt-cache show ${apt} 2>/dev/null | \
		grep -E "Description-..^|^ " | \
		sed $'s/\*/\u2605/g' | \
		sed '/^ *This package contains.*\./d') | fold -s -w120 | sed 's/^/'"${ind}"'/g'
	fi
	return 0
}


clearAll(){
	if [ -z "$lib" ];then
		read -p 'Clear all data? (Builds, Sources and Logs) [Y|n] ' ca
		case $ca in Y|y) rm -rf builds sources && clear;;esac
	else
		rm -rf sources/$lib
		[ -n "$arch" ] && rm -rf builds/$arch/$lib builds/$arch/$lib.log
	fi
}

checkPkg(){
	local pf="${dir_install_pc}/${pkg}.pc"
	[ -f "$pf" ] && echo $pf
	return 0
}

list_tarball(){
	local lf=$(ls -1 ${dir_pkgdist}/${lib}*${arch}.tar.gz 2>/dev/null | tail -n1)
	if [ -z "${lf}" ] || [ ! -f "${lf}" ]; then
		return 1
	fi
	tar -ztvf ${lf} | grep -e "[^/]$"
	return 0
}

# USAGE: create_patch [b64] <rel_path_oldfile> [<rel_path_newfile>]
create_patch(){  
	local od=$(pwd); cd ${dir_src} || return 1
	local b64=false
	[ "${1}" == "b64" ] && b64=true && shift
	case $# in
		0) return 1;;
		1) touch "${1}_"
		   $b64 && diff -Naur "${1}_" "${1}" >"${1}.patch" || diff -Naur "${1}_" "${1}" | base64 -w 72 >"${1}.patch"
		   ;;
		*) $b64 && diff -Naur "${1}" "${2}" >"${2}.patch" || diff -Naur "${1}" "${2}" | base64 -w 72 >"${2}.patch"
		   ;;
	esac
	cd $od
}

hwinfoCountCores(){
	echo $(nproc)
	# or cat /proc/cpuinfo | grep -Po -c 'model name\s+: \K(.*)'
}

hwinfoCountCoresReadable(){
	# How to get the number of physical cores
	local n=$(lscpu -b -p=Core,Socket | grep -v '^#' | sort -u | wc -l)
	case "${n}" in
		"1") echo "Single-Core";;
		"2") echo "Dual-Core";;
		"4") echo "Quad-Core";;
		"6") echo "Hexa-Core";;
		"8") echo "Octa-Core";;
		*) echo "${n}-Core";;
	esac
}

hwinfoProcessor(){
	cat /proc/cpuinfo | grep -Po 'model name\s+: \K(.*)' | head -n1
}

prompt_remove(){
	while [ -n "${1}" ]; do
		echo -ne "\n  Are you sure you want do remove ${CY1}$(basename $1)?${C0} Type 'Yes' to proceed: "; read q
		if [ "${q}" == "Yes" ]; then
		echo -ne "  > Removing $1... " && rm -rf $1 2>/dev/null && echo -e " ${CG1}done${C0}" || echo -e "${CR1} Fail${C0}"
		else
		break
		fi
		shift
	done
	echo
}


patch_check_patchdir(){
  test $patch_skip && return 0
  local patch_list=( $(ls -1 ${dir_patches}/${lib}*.patch 2>/dev/null) )
  if [ -n "${patch_list[@]}" ]; then
    pushd ${dir_src} 2>&1 >/dev/null
    for p in ${patch_list[@]}; do
      patch -p0 <${p} 2>&1 >${log_file}
    done
    popd 2>&1 >/dev/null
  fi
  return 0
}

patch_check_xbpatch(){
	pushdir ${dir_root}
	local matches=( $(grep -oP "(?<=^<<').*?(?=')" $0) )
	if [ ${#matches[@]} -gt 0 ]; then
		for match in ${matches[@]}; do
			echo -ne "${CC2}${match} ${C0}"
			local block=$(awk '/^<<.'${match}'./{flag=1; next} /^'{$match}'/{flag=0} flag' $0)
			case $match in
				XB_CREATE_CMAKELISTS|CMakeLists.txt)
					echo "${block}" >${dir_src}/CMakeLists.txt
					echo -e "\ncreate CMakeLists.txt: \n$block" >>${log_file}
					;;
				XB_PATCH) pushdir ${dir_src}
					patch -p0 <<<$(echo "${block}") 2>&1 >${log_file}
					echo -e "\npatch found: \n$block" >>${log_file}
					popdir
					;;
				XB64_PATCH) pushdir ${dir_src}
					patch -p0 <<<$(echo "${block}" | base64 -d) 2>&1 >${log_file}
					popdir
					;;
				LZS_PATCH) pushdir ${dir_src}
					patch -p0 <<<$(echo "${block}" | ${dir_root}/utils/lz-string -d -) 2>&1 >${log_file}
					popdir
					;;
				*) echo -e "\nUnknown block name ${match} with this contents (ignoring):\n$block" >>${log_file}
					;;
			esac
		done
	fi
	popdir
	return 0
}

# usage libname.sh --patch a [sources/libname/]path/to/newfile [sources/libname/]path/to/oldfile
patch_append(){
	local newfile=${1}
	local oldfile
	str_starts "${newfile}" "sources/${lib}/" && newfile="${newfile//sources\/${lib}\//}"
	[ -f "sources/${lib}/${newfile}" ] || exit_err "unable to find file sources/${lib}/${newfile}"
	shift
	cd sources/${lib}
	if [ -z "${1}" ]; then
		oldfile="${newfile::-3}old"
		touch sources/${lib}/${oldfile}
	else
		oldfile=${1}
		str_starts "${oldfile}" "sources/${lib}/" && newfile="${oldfile//sources\/${lib}\//}"
		[ -f "${oldfile}" ] || exit_err "unable to find file sources/${lib}/${oldfile}"
	fi
	diff -Naur ${oldfile} ${newfile} | sed "s|${oldfile}|${newfile}|" >>${dir_root}/sources/${lib}/xbuild.patch
	cd ../..
	echo -e "\n  ${CC1}Patch file updated at:${C0} $(pwd)/sources/${lib}/xbuild.patch\n\n"
}

patch_embed(){
	if [ ! -f "sources/${lib}/xbuild.patch" ]; then
		exit_err "No sources/${lib}/xbuild.patch file to embed"
	fi
	hdr="STR_PATCH"
	case $1 in
		xb64|XB64) echo -e "\n<<'XB64_PATCH'" >>${0}
				cat "sources/${lib}/xbuild.patch" | base64 -w 90 >>${0}
				echo -e "XB64_PATCH" >>${0}
				;;
		lzs|LZS)   echo -e "\n<<'LZS_PATCH'" >>${0}
				cat "sources/${lib}/xbuild.patch" | utils/lz-string -c -w 90 - >>${0}
				echo -e "LZS_PATCH" >>${0}
				;;
	esac
}

patch_get(){
	matches=( $(grep -oP "(?<=^<<').*?(?=')" $0) )
	if [ ${#matches[@]} -gt 0 ]; then
		for match in ${matches[@]}; do
			block=$(awk '/^<<.'"$match"'./{flag=1; next} /^'"$match"'/{flag=0} flag' $0)
			case $match in
				XB64_PATCH) echo "${block}" | base64 -d;;
				LZS_PATCH)  echo "${block}" | utils/lz-string -d -;;
			esac
		done
	fi
	return 0;
}

create_diff(){
	local b64=false
	local newfile=${1}
	local oldfile
	[ -f "sources/${lib}/${newfile}" ] || exit_err "unable to find file sources/${lib}/${newfile}"
	shift
	pushdir sources/${lib}
	if [ -z "${1}" ]; then
		oldfile="${newfile::-3}old"
		touch sources/${lib}/${oldfile}
	else
		oldfile=${1}
		[ -f "${oldfile}" ] || exit_err "unable to find file sources/${lib}/${oldfile}"
	fi
	if $b64; then
		diff -Naur ${oldfile} ${newfile} | sed "s|${oldfile}|${newfile}|" | base64 -w 90 >>"${newfile}.patch"
	else
		diff -Naur ${oldfile} ${newfile} | sed "s|${oldfile}|${newfile}|" >"${newfile}.patch"
	fi
	echo -e "\n  ${CC1}Done${C0}\n"
	read -p "Open file? y|n: " yn
	case $yn in y|Y) nano "${newfile}.patch";; esac
	popdir
}

request_cmd(){
	local c1=$1
	local c2=$2
	test -z "${c2}" && c2=${c1}
	test -z $(command -v ${c1}) && apt_install ${c2}
	return 0
}


set_break(){
    case $1 in
        git)    break_on_git=true;;
        patch)  break_on_patch=true;;
        config) break_on_config=true;;
        build)  break_on_build=true;;
        make)   break_on_make=true;;
    esac
    return 0
}

menu_tune(){
	case $1 in
		smd855)   CPPFLAGS+=" -mtune=cortex-a76.cortex-a55";;
		smd865)   CPPFLAGS+=" -mtune=cortex-a77.cortex-a55";;
		smd888)   CPPFLAGS+=" -mtune=cortex-a78.cortex-a55";;
		cortex-*) CPPFLAGS+=" -mtune=$1";;
	esac
}

menu_clear(){
	while [ -n "$1" ];do
		case $1 in
			source|srclib)   prompt_remove ${dir_src};;
			allsources|sources)  prompt_remove ${dir_sources};;
			builds)   prompt_remove ${dir_install};;
			packages) prompt_remove ${dir_pkgdist};;
			wipe*)    prompt_remove ${dir_pkgdist} ${dir_install} ${dir_sources};;
		esac
		shift
	done
	return 0
}

prt_hmenu(){
	echo -e "\n${1}\n"
	shift
	local a
	local b
	while [ -n "$1" ]; do
		a="$1"; shift
		b="$1"; shift
		printf "  ${CC0}%-20s: ${C0}%s\n" "$a" "$b"
	done
	echo
}

menu_get(){
	local pkgfile="${dir_install_pc}/${pkg}.pc"
	[ -f "${pkgfile}" ] && local has_pc=true
	case $1 in
		help)		prt_hmenu "${CW}usage: $0 --get ${CC0}<opt>" \
					'cflags' 'get pkg-config --cflags' 'ldflags' 'get pkg-config --libs' 'ldstatic' 'get pkg-config --libs --static' \
					'pc-ver' 'get package version' 'pc-path|pc' 'get pkg-config file path' 'pc-name' 'get pkg-config file name without .pc' \
					'prefix' 'get prefix / install dir' 'libname' 'get the libname' 'aptname' 'get the debian package name' 'var <variable>' \
					'get <variable> value' 'vrs_remote' 'get git remote latest version' 'vrs_tag' 'get git remote latest tag' 'vrs_tags' \
					'get git remote tag list' 'vrs_local' 'get git local version' 'options|opts' 'show build options' 'log' 'edit (nano) log file' \
					'patch' 'show decoded patch included in the script'
					;;
		cflags)     [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --cflags)";;
		ldflags)    [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --libs)";;
		ldstatic)   [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --libs --static)";;
		pc-ver)     [ -f "${pkgfile}" ] && echo "$(pkg-config ${pkgfile} --modversion)";;
		pc-path|pc) echo "${pkgfile}";;
		pc-name)    echo "${pkg}";;
		prefix)     echo "${dir_install}";;
		libname)    echo "${lib}";;
		aptname)    echo "${apt}";;
		var)        shift; echo "${!1}";;
		vrs_latest) echo $(github_latest_tgz); exit 0;;
		vrs_remote) fn_defined 'vremote' && version_parse "$(vremote)" || git_version_remote $src;;
		vrs_taglist)git ls-remote --tags --refs --sort="v:refname" $src | tail -n1 | sed 's/.*\///';;
		vrs_tags)   git ls-remote --tags --sort="v:refname" $src | grep -oP 'tags/.*\d+\.\d+\.\d+.*';;
		vrs_local)  git_version_local $dir_src;;
		opt*)       showOpts "$(pwd)/sources/$lib"; exit 0;;
		log)        [ -f "${dir_install}/${lib}.log" ] && nano ${dir_install}/${lib}.log;;
		patch)      patch_get; exit 0;;
		vrs_git)    git ls-remote $src | grep 'refs/tags/' | sed 's/^.*refs\/tags\///g' | tail -n1;;
		vrs_git_n)  git ls-remote $src | grep 'refs/tags/' | sed 's/^.*refs\/tags\///g' | tail -n1 | sed 's/[a-zA-Z\-\^\{\}]//g';;
	esac
}

menu_git(){
	local b=false
	[ -z "${lib}" ] && return 0
	[ -z "${src}" ] && return 0
	case $1 in
		help)       prt_hmenu "${CW}usage: $0 --git ${CC0}<opt>" \
					'tar*' 'list current tarball contents' 'branches' 'list all local git available branches' \
					'tags' 'list all local git available branches' \
					'env' 'list toolchain environment variables' 'deps' 'list packages that depend on '${lib}''
					;;
		clone)      str_contains $src 'git' || return 0
					[ -d "sources/${lib}" ] && rm -rf sources/${lib}
					git clone $src sources/${lib}
					;;
	esac
	return 0
}


menu_list(){
	local b=false
	[ -n "${arch}" ] && [ -n "${lib}" ] && b=true
	case $1 in
		help)       prt_hmenu "${CW}usage: $0 --list ${CC0}<opt>" \
					'tar*' 'list current tarball contents' 'branches' 'list all local git available branches' \
					'tags' 'list all local git available branches' \
					'env' 'list toolchain environment variables' 'deps' 'list packages that depend on '${lib}''
					;;
		tar*)       $b && list_tarball;;
		branches)   [ -d "${dir_src}/.git" ] && git --git-dir="${dir_src}/.git" branch -a;;
		opt*)       showOpts "$(pwd)/sources/$lib"; exit 0;;
		tags)       [ -d "${dir_src}/.git" ] && git --git-dir="${dir_src}/.git" tag --list;;
		env)        $b && loadToolchain && print_vars CC CXX LD AS AR NM RANLIB STRIP ADDR2LINE OBJCOPY OBJDUMP READELF SIZE STRINGS WINDRES GCOV;;
		deps)       for f in ${dir_root}/*.sh; do
					[ -n "$(cat $f | grep -oP 'dep=.*'${lib}'.*')" ] && echo $(basename $f) | sed 's|\.sh||'
					done
					;;
	esac
	return 0
}

menu_goto(){
	case $1 in
		src|source) pushd ${dir_src};;
		bin)        pushd ${dir_install_bin};;
		lib)        pushd ${dir_install_lib};;
		include)    pushd ${dir_install_include};;
		pkgconfig)  pushd ${dir_install_pc};;
		*)          exit 0;;
	esac
#bash
}

utils_get_latest_release(){
	if fn_defined 'latest_release'; then
		echo $(latest_release)
	elif [ -z "${src}" ]; then
		echo "Unknown source ${src}"
	else
		local paths=( ${src//\// } )
		paths[3]=${paths[3]/\.git/}
		case ${paths[1]} in
			github.com) github_latest_release "${paths[2]}/${paths[3]}"
				;;
			*) echo $(git ls-remote --tags --sort "v:refname" $src | tail -n1 | rev | awk -v FS='/' '{print $1}' | rev)
				;;
		esac
	fi
}