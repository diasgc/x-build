#!/bin/bash
# ................................................
# X-Build util 0.4.0 2024-diasgc
# ................................................

#set -x
function trap_sigint {
	tput cnorm -- normal
	cd $(dirname $0)
	echo -e "\n\n${CY1}  Interrupted by user${C0}\n  Log available at \e[4m${log_file}\e[24m\n\n"
}

function init {
	[ -f ".config" ] && source .config
	if [ ! -f ".config" ] || test `expr $(date +%s) - $config_lastupdate` -gt $((config_timeout * timeout_days)); then
		./x-setup
		source .config || doErr 'Unable to initialize config file'
	fi
	export is_init=true
}

# first load .common functions and error trap
if [ -z ${vsh+x} ];then
	source .common
	source ./utils/.utils
	source ./utils/.cmake
	set -o pipefail
	if [ "${1}" == "--debug" ];then
		shift
		set -x
		debug=true
	fi
	trap err ERR
fi

clangv=-15

sudo=$(command -v sudo)

export HOST_NPROC=$(nproc)
# defvar debug=false
: "${src_rel:=true}"
: "${host_native:=false}"
: "${debug:=false}"
: "${nodev:=false}"
: "${is_init:=false}"
: "${pkg:=${lib}}"
: "${apt:=${lib}}"
: "${ac_nohost:=false}"
: "${disable_shared:=false}"
: "${ac_nosysroot:=false}"
: "${ac_nopic:=false}"
: "${banner:=true}"
: "${req_update_deps:=false}"
: "${update:=false}"
: "${build_dist:=true}"
: "${dep_build:=--static}"
: "${build_allshared:=false}"
: "${build_strip:=false}"
: "${build_cpack:=false}"
: "${API:=34}"
: "${git_checkout:=false}"
: "${def_build_sys:=meson}"
: "${inline:=false}"
: "${build_download:=false}"
: "${config_timeout:=86400}"
: "${indent:=0}"
: "${ind:=}"
: "${vnd:=}"
: "${ac_reconf:=true}"
: "${cmake_build_type:=Release}"

ndk_testtc=true

$req_update_deps && update=true
pkg_fmt="tgz"
timeout_days=3

cmake_toolchain_file=
mingw_posix_suffix=
update=false
retry=false
use_llvm_mingw=true
use_clang=true

break_on_git=false
break_on_patch=false
break_on_config=false
break_on_build=false
break_on_make=false


skip_pc=false
skip_dl=false
skip_cpack=true

# default build static, no shared, no executables
build_shared=false
build_static=true
build_bin=false
build_man=false
build_package=true

build_usepkgflags=false
git_stable=false
ndkcmake=false

only_repo=false
pc_filelist=

shell_dstack=

logtime_start=0
logtime_end=0


export CPPFLAGS=
export target_trip=

export dir_sources="${dir_root}/sources" \
       dir_cmake="${dir_root}/cmake" \
       dir_patches="${dir_root}/patches" \
	   dir_pkgdist="${dir_root}/dist"

#export dir_src="${dir_sources}/$(bool2str [ -z "${src_dir}" ] ${lib} ${src_dir} )"
if [ -z "${src_dir}" ];then
	export dir_src=${dir_sources}/${lib}
else
	export dir_src=${dir_sources}/${src_dir}
fi

[ -d "${dir_sources}" ] || mkdir -p ${dir_sources}

! $is_init && init








main(){

	# exit if missing vars lib arch or src
	if [ -z "${lib}" ]; then
		echo -e "\n\n\t${CB1}  Toolchain is loadad.\n\tNow exiting...\n\n${C0}"
		return 0
	fi

	inc_tab

	if [ -z "${lic}" ] || [ -z "${dsc}" ];then
		gitjson="$(git_api_tojson ${src})"
		if [ -n "${gitjson}" ];then
			#echo -ne "${CY1}${b}${C0}"
			: "${lic:=$(echo "$gitjson" | jq .licence)}"
			: "${dsc:=$(echo "$gitjson" | jq .description)}"
		fi
	fi

	# show package info
	export log_file="${dir_install}/${lib}.log"

	if [ -z "$(check_install pc)" ]; then
		package_showinfo
	elif $update || $retry || $git_checkout; then
		package_showinfo
	else
		end_script    
	fi
}



# Variables
# mki: rule for install 'make $mkinstall' (default: install)
# mkc: rule for clean 'make $mkclean' (default: clean)
# mkf: additional rule for make
# no_host  : while using autotools, no host will be set for cross-compile if no_host is not empty

gitjson=

start(){

	# Should we download the package instead of building it?
	if ${build_download}; then
		local lnk=$(get_link_pkg ${arch} ${lib})
		if [ -n "${lnk}" ]; then
			wget_pkg_tgz ${lnk} ${dir_install}
			$skip_pc || logver "${dir_install_pc}/${pkg}.pc"
			end_script
			exit 0
		fi
	fi

	fn_defined 'on_config' && on_config

	case ${target_trip[3]} in
		android) fn_defined 'on_config_ndk'   && fn_log '' on_config_ndk;;
		gnu)     fn_defined 'on_config_gnu'   && fn_log '' on_config_gnu;;
		mingw32) fn_defined 'on_config_mingw' && fn_log '' on_config_mingw;;
	esac

	if ${host_arm}; then 
		fn_defined 'on_config_arm' && fn_log '' on_config_arm
	else
		fn_defined 'on_config_x86x' && fn_log '' on_config_x86x
	fi

	fn_defined 'on_build_bin' && unset CBN && on_build_bin 
	fn_defined 'on_build_static' && unset CSH && on_build_static
	fn_defined 'on_build_shared' && unset CSH && on_build_shared

	# check whether to update source of main lib and dependencies
	if ${update}; then
		[ -d "${dir_src}" ] && rm -rf "${dir_src}" 2>/dev/null
		! $req_update_deps && update=false
	else
		! $git_checkout && ! $retry && [ -f "${dir_install_pc}/${pkg}.pc" ] && exit
	fi

	# Reset LOGFILE
	[ -f "${log_file}" ] && rm -f ${log_file}

	# Create INSTALL_DIR and PKGCONFIG DIR
	mkdir -p ${dir_install_pc} ${dir_install}/share/pkgconfig
	export PKG_CONFIG_LIBDIR="${dir_install_pc}:${dir_install}/share/pkgconfig:${PKG_CONFIG_LIBDIR}"
	export PKG_CONFIG_PATH=

	# check build tools
	check_tools $tls

	local ovrs=$vrs
	local ocsh=$CSH
	local ocbn=$CBN
	unset vrs CSH CBN

	build_dependencies $dep

	vrs=$ovrs
	CSH=$ocsh
	CBN=$ocbn7

	log_start $arch ${eta}s

	local bss=
	
	$build_static && bss="${SSB}[static]" || bss="${CD}[static]"
	$build_shared && bss="${bss}${SSB}[shared]" || bss="${bss}${CD}[shared]"
	$build_bin && echo -ne "${bss}${SSB}[bin]${C0} " || echo -ne "${bss}${CD}[bin]${C0} "
	
	cd ${dir_sources}


	if [ ! ${retry} ]; then
		if [ "${dir_build}" != "${dir_src}" ] && [[ "${dir_build}" != "${dir_config}" ]]; then
			rm -rf ${dir_build}
		fi
	fi

	local require_src_config=false
	local require_src_patch=false

	# get source
	if [ ! -d ${dir_src} ];then
		${skip_dl} || get_source
		
		require_src_config=true

		${break_on_git} && end_script

		test "x${cfg}" == "xcmake" && cmake_check_cmakefiles

		if fn_defined 'patch_source'; then
			fn_log 'patch' patch_source
		elif [ -n "${patch[@]}" ]; then
			fn_log '' patch_check_patchdir
		fi
	fi

	cd "${dir_src}"

	if [ -n "${bra}" ]; then
		do_log "${bra}" git checkout ${bra}
	elif $git_checkout; then
		do_log 'checkout' git checkout
		unset git_checkout
	fi

	case $src in *git*) echo -ne "${CT0}[$(git describe --tags 2>/dev/null)]${CD} ";; esac
	
	# default dir_config is dir_src
	: "${dir_config:=${dir_src}}"
	# check if defined custom dir_config location (config_dir)
	[ -n "${config_dir+x}" ] && dir_config="${dir_src}/${config_dir}"

	cd ${dir_config}

	if [ -z "${cfg}" ]; then
		config_guess
	fi

	if ${require_src_config}; then
		# check whether to custom config source
		if fn_defined 'source_config'; then
			fn_log 'config' source_config
		elif [ -n "${cfg_cmd}" ];then
			do_log 'config' ${cfg_cmd}
			unset cfg_cmd
		else case $cfg in
			ab)		[ -f "${dir_config}/boostrap" ] && do_log 'bootstrap' ${dir_config}/boostrap
					[ -f "${dir_config}/boostrap.sh" ] && do_log 'bootstrap' ${dir_config}/boostrap.sh
					;;
			ag) 	doAutogen ${dir_config} --noconfigure;;
			ar) 	doAutoreconf ${dir_config};;
			am)		if [ ! -f "${dir_config}/configure" ];then
						if [ -f "${dir_config}/autogen.sh" ];then
							doAutogen ${dir_config} --noconfigure
						else
							doAutoreconf ${dir_config}
						fi
					fi
					;;
			esac
		fi
		require_src_patch=true
	fi

	if $require_src_patch; then
		# check if has auto patch embeded in source: depracated
		patch_check_xbpatch
		# check if has patch function in source
		if fn_defined 'source_patch'; then
			fn_log 'patch' source_patch
		fi
		if [ -n "${cmake_cmakelists}" ]; then
			local fcmake="${dir_root}/cmake/$cmake_cmakelists"
			if [ -f "${fcmake}" ]; then
				local fcmake_dst="${dir_src}/CMakeLists.txt"
				cp -f "${fcmake}" "${fcmake_dst}" || doErr "Unable to copy ${fcmake} to ${fcmake_dst}"
				unset cmakelists_ext
			fi
		fi
	fi

	$break_on_patch && end_script

	if [ -z "${dir_build}" ];then
		case ${build_system} in
			cmake|meson|automake) dir_build="${dir_config}/build_${arch}"
				[ -d "${dir_build}" ] && rm -rf ${dir_build} 2>/dev/null
				;;
			*) dir_build=${dir_config};;
		esac
	fi

	[ -d "${dir_build}" ] || mkdir -p "${dir_build}"
	cd ${dir_build}

	log_vars dir_src dep PKG_CONFIG_LIBDIR
	log_vars API CC CXX LD AS AR NM RANLIB STRIP

	if fn_defined 'build_all'; then
		fn_log 'build' build_all
		end_script
	fi

	if fn_defined 'build_prepare'; then
		fn_log 'prepare' build_prepare
	fi

	if fn_defined 'build_clean'; then
		fn_log 'clean' build_clean
	elif [ -f "Makefile" ]; then
		mkc=$(make_findtarget "distclean" "clean")
		[ -n "${mkc}" ] && do_quietly 'clean' ${MAKE_EXECUTABLE} $mkc
	fi

	local arr
	if fn_defined 'build_config'; then
		build_config
		unset -f build_config
	else case "${build_system}" in
		cmake)
			cmake_configure
			cfg_cmd=${CMAKE_EXECUTABLE}
			: "${cmake_bdir:=${dir_config}}"
			cfg_args+=("${cmake_bdir}" "-DCMAKE_INSTALL_PREFIX=${dir_install}" "-DCMAKE_BUILD_TYPE=${cmake_build_type}" "${CTC}" "${CFG}" "${CSH}" "${CBN}" "${CPACK}" -Wno-dev)
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			case $cfg in ccm|ccmake) tput sc; ccmake ..; tput rc;; esac
			;;

		automake) # use autotools and configure executable to create makefile
			ac_configure
			cfg_cmd="${dir_config}/configure"
			cfg_args+=("--prefix=${dir_install}" "${CFG}" "${CSH}" "${CBN}")
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			;;

		meson)
			meson_configure
			cfg_cmd='meson'
			cfg_args+=('setup' '--buildtype=release' "--cross-file=${cfg_file}" "--prefix=${dir_install}" "${CFG}" "${CSH}" "${CBN}")
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			#do_log 'meson' meson setup --buildtype=release --cross-file=${cfg_file} --prefix=${dir_install} ${CFG} ${CSH} ${CBN}
			;;

		make)
			: "${mkf:=$CFG}"
			MAKE_EXECUTABLE=make
			;;
		bazel)
			cfg_cmd='bazel'
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			;;
		*)	if [ -n "${cfg_cmd}" ]; then
				do_log 'config' ${cfg_cmd} ${cfg_args[@]}
			else
				doErr "cfg ${cfg} unknown or cfg_cmd not defined. Use build_config to custom configure makefile"
			fi
			;;
		esac
	fi

	${break_on_config} && end_script

	if fn_defined 'before_make'; then
		fn_log 'preparing' before_make
	fi

	[ -n "${WFLAGS}" ] && CPPFLAGS+=" ${WFLAGS}"

	if [ -z "${static_ldflag}" ];then
		static_ldflag='-static'
		# set -all-static flags at make time (see: https://stackoverflow.com/questions/20068947/how-to-static-link-linux-software-that-uses-configure)
		# $build_static && [[ "$LDFLAGS" != *"-all-static"* ]] && LDFLAGS="-all-static $LDFLAGS"
		$host_clang && static_ldflag="-all${static_ldflag}"
	fi

	$host_clang && $build_static && LDFLAGS="-static $LDFLAGS"

	log_vars CFLAGS CXXFLAGS WFLAGS CPPFLAGS LDFLAGS LIBS

	[ -z "${mki}" ] && mki="install"
	: "${skip_make:=false}"

	if fn_defined 'on_make'; then
		fn_log 'make' on_make
	elif ! $skip_make; then
		do_progress 'make' "${MAKE_EXECUTABLE}" ${mkf} -j${HOST_NPROC} || err
		unset skip_make
	fi

	${break_on_make} && end_script
	


	if fn_defined 'before_install'; then
		fn_log 'preparing' before_install
	fi

	# strip libs
	if ! ${host_mingw}; then
		if fn_defined 'on_strip'; then
			fn_log 'strip' on_strip
		elif ${build_strip}; then
			do_log 'strip' doStrip
		fi
	fi

	if fn_defined 'on_install'; then
		fn_log 'install' on_install
	else
		cd "${dir_build}"
		do_log 'install' "${MAKE_EXECUTABLE}" ${mki}
	fi

	# check whether to create pkg-config .pc file
	if ! ${skip_pc}; then
		fn_defined 'get_version' && vrs="$(get_version)"
		
		if fn_defined 'on_create_pc'; then
			fn_log 'pkgconfig' on_create_pc
		elif [ -n "$pc_llib" ]; then
			do_log 'pkgconfig' create_pkgconfig_file $pkg $pc_llib
		elif [ -n "${pc_llibs}" ]; then
			local p
			for f in ${pc_llibs}; do
				[ "${f::2}" == "-l" ] && p="${f:2}" || p="$f"
				create_pkgconfig_file $p $f
			done
		fi
	fi

	local pcfile=${dir_install_pc}/${pkg}.pc

	if [ ! -f "${pcfile}" ] && [ -f "${dir_install}/share/pkgconfig/${lib}.pc" ]; then
		pcfile="${dir_install}/share/pkgconfig/${lib}.pc"
	fi

	if ${build_cpack}; then
		if [ -z "${CPACK}" ]; then
			if fn_defined 'on_pack'; then
				fn_log 'pack' on_pack
			elif $build_package; then
				if [ -f "${dir_build}/install_manifest.txt" ]; then
					do_log 'cpack' cmake_build_package
				else
					do_log 'pack' build_packages_bin
				fi
			fi
		else
			cd "${dir_build}"
			vrs="$(pkg-config ${pcfile} --modversion)"
			do_log 'cpack' cpack -G DEB -P "${lib}_${vrs}_${arch}"
		fi
	fi

	cd ${dir_src}

	${skip_pc} || logver "${pcfile}"

	fn_defined 'on_end' && fn_log '' on_end

	local pcvrs=$(pkg-config --modversion ${pcfile})
	local scrpt=${dir_root}/$(basename "$0")
	test -n "${pcvrs}" && sed -i "s/dev_vrs='.*'/dev_vrs='"${pcvrs}"'/g" ${scrpt}

	end_script
}	

# see https://mesonbuild.com/Commands.html for command line options
meson_configure(){
	export cfg_file="${dir_config}/${arch}.meson"
	test -f "${cfg_file}"  && rm ${cfg_file}
	${host_clang} || LD="bfd"
	if [ -n "${meson_bin}" ]; then
		arr=(${meson_bin//|/ })
		case ${#arr[@]} in
			1) CBN="-D${arr[0]}=$(bool2str ${build_bin} true false)";;
			2) CBN="-D$(bool2str ${build_bin} ${arr[1]} ${arr[0]})";;
		esac
	fi
	meson_create_toolchain ${cfg_file}
	MAKE_EXECUTABLE=ninja
	$build_static && meson_cfg+=' --prefer-static'
	[ -n "${meson_cfg}" ] && CFG="${meson_cfg} ${CFG}"
}

ac_configure() {
	$ac_reconf && autoreconf -fi 2>/dev/null >>${log_file}
	#[ -z "${mki+x}" ] && mki=$(make_findtarget "install-strip" "install")
	[ -z "$exec_config" ] && exec_config='configure' # default config executable
	[ -n "${ac_config}" ] && CFG=${ac_config}

	local opt_list="$(${dir_config}/${exec_config} --help | grep -P '^[[:space:]]+\-\-')"

	# find static build option
	if $build_static && [ -n "$(echo "${opt_list}" | grep '\-\-enable-static')" ]; then
		build_type="--enable-static"
	fi
	# find shared build option
	if $build_shared && [ -n "$(echo "${opt_list}" | grep '\-\-enable-shared')" ]; then
		build_type+=" --enable-shared"
	fi

	if [ -n "${ac_bin}" ]; then
		arr=(${ac_bin//|/ })
		case ${#arr[@]} in
			1) CBN=$(bool2str ${build_bin} "${arr[0]}=1" "${arr[0]}=0");;
			2) CBN=$(bool2str ${build_bin} "${arr[1]}" "${arr[0]}");;
		esac
	fi

	if [ -n "${ac_opts}" ]; then
		for opt in $(echo ${ac_opts}); do
			case $opt in
				--update-config_sub)
					local fpath=$(find ${dir_src} -name 'config.sub')
					test -f "${fpath}" && cp -f /usr/share/automake*/config.sub ${fpath}
					;;
				--update-config_guess)
					local fpath=$(find ${dir_src} -name 'config.guess')
					test -f "${fpath}" && cp -f /usr/share/automake*/config.guess ${fpath}
					;;
				--no-sysroot)
					ac_nosysroot=true
					;;
				--no-pic)
					ac_nopic=true
					;;
				--no-host)
					ac_nohost=true
					;;
			esac
		done
	fi

	if ! $ac_nohost && $host_cross && [ -n "$(echo "${opt_list}" | grep '\-\-host')" ]; then
		$host_cross && CFG+=" --host=${arch}"
	fi

	if ! $ac_nosysroot; then
		if [ -n "$(echo "${opt_list}" | grep '\-\-with-sysroot')" ]; then
			CFG+=" --with-sysroot=${SYSROOT}"
		elif [ -n "$(echo "${opt_list}" | grep '\-\-sysroot')" ]; then
			CFG+=" --sysroot=${SYSROOT}"
		fi
	fi

	if ! $ac_nopic && ! $host_mingw && [ -n "$(echo "${opt_list}" | grep '\-\-with-pic')" ]; then
		CFG+=" --with-pic"
	fi
	MAKE_EXECUTABLE=make
}

doStrip(){
	local libdir
	for dd in $(find ${dir_build} \( -name "*.a" -o -name "*.so" \));do
		${STRIP} --strip-unneeded $dd
	done
}

end_script(){
	log_end
	# check if parent process is shell script
	local parent=$(ps -o comm= $PPID)
	[ "${parent: -3}" == ".sh" ] || echo -e "\n${CT1}::Done${C0}\n"
	$debug && set +x
	unset	dir_config dir_build dir_src \
			CSH CBN exec_config vrs vnd \
			ac_nohost ac_nopic ac_nosysroot ac_opts ac_reconf \
			req_pcforlibs mkc mki mingw_posix \
			cfg_args LIBS CFLAGS CXXFLAGS LDFLAGS WFLAGS
	dec_tab
	echo
	exit 0
}

make_findtarget(){
	${MAKE_EXECUTABLE} ${1} -n 2>>${log_file}
	if test $? -eq 2 ; then
		echo "${2}"; echo "make: target ${1} not found, setting default ${2} target." >>${log_file}
	else
		echo "${1}"; echo "make: target ${1} found." >>${log_file}
	fi
}

check_install(){
	local ext=''
	case "${1}" in
		# check includes
		inc*)
			for h in $lst_inc; do 
				test -z "$(ls ${dir_install}/include/$h 2>/dev/null)" && echo && return 0
			done
			echo 1
			return 0
			;;
		# check libs
		static*) ext='\.a';;
		shared*) $host_mingw && ext='\.dll*' || ext='\.so*';;
		lib*) ext='.*';;
		# check bin
		bin)
			for h in $lst_bin; do 
				test -z "$(ls "${dir_install}/bin/${h}" 2>/dev/null)" && echo && return 0
			done
			echo 1
			return 0
			;;
		# check pkgconfig
		pc|pkgconfig)
			[ -z "${lst_pc}" ] && echo && return 0
			for h in $lst_pc; do 
				test -z "$(ls "${dir_install}/lib/pkgconfig/${h}" 2>/dev/null)" && echo && return 0
			done
			echo 1
			return 0
			;;
	esac
	if [ -n "${ext}" ];then
		for h in $lst_lib; do
		echo "listing ${dir_install}/lib/${h}${ext}"
		test -z "$(ls ${dir_install}/lib/${h}.* | grep ''${ext}'' 2>/dev/null)" && echo && return 0
		done
		echo 1
		return 0
	fi
	echo
	return 0
}


function build_dependencies {
	local dep_args="${arch}"
	local dep_file
	dep_args+=" $(bool2str ${build_allshared} shared static)"
	while [ -n "${1}" ]; do
		dep_file="${dir_root}/${1}.sh"
		test -f "${dep_file}" || exit_err "Fail to build dependency ${1}. ${dep_file} not found."

		${dep_file} ${dep_args}
		
		shift
	done
}

build_dependencies_old(){
	local pkgfile
	local o_csh
	local o_cbh
	local cf
	local ldir
	while [ -n "${1}" ]; do
		[ -f "./${1}.sh" ] || doErr "no script file ${1}.sh.\n  Aborting..."
		pkgfile=$(./${1}.sh ${arch} --get pc)
		libname=$(./${1}.sh --get libname)
		if [ ! -f "${pkgfile}" ]; then
			o_csh=$CSH
			o_cbh=$CBH
			${build_download} && local dl="--dl" || local dl=''
			unset CSH CBH
			
			./${1}.sh ${arch} ${dep_build} ${dl}
			
			CSH=$o_csh
			CBH=$o_cbh
		fi
		if [ -f "${pkgfile}" ]; then
			local cmi=$(./${1}.sh ${arch} --get cmake_include)
			[ -n "$cmi" ] && cmake_includes="$cmi $cmake_includes"
			ldir="$(dirname ${pkgfile})"
			str_contains $PKG_CONFIG_LIBDIR ${ldir} || PKG_CONFIG_LIBDIR="${ldir}:${PKG_CONFIG_LIBDIR}"
		fi
		shift
	done
}


#usage: meson_create_toolchain <out.meson.file>
meson_create_toolchain(){
	case $arch in
		aarch*)  cpu1="aarch64" cpu2="aarch64";;
		arm*)    cpu1="arm"     cpu2="arm";;
		i686*)   cpu1="x86"     cpu2="i686";;
		x86_64*) cpu1="x86_64"  cpu2="x86_64";;
	esac
	cmake_create_toolchain ${dir_build}

	cat <<-EOF >${1}
		[binaries]
		c = '${CC}'
		c_ld = '${LD}'
		cpp = '${CXX}'
		cpp_ld = '${LD}'
		ar = '${AR}'
		as = '${AS}'
		pkg-config = '$(command -v pkg-config)'
		addr2line = '${ADDR2LINE}'
		objcopy = '${OBJCOPY}'
		objdump = '${OBJDUMP}'
		ranlib = '${RANLIB}'
		readelf = '${READELF}'
		size = '${SIZE}'
		strings = '${STRINGS}'
		strip = '${STRIP}'
		windres = '${WINDRES}'

		[properties]
		needs_exe_wrapper = true
		cmake_toolchain_file = '${cmake_toolchain_file}'

		[host_machine]
		system = '$(str_lowercase ${PLATFORM})'
		cpu_family = '${cpu1}'
		endian = 'little'
		cpu = '${cpu2}'

		[target_machine]
		system = '$(str_lowercase ${PLATFORM})'
		cpu_family = '${cpu1}'
		endian = 'little'
		cpu = '${cpu2}'
		EOF

	echo -e "\nMeson file:(${1})\n\n" >>${log_file} 2>&1
	cat ${1} >>${log_file} 2>&1
}

# usage cmake_create_toolchain <dir>
cmake_create_toolchain(){
	cmake_build_toolchainfile
}

cargo_create_toolchain(){
cat <<-EOF >>cargo-config.toml
	[target.aarch64-linux-android]
	ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
	linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${API}-clang"

	[target.arm-linux-androideabi]
	ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
	linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi${API}-clang"

	[target.i686-linux-android]
	ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
	linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android${API}-clang"

	[target.x86_64-linux-android]
	ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
	linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android${API}-clang"
	EOF
}

# usage: check_tool_dependency <exe-name> <pkg-name>. returns path of exe-name
check_tool_dependency(){
	local nm
	local pk
	if [ -n "$1" ];then
		nm=$1
		[ -n "$2" ] && pk=$2 || pk=$1
		[ -z $(command -v $nm) ] && apt_install $pk
		nm=$(command -v $nm)
	fi
	echo $nm
}


check_tools(){
	while [ -n "$1" ]; do
		toolname=$1
		toolpkg=$1
		case $1 in
			rust )      installRust && continue;;
			libtool )   toolname=libtoolize;;
			texinfo )   toolname=makeinfo;;
			autotools ) autotools_check && continue;;
		* ) ;;
		esac
		request_cmd ${toolname} ${toolpkg}
		shift
	done
}

# usage: chkTools tools...
autotools_check(){
	if [ -z $(command -v automake) ];then
		tput sc
		$sudo apt -qq install automake autogen autoconf m4 libtool-bin -y >/dev/null 2>&1 
		tput rc
	fi
}

# make args...
do_make(){
	make $@ 2>&1 | tee -a ${log_file} | grep -Eo "\[.+%\]" 
}

secs2time(){
	[ $(($1/60%60)) -eq 0 ] && printf '%ds' $(($1%60)) || printf '%dm %ds' $(($1/60%60)) $(($1%60))
}

log_start(){
	logtime_start=$(date +%s)
	#echo -ne "$CC1  $@: "
	if ! $inline; then
		echo -ne "${CD}${inde}${C0}$(date '+%H:%M')"
		[ $eta ] && echo -ne "-${CW}$(date '+%H:%M' --date="$eta seconds")"
		printf " ${CT1}%-10s ${CT1}%-21s${CD} " ${lib} ${arch}
	fi
	echo $(date) > ${log_file}
}

log_end(){
	if ! $inline && [ -n "${logtime_start}" ]; then
		logtime_end=$(date +%s)
		#local pkgsize=$(du -sk ${dir_install} | cut -f1)
		#local libsize=$(du -sk ${dir_install}/lib | cut -f1)
		local secs=$(($logtime_end-$logtime_start))
		local msg="${CT1} done ${CD}in $(secs2time ${secs})"
		[ $secs -gt 60 ] && msg="$msg (${secs}s)"
		#echo -e "$msg pkg/lib: ${pkgsize}/${libsize}kb${C0}"
		echo -e "$msg"
	fi
}

log(){
	echo -ne "$CD$@$C0"
}

logf(){
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
}

log_vars(){
	local t;
	while [ -n "$1" ]; do
		echo "$1=${!1}" >>${log_file} 2>&1
		shift
	done
	echo >>${log_file}
}

print_vars(){
	while [ -n "$1" ]; do
		printf "${CC0}%-20s: ${C0}%s\n" "  ${1}" ${!1}
		shift
	done
}

doErr(){
	echo -e "${CR1}  Error: ${CR0}${1}${C0}\n\n"
	if [ -f ${log_file} ];then
		if [ -f ${dir_build}/CMakeFiles/CMakeError.log ];then
		echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> ${log_file}
		cat ${dir_build}/CMakeFiles/CMakeError.log >> ${log_file}
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "$openlog" != "n" ] && nano ${log_file}
	fi
	exit 1
}

err(){
	if [ -n "${logtime_start}" ]; then
		logtime_end=$(date +%s)
		echo -e "${CR1} fail ${CR0}[$(secs2time $(($logtime_end-$logtime_start)))]${C0}\n"
	fi
	if [ -f ${log_file} ];then
		if [ -f ${dir_build}/CMakeFiles/CMakeError.log ];then
		echo -e "\n\n${dir_build}/CMakeFiles/CMakeError.log:\n" >> ${log_file}
		cat ${dir_build}/CMakeFiles/CMakeError.log >> ${log_file}
		fi
		echo -ne "${CD}${ind}${CY1}Open log? [Y|n]:${C0}" && read openlog
		[ "$openlog" != "n" ] && nano ${log_file}
	fi
	echo
	exit 1
}

log_this() {
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	"$@" 2>> "${log_file}" 1>> "${log_file}" || err
	logok
}


do_quietly(){
	local var=$1; shift
	echo -ne "${CD}${var}${C0}"
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	"$@" >/dev/null 2>&1
	logok $var
}

do_log() {
	local var=$1; shift
	echo -ne "${CD}${var}${C0}"
	log_this $@
	logok $var
}

do_progress() {
	local var=$1; shift
	echo -ne "${CD}${var}"
	echo -e "\n$(date +"%T"): $@" >> "${log_file}"
	("$@" |& tee -a ${log_file} | topct) || doErr "in ${var}:\n\n...\n$(tail -n5 ${log_file})${C0}"
	logok $var
}

logok() {
	echo -ne "\e[${#1}D${CT0}${1}${C0} "
}

# usage logver /path/to/pkgconfigfile.pc
logver() {
	if [ -f $1 ];then
		echo -ne "${CT1}version $(pkg-config --modversion $1)${C0}"
	else
		echo -ne "${CS0} missing ${1} ${C0}"
	fi
}

inline_ccmake(){
	tput sc; ccmake $@; tput rc
}

isBottomRow(){
	test "$(echo "lines"|tput -S)" == "$(IFS=';' read -sdR -p $'\e[6n' ROW COL && echo "${ROW#*[}")" && echo 1 || echo 0
}

# usage: do_git giturl [libname]
do_git(){
	do_log 'git' git clone $1 $2
	cd $2
	if [ -n "${bra}" ]; then
		do_log ${bra} git checkout ${bra}
	elif [ -n "${vrs}" ]; then
		do_log ${vrs} git checkout tags/${vrs}
	fi
	if [ -n "${sub}" ];then
		do_log 'sub' git ${sub}
	fi
	cd ..
}

prt_git_progress(){
	tput civis
	printf "%-8s"
	local s0
	local s1
	local n1=0
	while read -r ln; do
		if ! [ "${ln%\'...}" == "${ln}" ]; then
		printf "\e[7D"
		printf "%-40s\e[40D"
		s1=${ln#*\'}
		s1=${s1##*/}
		s1=${s1%\'...}
		printf "\e[${n1}D"
		n1=${#s1}
		[ $n1 -gt 0 ] && printf " %-${n1}s" $s1
		printf "%-6s"
		else
		s0=$(grep -oP '\d+%' <<< $ln)
		[ -n "$s0" ] && printf "\e[5D%-5s" $s0
		fi
	done
	[ $n1 -gt 0 ] && printf "\e[${n1}D"
	printf "\e[7D"
	tput cnorm
}

topct(){
	local sln
	local grp
	tput civis
	printf "build_system: %10s; make: %7s" ${build_system} ${MAKE_EXECUTABLE} >>${log_file}
	if [ "${build_system}" == "cmake" ] && [ "$(basename ${MAKE_EXECUTABLE})" == "make" ]; then
		printf "%-6s"
		while read -r ln; do
			str_contains "${ln}" 'error: ' && printf $CR1
			sln=$(grep -oP '\d+%' <<< $ln)
			[ -n "$sln" ] && printf "\e[5D%-5s" $sln
		done
		printf "\e[6D"
	elif [ "$(basename ${MAKE_EXECUTABLE})" == "ninja" ]; then
		printf "%-12s"
		while read -r ln; do
			str_contains $ln 'error: ' && printf $CR1
			sln=$(grep -oP '\[\d+/\d+\]' <<< $ln)
			[ -n "$sln" ] && printf "\e[11D%-11s" $sln
		done
		printf "\e[12D"
	else
		printf "%-6s"
		while read -r ln; do
			sln+="." # ·
			[ ${#sln} -eq 5 ] && sln=''
			[ -n "$sln" ] && printf "\e[5D%-5s" $sln
		done
		printf "\e[6D"
	fi
	tput cnorm
}

set_git_version(){
	pushdir ${dir_src}
	local v=$(git describe --abbrev=0 --tags 2>/dev/null)
	[ -n "$v" ] && export vrs=$v
	popdir
}



wget_pkg_tgz(){
	local tag="$(basename ${1})"
	tag="pkg: ${tag//_${arch}.tag.gz/}"
	printf "${CD}%s${C0}" ${tag}
	printf "\n\n$(date): wget/untar %-50s to %s" $1 $2 >>${log_file}
	wget -qO- ${1} 2>>${log_file} | tar --transform 's/^dbt2-0.37.50.3/dbt2/' -xvz -C ${2} >>${log_file} 2>&1 || err
	echo -e "\n\n" >>${log_file}
	logok $tag
}

# Usage: wget_targz src_url dest_dir
wget_targz(){
	pushd $(dirname $2)
	wget -qO- $1 2>>${log_file} | tar --transform 's/^dbt2-0.37.50.3/dbt2/' -xvz -C $2 >/dev/null 2>&1 || err
	popd
}

wget_tar(){
	local tag="source"
	local args=
	echo -ne "${CD}${tag}${C0}"
	echo -e "\n\n$@\n----------------------------------------\n" >> "${log_file}"
	echo "$(date): $@" >> "${log_file}"
	case $sty in
		tlz|tar_lz) 
		test -z $(command -v lzip) && apt_install lzip
		ags="--lzip -xv"
		;;
		tgz|tar_gz) args="-xvz";;
		txz|tar_xz) args="-xvJ";;
	esac
	wget -qO- $src 2>>${log_file} | tar --transform 's/^dbt2-0.37.50.3/dbt2/' $args >/dev/null 2>&1 || err
	mv ${1}* ${lib}
	echo -e "----------------------------------------\n" >> "${log_file}"
	logok $tag
}

getZip(){
	[ -z $(command -v unzip) ] && apt_install unzip
	log download
	wget $1 -O tmp.zip || err
	log extract unzip tmp.zip
	rm tmp.zip
	logok
}




clean(){
	echo -ne "${CT0}\n\tcleaning...\n"
	rm -rf builds/$arch/$lib builds/$arch/$lib.log
	pushdir sources/$lib
	[ -f Makefile ] && make clean
	popdir
	echo -e "$C0\tdone"
	clear
}



showOpts(){
	if [ -d "$1" ];then
		local od=$(pwd)
		local bdir=$(pwd)/builds
		cd "${1}/${config_dir}"
		[ -f CMakeLists.txt ] && ${CMAKE_EXECUTABLE} -LA | awk '{if(f)print} /-- Cache values/{f=1}' >${od}/builds/${lib}_cmake.opts && nano "${od}/builds/${lib}_cmake.opts"
		[ -f configure ] && ./configure --help >${od}/builds/${lib}_aconf.opts && nano "${od}/builds/${lib}_aconf.opts"
		cd $od
	else
		echo -e "${CD}${ind}${CR0}no configuration file found in ${CR1}${1}${CD}\n\n"
	fi
}



doAutogen(){
	[ $1 ] || doErr "missing arg in doAutogen: usage doAutogen <AUTOGEN_DIR>"
	local var="autogen"
	echo -ne "${CD}${var}${C0}"
	pushdir $1
	shift
	case $1 in
		--noerr ) ./autogen.sh >>${log_file} 2>&1;;
		--noconfigure ) NOCONFIGURE=1 log_this ./autogen.sh;;
		* ) log_this ./autogen.sh;;
	esac
	popdir
	logok $var
}

doAutoreconf(){
	local d=${1}
	local var="autoreconf"
	local od=$(pwd)
	[ -z "${d}" ] && d=${dir_config}
	echo -ne "${CD}${var}${C0}"
	cd $d
	log_this autoreconf -fi
	cd $od
	logok $var
}

download(){
	# bsdtar from stdin doesnt extract file +x permission
	# wget -qO- $1 | bsdtar -xvf- >/dev/null 2>&1
	echo -ne " ${CD}checking tools"
	test -z $(command -v unzip) && apt_installBr unzip
	echo -ne " ${CS0}downloading..."
	tput sc && echo -ne "\e[$(tput lines);0H${CY1}"
	wget --progress=dot $1 -O tmp.zip 2>&1 | grep --line-buffered "%" | sed -u -e "s,\.,,g" | awk '{printf("\r%4s %s eta:%s  ",$2,$1,$4)}'
	tput rc
	echo -ne "${CS0} decompressing... ${C0}"
	unzip tmp.zip >/dev/null 2>&1 && rm tmp.zip || err
}

toolchain_android(){
	PLATFORM='Android'
	[ -d "${ANDROID_NDK_HOME}" ] || doErr "No ANDROID NDK Toolchain found. Aborting."

	TOOLCHAIN="/usr/${arch}"
	SYSROOT="${TOOLCHAIN}/sysroot"
	CROSS_PREFIX="${TOOLCHAIN}/bin/"

	CC="${CROSS_PREFIX}clang"
	CXX="${CROSS_PREFIX}clang++"
	AS="${CC}"
	LD="${CROSS_PREFIX}ld"
	YASM=${CROSS_PREFIX}yasm
	ASM_NASM=${YASM}

	CMAKE_TOOLCHAIN="${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake"
	LT_SYS_LIBRARY_PATH="${TOOLCHAIN}/lib:${SYSROOT}/usr/lib/${arch}:${SYSROOT}/usr/lib/${arch}/${NDK_API}"
	PKG_CONFIG_DIR="/usr/${arch}/local/lib/pkgconfig"
	CPPFLAGS+=" -I${SYSROOT}/usr/include -I/usr/${arch}/include -I${SYSROOT}/usr/include"
	LDFLAGS="-Wl,-rpath,${LT_SYS_LIBRARY_PATH} ${LDFLAGS}"
	#test $build_static && LDFLAGS+=" -static-libstdc++ -lc++_static"

	cmake_system_processor="${target_trip[0]}${target_trip[1]}"
	$host_arm32 && cmake_system_processor="armv7-a"
	cmake_findrootpath="/usr/${arch} /usr/${arch}/lib /usr/${arch}/lib/${API} /usr/${arch}/sysroot/usr ${dir_install}"
	export NDK_API=${API}
}

toolchain_llvm_mingw(){
	local ltsdir
	local cargs=
	PLATFORM='Windows'

	SYSROOT="/usr/${arch}"
	TOOLCHAIN="${SYSROOT}/bin/"
	CROSS_PREFIX="${LLVM_MINGW_HOME}/bin/${arch}-"
	if $use_clang; then
		CC="${CROSS_PREFIX}clang"
		CXX="${CROSS_PREFIX}clang++"
		AS="${CC}"
		LD="${CROSS_PREFIX}ld"
	else
		CC="${CROSS_PREFIX}gcc"
		CXX="${CROSS_PREFIX}g++"
		AS="${CROSS_PREFIX}as"
		LD="${CROSS_PREFIX}ld"
	fi
	export RC=${CROSS_PREFIX}windres
	LT_SYS_LIBRARY_PATH="${LLVM_MINGW_HOME}/lib/clang/${xv_llvm_mingw}"
	CPPFLAGS+=" -I${SYSROOT}/include"
	LDFLAGS="-L${LT_SYS_LIBRARY_PATH}/lib -L${SYSROOT}/lib ${LDFLAGS}"
	YASM=yasm
	NASM=nasm
	ASM_NASM=${NASM}
	cmake_findrootpath="${SYSROOT} ${LT_SYS_LIBRARY_PATH} ${dir_install}"

}

toolchain_linux(){
	$host_cross && cross="-cross"
	ltsdir=$(gcc -dumpversion)
	if $use_clang; then
		SYSROOT="/usr/${arch}"
		TOOLCHAIN="${SYSROOT}/bin"
		CROSS_PREFIX="llvm-"
		CC="${TOOLCHAIN}/clang"     
		#CC="clang -target ${arch}" # -fuse-ld=lld"
		CXX="${TOOLCHAIN}/clang++"  
		#CXX="clang++ -target ${arch}" # -fuse-ld=lld"++
		AS="${CC}"
		LD="${TOOLCHAIN}/ld.lld" # --sysroot=${SYSROOT}"+
		#$build_static && LDFLAGS+=" -static"
		GNU_CLANG_VERSION_FULL="$(clang -dumpversion)"
		GNU_CLANG_VERSION_MAJOR=${GNU_CLANG_VERSION_FULL%%\.*}
		CPPFLAGS="-I$/usr/lib/clang/${GNU_CLANG_VERSION_MAJOR}/include ${CPPFLAGS}"
		LT_SYS_LIBRARY_PATH="/usr/lib/llvm-${GNU_CLANG_VERSION_MAJOR}/lib"
	else
		SYSROOT="/usr/${arch}"
		TOOLCHAIN="/usr/bin"
		CROSS_PREFIX="${TOOLCHAIN}/${arch}-"
		CC="${CROSS_PREFIX}gcc"
		CXX="${CROSS_PREFIX}g++"
		AS="${CROSS_PREFIX}as"
		LD="${CROSS_PREFIX}ld"
		LT_SYS_LIBRARY_PATH="/usr/lib/gcc${cross}/${arch}/${ltsdir}"
	fi
	ASM_NASM=nasm
	LDFLAGS="-L${SYSROOT}/lib -L${LT_SYS_LIBRARY_PATH} ${LDFLAGS}"
	CPPFLAGS=" -I${SYSROOT}/include -I${SYSROOT}/local/include ${CPPFLAGS}"
	cmake_findrootpath="${SYSROOT} ${LT_SYS_LIBRARY_PATH} ${dir_install}"
}

loadToolchain(){

	CMAKE_EXECUTABLE=cmake
	YASM=yasm
	PKG_CONFIG=pkg-config

	#reset flags

	CPPFLAGS+=" -I${dir_install_include}"
	LDFLAGS="-L${dir_install_lib}"
	cmake_system_processor="${target_trip[0]}${target_trip[1]}"

	if $host_cross; then
		case $PLATFORM in
			Android) toolchain_android;;
			Windows) toolchain_llvm_mingw;;
			Linux)   toolchain_linux;;
		esac
	else
		TOOLCHAIN=/usr/bin
		SYSROOT=/usr
		if ${use_clang}; then
			CROSS_PREFIX=llvm-
			CC=clang CXX=clang++ AS=${CC} LD=ld.lld
			$host_native && CPPFLAGS="-mtune=native ${CPPFLAGS}"
		else
			CROSS_PREFIX=
			CC=gcc CXX=g++ AS=as LD=ld
			$host_native && CPPFLAGS="-march=native ${CPPFLAGS}"
		fi
		ASM_NASM=nasm
	fi

	AR=${CROSS_PREFIX}ar
	NM=${CROSS_PREFIX}nm
	
	ADDR2LINE=${CROSS_PREFIX}addr2line
	OBJCOPY=${CROSS_PREFIX}objcopy
	OBJDUMP=${CROSS_PREFIX}objdump
	RANLIB=${CROSS_PREFIX}ranlib
	READELF=${CROSS_PREFIX}readelf
	SIZE=${CROSS_PREFIX}size
	STRINGS=${CROSS_PREFIX}strings
	STRIP=${CROSS_PREFIX}strip
	WINDRES=${CROSS_PREFIX}windres
	[ -z ${GCOV+x} ] && GCOV=${CROSS_PREFIX}gcov

	# export
	export CMAKE_EXECUTABLE YASM PKG_CONFIG API \
		PLATFORM TOOLCHAIN SYSROOT CC CXX LD AS \
		ADDR2LINE AR NM OBJCOPY OBJDUMP RANLIB \
		READELF SIZE STRINGS STRIP WINDRES \
		CROSS_PREFIX LT_SYS_LIBRARY_PATH CPPFLAGS LDFLAGS
}

getMinGwVersion(){
	echo $(x86_64-w64-mingw32-gcc --version | head -n1 | grep -Eo "(GCC).+-win32" | sed 's|GCC) \(.*\)-win32|\1|')
}

errUnknownTarget(){
	if [ $arch ];then
		echo -e "\n${CD}${ind}${CR1}unknown target ${arch}${C0}\n" && exit 1
	else
		echo -e "\n${CD}${ind}${CR1}must specify a target${C0}\n" && usage && exit 1
	fi
}

showBanner(){
	if $banner; then
		echo -ne "\n\n${CW}Cross Build scripts ${vsh} for Linux${C0}\n"
		[ -n $(command -v lsb_release) ] && echo -ne "$(lsb_release -sd) "
		if [ -n "$(uname -r | grep 'microsoft')" ];then
			echo -ne "WSL2 "
		elif [ -n "$(uname -r | grep 'Microsoft')" ];then
			echo -ne "WSL "
		fi
		echo -e "$(uname -o) $(uname -m) ${C0} kernel $(uname -r)"
		echo -e "${CW}$(hwinfoCountCoresReadable) $(hwinfoProcessor)${C0}"
	fi
}

skip_options(){
	while [ -n "${1}" ] || [ -n "${1##--*}" ]; do
		case $1 in
		dl|git|src) skip_dl=true;;
		esac
		shift
	done
}

set_target(){
	cpu_id="${1}"
	target_trip=("${2}" "${3}" "${4}" "${5}" "${6}" "${7}" "${8}")
	arch="${2}-${4}-${5}${6}"
	CT0="${9}"
	CT1="${10}"
	CPU=${2}
	ABI=${7}
	EABI=${6}
	set_env
}

set_target_build(){
	target_trip[5]=$(uname -m)
	arch="${target_trip[5]}-${OSTYPE}"
	target_trip[0]=${target_trip[5]}
	if [ "${target_triple[0]::3}" == "arm" ]; then
		target_trip[1]="${target_triple[0]:3}"
		target_trip[0]="${target_triple[0]::3}"
	fi
	arr=(${OSTYPE//-/ })
	target_trip[2]=${arr[0]}
	target_trip[3]=${arr[1]}
	if [ -z "${target_trip[3]##*eabi*}" ] ;then
		local a2=${target_trip[3]%eabi*}
		target_trip[4]=${target_trip[3]#${a2}*}
		target_trip[3]=${a2}
	fi
	set_env
	STRIP=strip
}

set_env(){
	case ${target_trip[0]} in
		aarch64) host_arm=true;  host_arm32=false; host_arm64=true;  host_x86=false; host_x64=false; host_bits=64;;
		arm)     host_arm=true;  host_arm32=true;  host_arm64=true;  host_x86=false; host_x64=false; host_bits=32;;
		i686)    host_arm=false; host_arm32=false; host_arm64=false; host_x86=true;  host_x64=false; host_bits=32;;
		x86_64)  host_arm=false; host_arm32=false; host_arm64=false; host_x86=false; host_x64=true; host_bits=64;;
	esac
	case ${target_trip[3]} in
		android) host_sys=linux;   host_mingw=false; host_os=android; host_ndk=true;	host_gnu=false;	host_clang=true;  PLATFORM="Android"
		dir_install="/usr/${arch}/local"
		;;
		gnu)     host_sys=linux;   host_mingw=false; host_os=gnu;     host_ndk=false;	host_gnu=true;	host_clang=false; PLATFORM="Linux"
		dir_install="${dir_root}/builds/${PLATFORM,,}/${target_trip[5]}"
		;;
		mingw32) host_sys=windows; host_mingw=true;  host_os=mingw32; host_ndk=false;	host_gnu=false;	host_clang=true;  PLATFORM="Windows"
		dir_install="${dir_root}/builds/${PLATFORM,,}/${target_trip[5]}"
		;;
	esac
	#LIBSDIR="$(pwd)/builds/${PLATFORM,,}/${target_trip[5]}"
	export dir_install
	export dir_install_bin="${dir_install}/bin"
	export dir_install_include="${dir_install}/include"
	export dir_install_lib="${dir_install}/lib"
	export dir_install_pc="${dir_install_lib}/pkgconfig"
}

checkForArch(){
	case $1 in
		native)		set_target_build; host_native=true;;

		$aa64 )		set_target '0' 'aarch64' '' 'linux' 'android' '' 'arm64-v8a' '64' $CG3 $CG6;;
		$aa32 )		set_target '1' 'arm' 'v7a' 'linux' 'android' 'eabi' 'armeabi-v7a' '32' $CG2 $CG5;;
		$ax86 )		set_target '2' 'i686' '' 'linux' 'android' '' 'x86' '32' $CG0 $CG1;;
		$ax64 )		set_target '3' 'x86_64' '' 'linux' 'android' '' 'x86_64' '64' $CG0 $CG1;;

		$la64 )		set_target '4' 'aarch64' '' 'linux' 'gnu' '' 'aarch64' '64' $CM4 $CM6;;
		$la32 )		set_target '5' 'arm' '' 'linux' 'gnu' 'eabihf' 'armv7' '32' $CM4 $CM6;;
		$lx86 )		set_target '6' 'i686' '' 'linux' 'gnu' '' 'x86' '32' $CM0 $CM1;;
		$lx64 )		set_target '7' 'x86_64' '' 'linux' 'gnu' '' 'x86_64' '64' $CM0 $CM1;;

		$wa64 )		set_target '8' 'aarch64' '' 'w64' 'mingw32' '' 'arm64' '64' $CC0 $CC1;;
		$wa32 )		set_target '9' 'arm' 'v7' 'w64' 'mingw32' '' 'armv7' '32' $CC0 $CC1;;
		$wx86 )		set_target '10' 'i686' '' 'w64' 'mingw32' '' 'x86' '32' $CB0 $CB1;;
		$wx64 )		set_target '11' 'x86_64' '' 'w64' 'mingw32' '' 'x86_64' '64' $CB0 $CB1;;
	esac
}

usage(){
  printf "\n\n${CW}Usage: ${0} ${CC1}<target> ${CC1}<build-options> ${CB1}<builder-options> ${CM1}<other-options>${C0}\n\n"
  printf "${CC1}target:${CC0}   native|${CC1}[a-android|l-linux|w-windows]${CC2}[a-arm|x-x86]${CC1}[hf-armhf|7-armv7|8-armv8|86-x86|64-x64]\n"
  printf "          ${CC1}eg. aa8, lx64, wa64)\n\n"
  printf "${CC2}build:    --static* --shared | --both\n"
  printf "          --bin*|--no-bin \n\n"
  printf "${CB1}builder:  --api <api> --cmake  --ndkcmake  --ccmake\n"
  printf "          --dist --strip --dirbuild <dir> \n\n"
  printf "${CB1}compiler: --clang*|--gcc --cpus\n"
  printf "          --tune <tune> --mcpu <mcpu> --mtune <mtune> \n\n"
  printf "${CM1}source:   --git --clone --nodev --download|--dl --stable\n"
  printf "          --update --upd-all --refresh --retry --force --clear\n"
  printf "          --patch <add|make|get> --diff --opts\n\n"
  printf "${CM1}control:  --desc --get --list --checkPkg --libName --var <var> \n\n"
  printf "${CM1}other:    --skip --goto \n\n"
  printf "Example targeting android armv8 build shared libs and executable:\n\n\n  ${CW}${0} aa8 --shared --bin --no-strip --no-dist\n\n\n${C0}"
}




# main

test $# -eq 0 && usage && exit 0

aa64='@(aa64|aa8|a*64-*android|android*-a*64|arm*8*android|android*arm*8)'
aa32='@(aa32|aa7|arm-*android*|arm*7*-android*|android*arm*7*)'
ax86='@(a86|ax86|*86-*android|android*86)'
ax64='@(a64|ax64|*64-*android|android*64)'
la64='@(la8|la64|a*64-linux|arm*8*-linux|a*64-linux|a*64-*gnu|arm*8*-*gnu)'
la32='@(la7|lahf|arm*hf|arm-linux*)'
lx86='@(l86|lx86|*86-linux*|linux*32)'
lx64='@(l64|lx64|*64-linux*|linux*64|linux)'
wa64='@(wa8|a*64-w64*|a*64-*mingw*)'
wa32='@(wa7|arm*-w64*|arm*-*mingw*)'
wx86='@(w86|wx86|*86-win*|*86-*mingw*|w*32)'
wx64='@(w64|wx64|*64-win*|*64-*mingw*|windows|win|w*64)'

optVrs='@(--version|--vrs|--ver|-v)'
optDnl='@(--download|--dl|-d)'
optHelp='@(--help|-h)'

while [ $1 ];do
	case $1 in
		
		$optHelp)	showBanner; usage; exit 0;;

		native)		set_target_build; host_native=true;;

		$aa64 )		set_target '0' 'aarch64' '' 'linux' 'android' '' 'arm64-v8a' '64' $CG3 $CG6;;
		$aa32 )		set_target '1' 'arm' 'v7a' 'linux' 'android' 'eabi' 'armeabi-v7a' '32' $CG2 $CG5;;
		$ax86 )		set_target '2' 'i686' '' 'linux' 'android' '' 'x86' '32' $CG0 $CG1;;
		$ax64 )		set_target '3' 'x86_64' '' 'linux' 'android' '' 'x86_64' '64' $CG0 $CG1;;

		$la64 )		set_target '4' 'aarch64' '' 'linux' 'gnu' '' 'aarch64' '64' $CM4 $CM6;;
		$la32 )		set_target '5' 'arm' '' 'linux' 'gnu' 'eabihf' 'armv7' '32' $CM4 $CM6;;
		$lx86 )		set_target '6' 'i686' '' 'linux' 'gnu' '' 'x86' '32' $CM0 $CM1;;
		$lx64 )		set_target '7' 'x86_64' '' 'linux' 'gnu' '' 'x86_64' '64' $CM0 $CM1;;

		$wa64 )		set_target '8' 'aarch64' '' 'w64' 'mingw32' '' 'arm64' '64' $CC0 $CC1;;
		$wa32 )		set_target '9' 'arm' 'v7' 'w64' 'mingw32' '' 'armv7' '32' $CC0 $CC1;;
		$wx86 )		set_target '10' 'i686' '' 'w64' 'mingw32' '' 'x86' '32' $CB0 $CB1;;
		$wx64 )		set_target '11' 'x86_64' '' 'w64' 'mingw32' '' 'x86_64' '64' $CB0 $CB1;;

		--full)    	build_shared=true
					build_static=true
					build_bin=true
					build_dist=true
					dep_build="--full"
					;;

		--break)    shift; set_break $1;;

		$optVrs)	shift; vrs=$1;;

		--bra*)     shift; export bra=$1;;
		--shared)   build_shared=true; build_static=false;;
		--static)   build_static=true; build_shared=false;;
		--both)     build_static=true; build_shared=true;;
		--bin)      build_bin=true;;
		--devel)    src_rel=false;;
		--checkout) git_checkout=true;;
		--no-bin)   build_bin=false;;
		--man)      build_man=true;;
		--dist)     build_dist=true;;
		--cpack)    build_cpack=true;;
		--strip)    build_strip=true;;
		--api)      shift; export API=$1;;
		--clang)    use_clang=true;;
		--gcc)      use_clang=false;;
		--tune)     shift; menu_tune $1;;
		--cpus)     loadToolchain; $CC --print-supported-cpus; exit 0;;
		--mcpu)		shift; export CPPFLAGS+=" -mcpu=${1}";;
		--mtune)	shift; export CPPFLAGS+=" -mtune=${1}";;
		--new)      shift; generate_script $@; exit 0;;

		$optDnl)	build_download=true;;

		--prefix)   shift; dir_install=$1;;
		--stable)   git_stable=true;;
		--diff)     shift; create_diff $@; exit 0;;
		--update)   update=true;;
		--upd-all)  update=true; req_update_deps=true;;
		--opts)     showOpts "$(pwd)/sources/$lib"; exit 0;;
		--checkPkg) checkPkg; exit 0;;
		--libName)  echo "${lib}"; exit 0;;
		--var)      shift; echo "$($1)"; exit 0;;
		--refresh)  update=true;;
		--retry)    retry=true;;
		--force)    [ -f "${dir_install_pc}/${pkg}.pc" ] && rm "${dir_install_pc}/${pkg}.pc" 2>/dev/null;;
		
		--clear)    shift; menu_clear $@; exit 0;;
		--desc )    echo $dsc && exit 0;;
		
		--get)      shift; menu_get $@; exit 0;;
		
		--check)    shift; check_install $@; exit 0;;

		--list)     shift; menu_list $@; exit 0;;

		--patch)    shift;
					case $1 in
						# usage libname.sh --patch a [sources/libname/]path/to/newfile [sources/libname/]path/to/oldfile
						a|add|append)       shift; patch_append $@; exit 0;;
						m|make|e|embed)     shift; patch_embed $1; exit 0;;
						g|get|show)         patch_get; exit 0;;
					esac
					;;

		--skip)     shift; skip_options $@;;

		--goto)     shift; menu_goto $@; exit 0;;

		--git)      shift; menu_git $@; exit 0;;

		--dirbuild) shift; dir_build=$1;;
		--inline)   inline=true;;
		--clone)    only_repo=true;;   
		--cmake)    cfg='cmake';;
		--ndkcmake) ndkcmake=true;;
		--ccmake)   cfg='ccm';;
		--nobanner) banner=false;;
		--nodev)    nodev=true;;
		
		--latest-release) utils_get_latest_release; exit 0;;

		* ) if fn_defined 'extraOpts'; then
				extraOpts $1
			else
				cfg_args+=("${1}")
			fi
			;;
	esac
	shift
done

fn_undef 'extraOpts'

if fn_defined 'compiler_config'; then
	compiler_config
	fn_undef 'compiler_config'
fi

[ -z "${mingw_posix}" ] && mingw_posix=false

# Set default Host

if [ -z "${target_trip}" ];then
	set_target_build
fi

# is cross-compile?
if [ "${build_arch}" == "${arch}" ]; then
	host_cross=false
else
	host_cross=true
fi

loadToolchain

if [ -z "$ISRUNNING" ]; then
	showBanner
	export ISRUNNING=1
fi
if [ -n "${sudo}" ] && ! ${sudo} -n true 2>/dev/null; then
	echo -ne "${CY1}Requesting sudo for tool install " && sudo echo -e "\e[1A\e[2K"
fi

# check build type and set defaults if no cst0 cst1 csh0 or csh1 value provided
case $cfg in
	cm|ccm|cmake|ccmake) build_system=cmake

		[ -n "$cstk" ] && cst0="-D${cstk}=OFF" cst1="-D${cstk}=ON"
		[ -n "$cshk" ] && csh0="-D${cshk}=OFF" csh1="-D${cshk}=ON"
		
		! $build_shared && [ -z "$cst1" ] && cst1="-DBUILD_SHARED_LIBS=OFF"
		[ -z "$csh1" ] && csh1="-DBUILD_SHARED_LIBS=ON"
		
		$build_static && ! $build_shared && CSH="${cst1} ${csh0}"
		$build_shared && ! $build_static && CSH="${csh1} ${cst0}"
		$build_static && $build_shared && CSH="${cst1} ${csh1}"
		
		[ -n "$cbk" ] && cb0="-D${cbk}=OFF" cb1="-D${cbk}=ON"

		;;
	ab|am|ac|ar|ag|auto*) build_system=automake
		[ -z "$cst0" ] && cst0="--disable-static"
		[ -z "$cst1" ] && cst1="--enable-static"
		[ -z "$csh0" ] && csh0="--disable-shared"
		[ -z "$csh1" ] && csh1="--enable-shared"
		$build_static && ! $build_shared && CSH="${cst1} ${csh0}"
		$build_shared && ! $build_static && CSH="${csh1} ${cst0}"
		$build_static && $build_shared && CSH="${cst1} ${csh1}"
		[ -n "$cbk" ] && {
		case $cbk in
			--enable-*) cb0="${cbk}=0"; cb1="${cbk}=1";;
			able-*) cb0="--dis${cbk}"; cb1="--en${cbk}";;
			with-*) cb0="--without-${cbk:5}"; cb1="--${cbk}";;
			*) cb0="--enable-${cbk}=0" cb1="--enable-${cbk}=1";;
		esac
		}
		;;
	meson) build_system=meson
		test -z "${meson_static}" && meson_static="-Ddefault_library=static"
		$build_static && ! $build_shared && CSH="${meson_static}"
		test -z "${meson_shared}" && meson_shared="-Ddefault_library=shared"
		$build_shared && ! $build_static && CSH="${meson_shared}"
		$build_static && $build_shared && CSH="-Ddefault_library=both"
		;;
	mk|make) build_system=make;;
	other) build_system=other;;
	*) unset build_system;;
esac

if [ -z "${CBN}" ];then
	$build_bin && CBN="${cb1}" || CBN="${cb0}"
fi

# reset presets, we don't need them anymore
unset cst0 cst1 csh0 csh1 cb0 cb1 cstk cshk cbk

: "${MAKE_EXECUTABLE:=make}"

export arch update retry \
build_shared build_static build_bin build_system \
dir_install \
CSH CBN LIBSDIR PLATFORM CPU ABI EABI \
host_arch host_64 host_eabi host_vnd host_arm host_os \
mingw_posix MAKE_EXECUTABLE cmake_includes

main
