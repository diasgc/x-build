#!/bin/bash
# ................................................
# X-Build util 0.4.0 2024-diasgc
# ................................................

#set -x

: "${banner:=true}"
: "${config_timeout:=86400}"
: "${debug:=false}"
: "${timeout_days:=3}"

function trap_sigint {
	tput cnorm -- normal
	cd $(dirname $0)
	echo -e "\n\n${CY1}  Interrupted by user${C0}\n  Log available at \e[4m${log_file}\e[24m\n\n"
}

# first load .common functions and error trap
if [ -z ${vsh+x} ];then
	source .common
	source ./utils/.utils
	source ./utils/.cmake
	set -o pipefail
	if [ "${1}" == "--debug" ];then
		shift
		set -x
		debug=true
	fi
	trap err ERR
	[ -f ".config" ] && source .config
	if [ ! -f ".config" ] || test `expr $(date +%s) - ${config_lastupdate}` -gt $((config_timeout * timeout_days)); then
		./x-setup
		source .config || exit_err 'Unable to initialize config file'
	fi
fi
sudo=$(command -v sudo)

export HOST_NPROC=$(nproc)

: "${ac_nohost:=false}"
: "${ac_nosysroot:=false}"
: "${ac_nopic:=false}"
: "${ac_reconf:=true}"

: "${build_allshared:=false}"
: "${build_strip:=false}"
: "${build_dist:=true}"
: "${build_cpack:=false}"
: "${build_download:=false}"
: "${dep_build:=--static}"

: "${def_build_sys:=meson}"
: "${cmake_build_type:=Release}"

: "${src_rel:=true}"
: "${tar_stripcomponents:=false}"
: "${req_update_deps:=false}"
: "${update:=${req_update_deps}}"
: "${git_checkout:=false}"

: "${host_native:=false}"

: "${pkg:=${lib}}"
: "${pkg_deb:=${lib}-dev}"

: "${inline:=false}"
: "${indent:=0}"
: "${ind:=}"
: "${vnd:=}"
: "${is_running:=false}"

pkg_fmt="tgz"


update=false
retry=false

break_on_git=false
break_on_patch=false
break_on_config=false
break_on_build=false
break_on_make=false

skip_pc=false
skip_dl=false

# default build static, no shared, no executables
build_shared=false
build_static=true
build_bin=false
build_man=false
build_package=true

use_clang=true
ndkcmake=false
cmake_toolchain_file=

pc_filelist=

logtime_start=0
logtime_end=0

: "${API:=${ANDROID_NDK_API}}"
: "${NDK_API:=${ANDROID_NDK_API}}"

export CPPFLAGS=
export target_trip=

export dir_sources="${dir_root}/sources" \
       dir_cmake="${dir_root}/cmake" \
       dir_patches="${dir_root}/patches" \
	   dir_pkgdist="${dir_root}/dist" \
	   this_script=${dir_root}/$(basename "$0")

#export dir_src="${dir_sources}/$(bool2str [ -z "${src_dir}" ] ${lib} ${src_dir} )"
if [ -z "${src_dir}" ];then
	export dir_src=${dir_sources}/${lib}
else
	export dir_src=${dir_sources}/${src_dir}
fi

[ -d "${dir_sources}" ] || mkdir -p ${dir_sources}




# Variables
# mki: rule for install 'make $mkinstall' (default: install)
# mkc: rule for clean 'make $mkclean' (default: clean)
# mkf: additional rule for make
# no_host  : while using autotools, no host will be set for cross-compile if no_host is not empty

gitjson=

start(){

	# Should we download the package instead of building it?
	if ${build_download}; then
		local lnk=$(get_link_pkg ${arch} ${lib})
		if [ -n "${lnk}" ]; then
			wget_pkg_tgz ${lnk} ${dir_install}
			${skip_pc} || logver "${dir_install_pc}/${pkg}.pc"
			end_script
			exit 0
		fi
	fi


	# Configure variables
	fn_defined 'on_config' && fn_log '' on_config

	case ${target_trip[3]} in
		android) fn_defined 'on_config_ndk'   && fn_log '' on_config_ndk;;
		gnu)     fn_defined 'on_config_gnu'   && fn_log '' on_config_gnu;;
		mingw32) fn_defined 'on_config_mingw' && fn_log '' on_config_mingw;;
	esac

	if ${host_arm}; then 
		fn_defined 'on_config_arm' && fn_log '' on_config_arm
	else
		fn_defined 'on_config_x86x' && fn_log '' on_config_x86x
	fi

	fn_defined 'on_build_bin' && unset CBN && fn_log '' on_build_bin 
	fn_defined 'on_build_static' && unset CSH && fn_log '' on_build_static
	fn_defined 'on_build_shared' && unset CSH && fn_log '' on_build_shared




	# check whether to update source of main lib and dependencies
	if ${update}; then
		[ -d "${dir_src}" ] && rm -rf "${dir_src}" 2>/dev/null
		! ${req_update_deps} && update=false
	else
		! ${git_checkout} && ! ${retry} && [ -f "${dir_install_pc}/${pkg}.pc" ] && exit
	fi

	# Reset LOGFILE
	[ -f "${log_file}" ] && rm -f ${log_file}

	# Create INSTALL_DIR and PKGCONFIG DIR
	#mkdir -p ${dir_install_pc} ${dir_install}/share/pkgconfig
	#export PKG_CONFIG_LIBDIR="${dir_install_pc}:${dir_install}/share/pkgconfig:${PKG_CONFIG_LIBDIR}"
	#[ ! -d "${dir_install_pc}" ] && mkdir -p ${dir_install_pc}
	#[ ! -d "${dir_install}/share/pkgconfig" ] && mkdir -p ${dir_install}/share/pkgconfig
	
	# check build tools
	check_tools ${tls}

	local ovrs=$vrs
	local ocsh=$CSH
	local ocbn=$CBN
	unset vrs CSH CBN

	build_dependencies ${dep}

	vrs=$ovrs
	CSH=$ocsh
	CBN=$ocbn

	log_start ${arch} "$((${eta}/$(nproc)))s"

	echo -ne "$(bool2str ${build_static} ${SSB} ${CD})[static]"
	echo -ne "$(bool2str ${build_shared} ${SSB} ${CD})[shared]"
	echo -ne "$(bool2str ${build_bin} ${SSB} ${CD})[bin] ${C0}"

	cd ${dir_sources}


	if [ ! ${retry} ]; then
		if [ "${dir_build}" != "${dir_src}" ] && [[ "${dir_build}" != "${dir_config}" ]]; then
			rm -rf ${dir_build}
		fi
	fi

	local require_src_config=false
	local require_src_patch=false

	# get source
	if [ ! -d ${dir_src} ];then
		
		get_source
		require_src_config=true
		${break_on_git} && end_script

		test "${cfg}" == "cmake" && cmake_check_cmakefiles

		if fn_defined 'patch_source'; then
			fn_log 'patch' patch_source
		elif [ -n "${patch[@]}" ]; then
			fn_log '' patch_check_patchdir
		fi
	fi

	cd "${dir_src}"

	if [ -n "${bra}" ]; then
		do_log "${bra}" git checkout ${bra}
	elif $git_checkout; then
		do_log 'checkout' git checkout
		unset git_checkout
	fi

	#case $src in *git*) echo -ne "${CT0}[$(git describe --tags 2>/dev/null)]${CD} ";; esac
	
	# default dir_config is dir_src
	: "${dir_config:=${dir_src}}"
	# check if defined custom dir_config location (config_dir)
	[ -n "${config_dir+x}" ] && dir_config="${dir_src}/${config_dir}"

	cd ${dir_config}

	# if there is no config selected, try guess
	test -z "${cfg}" && config_guess
	
	if ${require_src_config}; then	
		# check whether to custom config source
		if fn_defined 'source_config'; then
			fn_log 'config' source_config
		elif [ -n "${cfg_cmd}" ];then
			do_log 'config' ${cfg_cmd}
			unset cfg_cmd
		else case ${cfg} in
			ab)		[ -f "${dir_config}/boostrap" ] && do_log 'bootstrap' ${dir_config}/boostrap
					[ -f "${dir_config}/boostrap.sh" ] && do_log 'bootstrap' ${dir_config}/boostrap.sh
					;;
			ag) 	do_am_autogen ${dir_config} --noconfigure;;
			ar) 	do_am_autoreconf ${dir_config};;
			am)		if [ ! -f "${dir_config}/configure" ];then
						if [ -f "${dir_config}/autogen.sh" ];then
							do_am_autogen ${dir_config} --noconfigure
						else
							do_am_autoreconf ${dir_config}
						fi
					fi
					;;
			esac
		fi
		require_src_patch=true
	fi

	if ${require_src_patch}; then
		# check if has patch function in source
		fn_defined 'source_patch' && fn_log 'patch' source_patch
		if [ -n "${cmake_file}" ] && [ -f "${dir_root}/cmake/${cmake_file}" ]; then
			cp -f "${dir_root}/cmake/${cmake_file}" "${dir_src}/CMakeLists.txt" || exit_err "Unable to copy ${fcmake} to ${fcmake_dst}"
			unset cmake_file
		fi
		#local fcmake="${dir_root}/cmake/${cmake_file}"
		#if [ -f "${fcmake}" ]; then
		#	local fcmake_dst="${dir_src}/CMakeLists.txt"
		#	cp -f "${fcmake}" "${fcmake_dst}" || exit_err "Unable to copy ${fcmake} to ${fcmake_dst}"
		#	unset cmake_file
		#fi
	fi

	${break_on_patch} && end_script

	if [ -z "${dir_build}" ];then
		case ${build_system} in
			cmake|meson|automake) dir_build="${dir_config}/build_${arch}"
				[ -d "${dir_build}" ] && rm -rf ${dir_build} 2>/dev/null
				;;
			*) dir_build=${dir_config};;
		esac
	fi

	[ -d "${dir_build}" ] || mkdir -p "${dir_build}"
	
	cd ${dir_build}

	log_vars dir_src dep PKG_CONFIG_LIBDIR
	log_vars API CC CXX LD AS AR NM RANLIB STRIP

	if fn_defined 'build_all'; then
		fn_log 'build' build_all
		end_script
	fi

	if fn_defined 'build_prepare'; then
		fn_log 'prepare' build_prepare
	fi

	if fn_defined 'build_clean'; then
		fn_log 'clean' build_clean
	elif [ -f "Makefile" ]; then
		mkc=$(make_findtarget "distclean" "clean")
		[ -n "${mkc}" ] && do_quietly 'clean' ${MAKE_EXECUTABLE} $mkc
	fi

	local arr
	if fn_defined 'build_config'; then
		fn_log 'config' build_config
		unset -f build_config
	else case "${build_system}" in
		cmake)
			cmake_configure
			cfg_cmd=${CMAKE_EXECUTABLE}
			: "${cmake_bdir:=${dir_config}}"
			cfg_args+=("${cmake_bdir}" "-DCMAKE_INSTALL_PREFIX=${dir_install}" "-DCMAKE_BUILD_TYPE=${cmake_build_type}" "${CTC}" "${CFG}" "${CSH}" "${CBN}" "${CPACK}" -Wno-dev)
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			case $cfg in ccm|ccmake) tput sc; ccmake ..; tput rc;; esac
			;;

		automake) # use autotools and configure executable to create makefile
			ac_configure
			cfg_cmd="${dir_config}/configure"
			cfg_args+=("--prefix=${dir_install}" "${CFG}" "${CSH}" "${CBN}")
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			;;

		meson)
			meson_configure
			cfg_cmd='meson'
			cfg_args+=('setup' '--buildtype=release' "--cross-file=${cfg_file}" "--prefix=${dir_install}" "${CFG}" "${CSH}" "${CBN}")
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			#do_log 'meson' meson setup --buildtype=release --cross-file=${cfg_file} --prefix=${dir_install} ${CFG} ${CSH} ${CBN}
			;;

		make)
			: "${mkf:=$CFG}"
			MAKE_EXECUTABLE=make
			;;
		bazel)
			cfg_cmd='bazel'
			do_log "${build_system}" "${cfg_cmd}" "${cfg_args[@]}"
			;;
		*)	if [ -n "${cfg_cmd}" ]; then
				do_log 'config' ${cfg_cmd} ${cfg_args[@]}
			else
				exit_err "cfg ${cfg} unknown or cfg_cmd not defined. Use build_config to custom configure makefile"
			fi
			;;
		esac
	fi

	${break_on_config} && end_script

	if fn_defined 'before_make'; then
		fn_log 'preparing' before_make
	fi

	[ -n "${WFLAGS}" ] && CPPFLAGS+=" ${WFLAGS}"

	if [ -z "${static_ldflag}" ];then
		static_ldflag='-static'
		# set -all-static flags at make time (see: https://stackoverflow.com/questions/20068947/how-to-static-link-linux-software-that-uses-configure)
		# $build_static && [[ "$LDFLAGS" != *"-all-static"* ]] && LDFLAGS="-all-static $LDFLAGS"
		$host_clang && static_ldflag="-all${static_ldflag}"
	fi

	$host_clang && $build_static && LDFLAGS="-static $LDFLAGS"

	log_vars CFLAGS CXXFLAGS WFLAGS CPPFLAGS LDFLAGS LIBS

	[ -z "${mki}" ] && mki="install"
	: "${skip_make:=false}"

	if fn_defined 'on_make'; then
		fn_log 'make' on_make
	elif ! $skip_make; then
		do_progress 'make' "${MAKE_EXECUTABLE}" ${mkf} -j${HOST_NPROC} || err
		unset skip_make
	fi

	${break_on_make} && end_script
	


	if fn_defined 'before_install'; then
		fn_log 'preparing' before_install
	fi

	# strip libs
	if ! ${host_mingw}; then
		if fn_defined 'on_strip'; then
			fn_log 'strip' on_strip
		elif ${build_strip}; then
			do_log 'strip' doStrip
		fi
	fi

	if fn_defined 'on_install'; then
		fn_log 'install' on_install
	else
		cd "${dir_build}"
		do_log 'install' "${MAKE_EXECUTABLE}" ${mki}
	fi

	# check whether to create pkg-config .pc file
	if ! ${skip_pc}; then
		fn_defined 'get_version' && vrs="$(get_version)"
		
		if fn_defined 'on_create_pc'; then
			fn_log 'pkgconfig' on_create_pc
		elif [ -n "$pc_llib" ]; then
			do_log 'pkgconfig' create_pkgconfig_file $pkg $pc_llib
		elif [ -n "${pc_llibs}" ]; then
			local p
			for f in ${pc_llibs}; do
				[ "${f::2}" == "-l" ] && p="${f:2}" || p="$f"
				create_pkgconfig_file $p $f
			done
		fi
	fi

	local pcfile=${dir_install_pc}/${pkg}.pc

	if [ ! -f "${pcfile}" ] && [ -f "${dir_install}/share/pkgconfig/${lib}.pc" ]; then
		pcfile="${dir_install}/share/pkgconfig/${lib}.pc"
	fi

	if ${build_cpack}; then
		if [ -z "${CPACK}" ]; then
			if fn_defined 'on_pack'; then
				fn_log 'pack' on_pack
			elif $build_package; then
				if [ -f "${dir_build}/install_manifest.txt" ]; then
					do_log 'cpack' cmake_build_package
				else
					do_log 'pack' build_packages_bin
				fi
			fi
		else
			cd "${dir_build}"
			vrs="$(pkg-config ${pcfile} --modversion)"
			do_log 'cpack' cpack -G DEB -P "${lib}_${vrs}_${arch}"
		fi
	fi

	cd ${dir_src}

	${skip_pc} || logver "${pcfile}"

	fn_defined 'on_end' && fn_log '' on_end

	vrs=$(pkg-config --modversion ${pcfile})
	test -n "${vrs}" && sed -i "s/dev_vrs='.*'/dev_vrs='"${vrs}"'/g" ${this_script}

	end_script
}	

# see https://mesonbuild.com/Commands.html for command line options
meson_configure(){
	export cfg_file="${dir_config}/${arch}.meson"
	test -f "${cfg_file}"  && rm ${cfg_file}
	${host_clang} || LD="bfd"
	if [ -n "${meson_bin}" ]; then
		arr=(${meson_bin//|/ })
		case ${#arr[@]} in
			1) CBN="-D${arr[0]}=$(bool2str ${build_bin} true false)";;
			2) CBN="-D$(bool2str ${build_bin} ${arr[1]} ${arr[0]})";;
		esac
	fi
	meson_create_toolchain ${cfg_file}
	MAKE_EXECUTABLE=ninja
	$build_static && meson_cfg+=' --prefer-static'
	[ -n "${meson_cfg}" ] && CFG="${meson_cfg} ${CFG}"
}

ac_configure() {
	$ac_reconf && autoreconf -fi 2>/dev/null >>${log_file}
	#[ -z "${mki+x}" ] && mki=$(make_findtarget "install-strip" "install")
	[ -z "$exec_config" ] && exec_config='configure' # default config executable
	[ -n "${ac_config}" ] && CFG=${ac_config}

	local opt_list="$(${dir_config}/${exec_config} --help | grep -P '^[[:space:]]+\-\-')"

	# find static build option
	if $build_static && [ -n "$(echo "${opt_list}" | grep '\-\-enable-static')" ]; then
		build_type="--enable-static"
	fi
	# find shared build option
	if $build_shared && [ -n "$(echo "${opt_list}" | grep '\-\-enable-shared')" ]; then
		build_type+=" --enable-shared"
	fi

	if [ -n "${ac_bin}" ]; then
		arr=(${ac_bin//|/ })
		case ${#arr[@]} in
			1) CBN=$(bool2str ${build_bin} "${arr[0]}=1" "${arr[0]}=0");;
			2) CBN=$(bool2str ${build_bin} "${arr[1]}" "${arr[0]}");;
		esac
	fi

	if [ -n "${ac_opts}" ]; then
		for opt in $(echo ${ac_opts}); do
			case $opt in
				--update-config_sub)
					local fpath=$(find ${dir_src} -name 'config.sub')
					test -f "${fpath}" && cp -f /usr/share/automake*/config.sub ${fpath}
					;;
				--update-config_guess)
					local fpath=$(find ${dir_src} -name 'config.guess')
					test -f "${fpath}" && cp -f /usr/share/automake*/config.guess ${fpath}
					;;
				--no-sysroot)
					ac_nosysroot=true
					;;
				--no-pic)
					ac_nopic=true
					;;
				--no-host)
					ac_nohost=true
					;;
			esac
		done
	fi

	if ! $ac_nohost && $host_cross && [ -n "$(echo "${opt_list}" | grep '\-\-host')" ]; then
		$host_cross && CFG+=" --host=${arch}"
	fi

	if ! $ac_nosysroot; then
		if [ -n "$(echo "${opt_list}" | grep '\-\-with-sysroot')" ]; then
			CFG+=" --with-sysroot=${SYSROOT}"
		elif [ -n "$(echo "${opt_list}" | grep '\-\-sysroot')" ]; then
			CFG+=" --sysroot=${SYSROOT}"
		fi
	fi

	if ! $ac_nopic && ! $host_mingw && [ -n "$(echo "${opt_list}" | grep '\-\-with-pic')" ]; then
		CFG+=" --with-pic"
	fi
	MAKE_EXECUTABLE=make
}

doStrip(){
	local libdir
	for dd in $(find ${dir_build} \( -name "*.a" -o -name "*.so" \));do
		${STRIP} --strip-unneeded $dd
	done
}

end_script(){
	log_end
	sed -i "s/eta='.*'/eta='"${eta}"'/g" ${this_script}
	# check if parent process is shell script
	local parent=$(ps -o comm= ${PPID})
	[ "${parent: -3}" == ".sh" ] || echo -e "\n${CT1}::Done ${C0}${lib} ${vrs}\n"
	${debug} && set +x
	unset	dir_config dir_build dir_src \
			CSH CBN exec_config vrs vnd \
			ac_nohost ac_nopic ac_nosysroot ac_opts ac_reconf \
			req_pcforlibs mkc mki mingw_posix \
			cfg_args LIBS CFLAGS CXXFLAGS LDFLAGS WFLAGS
	dec_tab
	echo -e "${C0}${ind}"
	exit 0
}

make_findtarget(){
	${MAKE_EXECUTABLE} ${1} -n 2>>${log_file}
	if test $? -eq 2 ; then
		echo "${2}"; echo "make: target ${1} not found, setting default ${2} target." >>${log_file}
	else
		echo "${1}"; echo "make: target ${1} found." >>${log_file}
	fi
}

check_install(){
	local ext=''
	case "${1}" in
		# check includes
		inc*)
			for h in $lst_inc; do 
				test -z "$(ls ${dir_install}/include/$h 2>/dev/null)" && echo && return 0
			done
			echo 1
			return 0
			;;
		# check libs
		static*) ext='\.a';;
		shared*) $host_mingw && ext='\.dll*' || ext='\.so*';;
		lib*) ext='.*';;
		# check bin
		bin)
			for h in $lst_bin; do 
				test -z "$(ls "${dir_install}/bin/${h}" 2>/dev/null)" && echo && return 0
			done
			echo 1
			return 0
			;;
		# check pkgconfig
		pc|pkgconfig)
			[ -z "${lst_pc}" ] && echo && return 0
			for h in ${lst_pc}; do 
				test -z "$(ls "${dir_install}/lib/pkgconfig/${h}" 2>/dev/null)" && echo && return 0
			done
			echo 1
			return 0
			;;
	esac
	if [ -n "${ext}" ];then
		for h in $lst_lib; do
		echo "listing ${dir_install}/lib/${h}${ext}"
		test -z "$(ls ${dir_install}/lib/${h}.* | grep ''${ext}'' 2>/dev/null)" && echo && return 0
		done
		echo 1
		return 0
	fi
	echo
	return 0
}


function build_dependencies {
	local dep_args="${arch} ${dep_build} $(bool2str ${build_allshared} --shared --static) $(bool2str ${build_download} '--dl' '')"
	local pkgfile libname old_csh old_csb
	while [ -n "${1}" ]; do
		test -f "./${1}.sh" || exit_err "Fail to build dependency ${1}. Script file not found."
		pkgfile=$(./${1}.sh ${arch} --get pc)
		if [ ! -f "${pkgfile}" ]; then
			old_csh=${CSH}; old_csb=${CSB}
			unset CSH CSB

			./${1}.sh ${dep_args}
			
			CSH=${old_csh}; CSB=${old_csb}
		else
			log_info "${1}: ${C0} version $(pkg-config --modversion ${pkgfile})"
		fi
		shift
	done
}

build_dependencies_old(){
	local pkgfile
	local o_csh
	local o_cbh
	local cf
	local ldir
	while [ -n "${1}" ]; do
		[ -f "./${1}.sh" ] || exit_err "no script file ${1}.sh.\n  Aborting..."
		pkgfile=$(./${1}.sh ${arch} --get pc)
		libname=$(./${1}.sh --get libname)
		if [ ! -f "${pkgfile}" ]; then
			o_csh=$CSH
			o_cbh=$CBH
			${build_download} && local dl="--dl" || local dl=''
			unset CSH CBH
			
			./${1}.sh ${arch} ${dep_build} ${dl}
			
			CSH=$o_csh
			CBH=$o_cbh
		fi
		if [ -f "${pkgfile}" ]; then
			local cmi=$(./${1}.sh ${arch} --get cmake_include)
			[ -n "$cmi" ] && cmake_includes="$cmi $cmake_includes"
			ldir="$(dirname ${pkgfile})"
			str_contains $PKG_CONFIG_LIBDIR ${ldir} || PKG_CONFIG_LIBDIR="${ldir}:${PKG_CONFIG_LIBDIR}"
		fi
		shift
	done
}


#usage: meson_create_toolchain <out.meson.file>
meson_create_toolchain(){
	case $arch in
		aarch*)  cpu1="aarch64" cpu2="aarch64";;
		arm*)    cpu1="arm"     cpu2="arm";;
		i686*)   cpu1="x86"     cpu2="i686";;
		x86_64*) cpu1="x86_64"  cpu2="x86_64";;
	esac
	cmake_create_toolchain ${dir_build}

	cat <<-EOF >${1}
		[binaries]
		c = '${CC}'
		c_ld = '${LD}'
		cpp = '${CXX}'
		cpp_ld = '${LD}'
		ar = '${AR}'
		as = '${AS}'
		pkg-config = '$(command -v pkg-config)'
		addr2line = '${ADDR2LINE}'
		objcopy = '${OBJCOPY}'
		objdump = '${OBJDUMP}'
		ranlib = '${RANLIB}'
		readelf = '${READELF}'
		size = '${SIZE}'
		strings = '${STRINGS}'
		strip = '${STRIP}'
		windres = '${WINDRES}'

		[properties]
		needs_exe_wrapper = true
		cmake_toolchain_file = '${cmake_toolchain_file}'

		[host_machine]
		system = '$(str_lowercase ${PLATFORM})'
		cpu_family = '${cpu1}'
		endian = 'little'
		cpu = '${cpu2}'

		[target_machine]
		system = '$(str_lowercase ${PLATFORM})'
		cpu_family = '${cpu1}'
		endian = 'little'
		cpu = '${cpu2}'
		EOF

	echo -e "\nMeson file:(${1})\n\n" >>${log_file} 2>&1
	cat ${1} >>${log_file} 2>&1
}

# usage cmake_create_toolchain <dir>
cmake_create_toolchain(){
	cmake_build_toolchainfile
}

cargo_create_toolchain(){
cat <<-EOF >>cargo-config.toml
	[target.aarch64-linux-android]
	ar = "/usr/aarch64-linux-android/bin/llvm-ar"
	linker = "/usr/aarch64-linux-android/bin/clang"

	[target.arm-linux-androideabi]
	ar = "/usr/arm-linux-androideabi/bin/llvm-ar"
	linker = "/usr/arm-linux-androideabi/bin/clang"

	[target.i686-linux-android]
	ar = "/usr/i686-linux-android/bin/llvm-ar"
	linker = "/usr/i686-linux-android/bin/clang"

	[target.x86_64-linux-android]
	ar = "/usr/x86_64-linux-android/bin/llvm-ar"
	linker = "/usr/x86_64-linux-android/bin/clang"
	EOF
}

wget_pkg_tgz(){
	local tag="$(basename ${1})"
	tag="pkg: ${tag//_${arch}.tag.gz/}"
	printf "${CD}%s${C0}" ${tag}
	printf "\n\n$(date): wget/untar %-50s to %s" $1 $2 >>${log_file}
	wget -qO- ${1} 2>>${log_file} | tar --transform 's/^dbt2-0.37.50.3/dbt2/' -xvz -C ${2} >>${log_file} 2>&1 || err
	echo -e "\n\n" >>${log_file}
	logok $tag
}

clean(){
	echo -ne "${CT0}\n\tcleaning...\n"
	rm -rf builds/$arch/$lib builds/$arch/$lib.log
	pushdir sources/$lib
	[ -f Makefile ] && make clean
	popdir
	echo -e "$C0\tdone"
	clear
}



showOpts(){
	if [ -d "$1" ];then
		local od=$(pwd)
		local bdir=$(pwd)/builds
		cd "${1}/${config_dir}"
		[ -f CMakeLists.txt ] && ${CMAKE_EXECUTABLE} -LA | awk '{if(f)print} /-- Cache values/{f=1}' >${od}/builds/${lib}_cmake.opts && nano "${od}/builds/${lib}_cmake.opts"
		[ -f configure ] && ./configure --help >${od}/builds/${lib}_aconf.opts && nano "${od}/builds/${lib}_am.opts"
		cd $od
	else
		echo -e "${CD}${ind}${CR0}no configuration file found in ${CR1}${1}${CD}\n\n"
	fi
}

function do_am_autoreconf {
	local tag='autoreconf'
	echo -ne "${CD}${tag}${C0}"
	pushdir ${1}
	log_this autoreconf -fiv
	popdir
	logok ${tag}
}

function do_am_autogen {
	local tag='autoreconf'
	echo -ne "${CD}${tag}${C0}"
	pushdir ${1} && shift
	case ${1} in
		--noerr ) ./autogen.sh >>${log_file} 2>&1;;
		--noconfigure ) NOCONFIGURE=1 log_this ./autogen.sh;;
		* ) log_this ./autogen.sh;;
	esac
	popdir
	logok ${tag}
}

toolchain_android(){
	PLATFORM='Android'
	[ -d "${ANDROID_NDK_HOME}" ] || exit_err "No ANDROID NDK Toolchain found. Aborting."

	TOOLCHAIN="/usr/${arch}"
	SYSROOT="${TOOLCHAIN}/sysroot"
	CROSS_PREFIX="${TOOLCHAIN}/bin/"

	CC="${CROSS_PREFIX}clang"
	CXX="${CROSS_PREFIX}clang++"
	AS="${CC}"
	LD="${CROSS_PREFIX}ld"
	YASM=${CROSS_PREFIX}yasm
	ASM_NASM=${YASM}

	CMAKE_TOOLCHAIN="${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake"
	LT_SYS_LIBRARY_PATH="${TOOLCHAIN}/lib:${SYSROOT}/usr/lib/${arch}:${SYSROOT}/usr/lib/${arch}/${NDK_API}"
	PKG_CONFIG_DIR="/usr/${arch}/local/lib/pkgconfig"
	CPPFLAGS+=" -I${SYSROOT}/usr/include -I/usr/${arch}/include -I${SYSROOT}/usr/include"
	LDFLAGS="-Wl,-rpath,${LT_SYS_LIBRARY_PATH} ${LDFLAGS}"
	#test $build_static && LDFLAGS+=" -static-libstdc++ -lc++_static"

	cmake_system_processor="${target_trip[0]}${target_trip[1]}"
	$host_arm32 && cmake_system_processor="armv7-a"
	cmake_findrootpath="/usr/${arch} /usr/${arch}/lib /usr/${arch}/lib/${API} /usr/${arch}/sysroot/usr ${dir_install}"
	export NDK_API=${API}
}

toolchain_llvm_mingw(){
	local ltsdir
	local cargs=
	PLATFORM='Windows'

	SYSROOT="/usr/${arch}"
	TOOLCHAIN="${SYSROOT}/bin/"
	CROSS_PREFIX="${LLVM_MINGW_HOME}/bin/${arch}-"
	if $use_clang; then
		CC="${CROSS_PREFIX}clang"
		CXX="${CROSS_PREFIX}clang++"
		AS="${CC}"
		LD="${CROSS_PREFIX}ld"
	else
		CC="${CROSS_PREFIX}gcc"
		CXX="${CROSS_PREFIX}g++"
		AS="${CROSS_PREFIX}as"
		LD="${CROSS_PREFIX}ld"
	fi
	export RC=${CROSS_PREFIX}windres
	LT_SYS_LIBRARY_PATH="${LLVM_MINGW_HOME}/lib/clang/${xv_llvm_mingw}"
	CPPFLAGS+=" -I${SYSROOT}/include"
	LDFLAGS="-L${LT_SYS_LIBRARY_PATH}/lib -L${SYSROOT}/lib ${LDFLAGS}"
	YASM=yasm
	NASM=nasm
	ASM_NASM=${NASM}
	cmake_findrootpath="${SYSROOT} ${LT_SYS_LIBRARY_PATH} ${dir_install}"

}

toolchain_linux(){
	$host_cross && cross="-cross"
	ltsdir=$(gcc -dumpversion)
	if $use_clang; then
		SYSROOT="/usr/${arch}"
		TOOLCHAIN="${SYSROOT}/bin"
		CROSS_PREFIX="llvm-"
		CC="${TOOLCHAIN}/clang"     
		#CC="clang -target ${arch}" # -fuse-ld=lld"
		CXX="${TOOLCHAIN}/clang++"  
		#CXX="clang++ -target ${arch}" # -fuse-ld=lld"++
		AS="${CC}"
		LD="${TOOLCHAIN}/ld.lld" # --sysroot=${SYSROOT}"+
		#$build_static && LDFLAGS+=" -static"
		GNU_CLANG_VERSION_FULL="$(clang -dumpversion)"
		GNU_CLANG_VERSION_MAJOR=${GNU_CLANG_VERSION_FULL%%\.*}
		CPPFLAGS="-I$/usr/lib/clang/${GNU_CLANG_VERSION_MAJOR}/include ${CPPFLAGS}"
		LT_SYS_LIBRARY_PATH="/usr/lib/llvm-${GNU_CLANG_VERSION_MAJOR}/lib"
	else
		SYSROOT="/usr/${arch}"
		TOOLCHAIN="/usr/bin"
		CROSS_PREFIX="${TOOLCHAIN}/${arch}-"
		CC="${CROSS_PREFIX}gcc"
		CXX="${CROSS_PREFIX}g++"
		AS="${CROSS_PREFIX}as"
		LD="${CROSS_PREFIX}ld"
		LT_SYS_LIBRARY_PATH="/usr/lib/gcc${cross}/${arch}/${ltsdir}"
	fi
	ASM_NASM=nasm
	LDFLAGS="-L${SYSROOT}/lib -L${LT_SYS_LIBRARY_PATH} ${LDFLAGS}"
	CPPFLAGS=" -I${SYSROOT}/include -I${SYSROOT}/local/include ${CPPFLAGS}"
	cmake_findrootpath="${SYSROOT} ${LT_SYS_LIBRARY_PATH} ${dir_install}"
}

loadToolchain(){

	CMAKE_EXECUTABLE=cmake
	YASM=yasm
	PKG_CONFIG=pkg-config

	#reset flags

	CPPFLAGS+=" -I${dir_install_include}"
	LDFLAGS="-L${dir_install_lib}"
	cmake_system_processor="${target_trip[0]}${target_trip[1]}"

	if $host_cross; then
		case $PLATFORM in
			Android) toolchain_android;;
			Windows) toolchain_llvm_mingw;;
			Linux)   toolchain_linux;;
		esac
	else
		TOOLCHAIN=/usr/bin
		SYSROOT=/usr
		if ${use_clang}; then
			CROSS_PREFIX=llvm-
			CC=clang CXX=clang++ AS=${CC} LD=ld.lld
			$host_native && CPPFLAGS="-mtune=native ${CPPFLAGS}"
		else
			CROSS_PREFIX=
			CC=gcc CXX=g++ AS=as LD=ld
			$host_native && CPPFLAGS="-march=native ${CPPFLAGS}"
		fi
		ASM_NASM=nasm
	fi

	AR=${CROSS_PREFIX}ar
	NM=${CROSS_PREFIX}nm
	
	ADDR2LINE=${CROSS_PREFIX}addr2line
	OBJCOPY=${CROSS_PREFIX}objcopy
	OBJDUMP=${CROSS_PREFIX}objdump
	RANLIB=${CROSS_PREFIX}ranlib
	READELF=${CROSS_PREFIX}readelf
	SIZE=${CROSS_PREFIX}size
	STRINGS=${CROSS_PREFIX}strings
	STRIP=${CROSS_PREFIX}strip
	WINDRES=${CROSS_PREFIX}windres
	[ -z ${GCOV+x} ] && GCOV=${CROSS_PREFIX}gcov

	# export
	export CMAKE_EXECUTABLE YASM PKG_CONFIG API \
		PLATFORM TOOLCHAIN SYSROOT CC CXX LD AS \
		ADDR2LINE AR NM OBJCOPY OBJDUMP RANLIB \
		READELF SIZE STRINGS STRIP WINDRES \
		CROSS_PREFIX LT_SYS_LIBRARY_PATH CPPFLAGS LDFLAGS
}

set_target(){
	cpu_id="${1}"
	target_trip=("${2}" "${3}" "${4}" "${5}" "${6}" "${7}" "${8}")
	arch="${2}-${4}-${5}${6}"
	CT0="${9}"
	CT1="${10}"
	CPU=${2}
	ABI=${7}
	EABI=${6}
	set_env
}

set_target_build(){
	target_trip[5]=$(uname -m)
	arch="${target_trip[5]}-${OSTYPE}"
	target_trip[0]=${target_trip[5]}
	if [ "${target_triple[0]::3}" == "arm" ]; then
		target_trip[1]="${target_triple[0]:3}"
		target_trip[0]="${target_triple[0]::3}"
	fi
	arr=(${OSTYPE//-/ })
	target_trip[2]=${arr[0]}
	target_trip[3]=${arr[1]}
	if [ -z "${target_trip[3]##*eabi*}" ] ;then
		local a2=${target_trip[3]%eabi*}
		target_trip[4]=${target_trip[3]#${a2}*}
		target_trip[3]=${a2}
	fi
	set_env
	STRIP=strip
}

set_env(){
	case ${target_trip[0]} in
		aarch64) host_arm=true;  host_arm32=false; host_arm64=true;  host_x86=false; host_x64=false; host_bits=64;;
		arm)     host_arm=true;  host_arm32=true;  host_arm64=true;  host_x86=false; host_x64=false; host_bits=32;;
		i686)    host_arm=false; host_arm32=false; host_arm64=false; host_x86=true;  host_x64=false; host_bits=32;;
		x86_64)  host_arm=false; host_arm32=false; host_arm64=false; host_x86=false; host_x64=true; host_bits=64;;
	esac
	case ${target_trip[3]} in
		android) host_sys=linux;   host_mingw=false; host_os=android; host_ndk=true;	host_gnu=false;	host_clang=true;  PLATFORM="Android"
		         dir_install="/usr/${arch}/local"
		         ;;
		gnu)     host_sys=linux;   host_mingw=false; host_os=gnu;     host_ndk=false;	host_gnu=true;	host_clang=false; PLATFORM="Linux"
		         dir_install="${dir_root}/builds/${PLATFORM,,}/${target_trip[5]}"
		         ;;
		mingw32) host_sys=windows; host_mingw=true;  host_os=mingw32; host_ndk=false;	host_gnu=false;	host_clang=true;  PLATFORM="Windows"
		         dir_install="${dir_root}/builds/${PLATFORM,,}/${target_trip[5]}"
		         ;;
	esac
	#LIBSDIR="$(pwd)/builds/${PLATFORM,,}/${target_trip[5]}"
	[ ! -d "${dir_install}" ] && mkdir -p "${dir_install}"
	export dir_install
	export dir_install_bin="${dir_install}/bin"
	export dir_install_include="${dir_install}/include"
	export dir_install_lib="${dir_install}/lib"
	export dir_install_pc="${dir_install_lib}/pkgconfig"
	export PKG_CONFIG_LIBDIR="${dir_install_pc}:${dir_install}/share/pkgconfig:${PKG_CONFIG_LIBDIR}"
	export PKG_CONFIG_PATH=
}

usage(){
  printf "\n\n${CW}Usage: ${0} ${CC1}<target> ${CC1}<build-options> ${CB1}<builder-options> ${CM1}<other-options>${C0}\n\n"
  printf "${CC1}target:${CC0}   native|${CC1}[a-android|l-linux|w-windows]${CC2}[a-arm|x-x86]${CC1}[hf-armhf|7-armv7|8-armv8|86-x86|64-x64]\n"
  printf "          ${CC1}eg. aa8, lx64, wa64)\n\n"
  printf "${CC2}build:    --static* --shared | --both\n"
  printf "          --bin*|--no-bin \n\n"
  printf "${CB1}builder:  --api <api> --cmake  --ndkcmake  --ccmake\n"
  printf "          --dist --strip --dirbuild <dir> \n\n"
  printf "${CB1}compiler: --clang*|--gcc --cpus\n"
  printf "          --tune <tune> --mcpu <mcpu> --mtune <mtune> \n\n"
  printf "          --update --upd-all --refresh --retry --force --clear\n"
  printf "          --patch <add|make|get> --diff --opts\n\n"
  printf "${CM1}control:  --desc --get --list --checkPkg --libName --var <var> \n\n"
  printf "${CM1}other:    --skip --goto \n\n"
  printf "Example targeting android armv8 build shared libs and executable:\n\n\n  ${CW}${0} aa8 --shared --bin --no-strip --no-dist\n\n\n${C0}"
}




# main

test $# -eq 0 && usage && exit 0

aa64='@(aa64|aa8|a*64-*android|android*-a*64|arm*8*android|android*arm*8)'
aa32='@(aa32|aa7|arm-*android*|arm*7*-android*|android*arm*7*)'
ax86='@(a86|ax86|*86-*android|android*86)'
ax64='@(a64|ax64|*64-*android|android*64)'
la64='@(la8|la64|a*64-linux|arm*8*-linux|a*64-linux|a*64-*gnu|arm*8*-*gnu)'
la32='@(la7|lahf|arm*hf|arm-linux*)'
lx86='@(l86|lx86|*86-linux*|linux*32)'
lx64='@(l64|lx64|*64-linux*|linux*64|linux)'
wa64='@(wa8|a*64-w64*|a*64-*mingw*)'
wa32='@(wa7|arm*-w64*|arm*-*mingw*)'
wx86='@(w86|wx86|*86-win*|*86-*mingw*|w*32)'
wx64='@(w64|wx64|*64-win*|*64-*mingw*|windows|win|w*64)'

optVrs='@(--version|--vrs|--ver|-v)'
optDnl='@(--download|--dl|-d)'
optHelp='@(--help|-h)'

while [ $1 ];do
	case $1 in
		
		$optHelp)	show_banner; usage; exit 0;;

		native)		set_target_build; host_native=true;;

		$aa64 )		set_target '0' 'aarch64' '' 'linux' 'android' '' 'arm64-v8a' '64' $CG3 $CG6;;
		$aa32 )		set_target '1' 'arm' 'v7a' 'linux' 'android' 'eabi' 'armeabi-v7a' '32' $CG2 $CG5;;
		$ax86 )		set_target '2' 'i686' '' 'linux' 'android' '' 'x86' '32' $CG0 $CG1;;
		$ax64 )		set_target '3' 'x86_64' '' 'linux' 'android' '' 'x86_64' '64' $CG0 $CG1;;

		$la64 )		set_target '4' 'aarch64' '' 'linux' 'gnu' '' 'aarch64' '64' $CM4 $CM6;;
		$la32 )		set_target '5' 'arm' '' 'linux' 'gnu' 'eabihf' 'armv7' '32' $CM4 $CM6;;
		$lx86 )		set_target '6' 'i686' '' 'linux' 'gnu' '' 'x86' '32' $CM0 $CM1;;
		$lx64 )		set_target '7' 'x86_64' '' 'linux' 'gnu' '' 'x86_64' '64' $CM0 $CM1;;

		$wa64 )		set_target '8' 'aarch64' '' 'w64' 'mingw32' '' 'arm64' '64' $CC0 $CC1;;
		$wa32 )		set_target '9' 'arm' 'v7' 'w64' 'mingw32' '' 'armv7' '32' $CC0 $CC1;;
		$wx86 )		set_target '10' 'i686' '' 'w64' 'mingw32' '' 'x86' '32' $CB0 $CB1;;
		$wx64 )		set_target '11' 'x86_64' '' 'w64' 'mingw32' '' 'x86_64' '64' $CB0 $CB1;;

		--shared)   build_shared=true; build_static=false;;
		--static)   build_static=true; build_shared=false;;
		--both)     build_static=true; build_shared=true;;
		--bin)      build_bin=true;;

		--full)    	build_shared=true
					build_static=true
					build_bin=true
					build_dist=true
					dep_build="--full"
					;;
		
		--prefix)   shift; dir_install=$1;;
		--clang)    use_clang=true;;
		--gcc)      use_clang=false;;

		--new)      shift; generate_script $@; exit 0;;
		--break)    shift; set_break ${1};;

		$optVrs)	shift; vrs="${1}";;
		--devel)    src_rel=false;;
		--bra*)     shift; export bra="${1}";;
		--checkout) git_checkout=true;;
		
		--force)    [ -f "${dir_install_pc}/${pkg}.pc" ] && rm "${dir_install_pc}/${pkg}.pc" 2>/dev/null;;

		--man)      build_man=true;;
		--dist)     build_dist=true;;
		--cpack)    build_cpack=true;;
		--strip)    build_strip=true;;
		--api)      shift; export API=$1;;
		--tune)     shift; menu_tune $1;;
		--cpus)     loadToolchain; $CC --print-supported-cpus; exit 0;;
		--mcpu)		shift; export CPPFLAGS+=" -mcpu=${1}";;
		--mtune)	shift; export CPPFLAGS+=" -mtune=${1}";;
		
		$optDnl)	build_download=true;;

		--diff)     shift; create_diff $@; exit 0;;
		--update)   update=true;;
		--upd-all)  update=true; req_update_deps=true;;
		--opts)     showOpts "$(pwd)/sources/$lib"; exit 0;;
		--checkPkg) checkPkg; exit 0;;
		--libName)  echo "${lib}"; exit 0;;
		--var)      shift; echo "$($1)"; exit 0;;
		--refresh)  update=true;;
		--retry)    retry=true;;
		
		
		--clear)    shift; menu_clear $@; exit 0;;
		--desc )    echo $dsc && exit 0;;
		
		--get)      shift; menu_get $@; exit 0;;
		
		--check)    shift; check_install $@; exit 0;;

		--list)     shift; menu_list $@; exit 0;;

		--patch)    shift;
					case $1 in
						# usage libname.sh --patch a [sources/libname/]path/to/newfile [sources/libname/]path/to/oldfile
						a|add|append)       shift; patch_append $@; exit 0;;
						m|make|e|embed)     shift; patch_embed $1; exit 0;;
						g|get|show)         patch_get; exit 0;;
					esac
					;;

		--skip)     shift; menu_skip_options $@;;

		--goto)     shift; menu_goto $@; exit 0;;

		--git)      shift; menu_git $@; exit 0;;

		--dirbuild) shift; dir_build=$1;;
		--inline)   inline=true;;
		--cmake)    cfg='cmake';;
		--ndkcmake) ndkcmake=true;;
		--ccmake)   cfg='ccm';;
		--nobanner) banner=false;;
		
		--latest-release) utils_get_latest_release; exit 0;;

		* ) if fn_defined 'extraOpts'; then
				extraOpts $1
			else
				cfg_args+=("${1}")
			fi
			;;
	esac
	shift
done

fn_undef 'extraOpts'

if fn_defined 'compiler_config'; then
	compiler_config
	fn_undef 'compiler_config'
fi

[ -z "${mingw_posix}" ] && mingw_posix=false

# Set default Host

if [ -z "${target_trip}" ];then
	set_target_build
fi

# is cross-compile?
if [ "${build_arch}" == "${arch}" ]; then
	host_cross=false
else
	host_cross=true
fi

loadToolchain

if ${banner} && ! ${is_running}; then
	show_banner
	is_running=true
fi

if [ -n "${sudo}" ] && ! ${sudo} -n true 2>/dev/null; then
	echo -ne "${CY1}Requesting sudo for tool install " && sudo echo -e "\e[1A\e[2K"
fi

config_init

# reset presets, we don't need them anymore
unset cst0 cst1 csh0 csh1 cb0 cb1 cstk cshk cbk

: "${MAKE_EXECUTABLE:=make}"

export arch update retry \
build_shared build_static build_bin build_system \
dir_install \
CSH CBN LIBSDIR PLATFORM CPU ABI EABI \
host_arch host_64 host_eabi host_vnd host_arm host_os \
mingw_posix MAKE_EXECUTABLE cmake_includes


# exit if missing vars lib arch or src
if [ -z "${lib}" ]; then
	echo -e "\n\n\t${CB1}  Toolchain is loadad.\n\tNow exiting...\n\n${C0}"
	return 0
fi

inc_tab

if [ -z "${lic}" ] || [ -z "${dsc}" ];then
	gitjson="$(git_api_tojson ${src})"
	if [ -n "${gitjson}" ];then
		#echo -ne "${CY1}${b}${C0}"
		: "${lic:=$(echo "$gitjson" | jq .licence)}"
		: "${dsc:=$(echo "$gitjson" | jq .description)}"
	fi
fi

test ! -d "${dir_install}" && mkdir -p "${dir_install}"

# show package info
export log_file="${dir_install}/${lib}.log"

if [ -z "$(check_install pc)" ]; then
	package_showinfo
elif ${update} || ${retry} || ${git_checkout}; then
	package_showinfo
else
	end_script    
fi
