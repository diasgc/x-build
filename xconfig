#!/bin/bash

function install_apt_repository {
  local url
  case "${1}" in
    cmake) url="https://apt.kitware.com/kitware-archive.sh";;
    llvm)  url="https://apt.llvm.org/llvm.sh";;
  esac
  test -n "${url}" && sudo bash -c "$(curl -sL ${url})"
}

function findname {
  local out
  local name="${1}"; shift
  while [ "${1}" ]; do
    out="$(find "${1}" -name "${name}" )"
    test -n "${out}" && break
  done
  echo "${out}"
}

function promptYN {
  echo -ne "${1} "; read -rp "[Y|n]" out
  case $out in
    y|Y) echo -ne "\e[1A\e[2K"; return 0;;
    *)   return 1;;
  esac
}

# ex.: check_policy 'https://apt.kitware.com' '--update cmake'
function check_policy {
  if [ -z "$(apt policy 2>/dev/null | grep "${1}")" ]; then
    echo -e "${CY1}  Run ${0} --update ${2} to get ultimate version${C0}"
  fi
}

function check_install {
  local v0 v1 out
  for p in $@; do
    v0=$(dpkg-query -W "$p" 2>/dev/null | cut -f2)
    v1=$(apt-cache madison "$p" | cut -d '|' -f2 | head -n1 | xargs)
    if [ -z "${v0}" ];then
      printf "${CH}${XBTAB}: ${C0}%s\n" "  $p" "installing..."
      out=$(${apt_install} "${p}" -y 2>/dev/null | grep "${p}" | sed "s/^${p}//" | head -n1)
      printf "%s\n" "$out"
    elif [ "${v1}" == "${v0}" ]; then
      printf "${CH}${XBTAB}: ${C0}%s\n" "  $p" "${v0}"
    else
      printf "${CH}${XBTAB}: ${C0}%s" "  $p" "${v0} upgrading to..."
      out=$(${apt_install} "${p}" -y 2>/dev/null | grep "${p}" | sed "s/^${p}//" | head -n1)
      printf "%s\n" "${out}"
    fi  
  done
}

function check_ndk_symlink {
  [[ -z "$(readlink "$1" | grep "${ANDROID_NDK_HOME}")" ]]
}

# syntax check_ndk_symlink_dir <dest-symlink> <src> [<src_root> <src_root_name>]
function check_ndk_symlink_dir {
  local quiet=false
  test "${1}" = "--quiet" && quiet=true && shift
  local dst="${1}"
  local src="${2}"
  local srcname="${src//${3}/${4}}"  
  local status
  if [ -L "${dst}" ]; then
    if [ "$(readlink "${dst}")" == "${src}" ]; then
      status="${CW}ok${CD}"
    else
      sudo ln -sfn "${src}" "${dst}" && status="${CY1}updated${CD}" || status="${CR1}failed${CD}"
    fi
  else
    sudo ln -sfn "${src}" "${dst}" && status="${CY1}created${CD}" || status="${CR1}failed${CD}"
  fi
  ! ${quiet} && echo -ne "\n    ${C0}$(basename "${dst}")${CD} symlink ${status}: ${dst} -> ${srcname}"
}

function ndk_url {
  echo "$(curl -sL https://developer.android.com/ndk/downloads | grep -Po "https://dl.google.com/android/repository/android-ndk-r..*-linux.zip" | sed "/\"/d")"
}

function llvm_mingw_install {
  # install llvm-mingw
  local url
  test -z "${XB_LLVM_MINGW_JSON}" && return 1
  : "${LLVM_MINGW_HOME:=${HOME}/llvm-mingw}"
  url="$(jq -r -M '.assets[] | .browser_download_url' <<<"${XB_LLVM_MINGW_JSON}" | grep '.*ucrt.*ubuntu.*'"$(uname -p)")"
  pushdir "$(pwd)"
  safe_cd "$(dirname "${LLVM_MINGW_HOME}")"
  safe_rm "${LLVM_MINGW_HOME}"
  echo -ne "  ${CY0}Downloading and extracting...${CD}"
  wget_untar "${url}" "llvm-mingw"
  echo -e "ยง{CH}done${CD}"    
  echo "${XB_LLVM_MINGW_LATEST}" >"${LLVM_MINGW_HOME}/version"
  popdir
}

# do_symlink --src <source> --dst <dest-slink> [--var varname][--test cmd_args][--export envfile value][--silent][--link]
function do_symlink {
  local src dst msg showlink var silent ret do_test test_args test_out do_export export_file export_val 
  showlink=false
  silent=false
  do_test=false
  do_export=false
  ret=1

  # parse option
  while [ "${1}" ]; do
    case "${1}" in
      --src|--source)
        shift; src="${1}"
        ;;
      --dst|--dest)
        shift; dst="${1}"
        ;;
      --var|--varname|-v)
        shift; var="${1}"
        ;;
      --test|-t)
        shift; test_args="${1}"
        do_test=true
        ;;
      --export|--exp|-e)
        shift; export_file="${1}"
        shift; export_val="${1}"
        do_export=true
        ;;
      --silent|--quiet|-q)
        silent=true
        ;;
      --link|--show*link|--show)
        showlink=true
        ;;
    esac
    shift
  done

  # empty dst or non-exist src
  test -f "${src}" || test ${dst} || return 1
  # default value for var name
  test ${var} || var="$(basename "${src}")"
  
  local op clr
  if [ ! -L "${dst}" ]; then
    op=1; clr="${CH}"
    msg_ok="created"
  elif [ "$(readlink "${dst}")" == "${src}" ]; then
    op=0; clr="${C0}"
    msg_ok="ok"
    ret=0
  else
    op=2; clr="${CY0}"
    msg_ok="updated"
  fi
  
  # do symlink, ret=0 if success
  test ${op} -gt 0 && sudo ln -sfn "${src}" "${dst}" && ret=0
  # if error set color and message
  if [ ${ret} -eq 1 ]; then
    clr="${CR1}"
    msg_ok="failed"
    do_test=false
    do_export=false
    showlink=false
  fi

  msg="${clr}${var}${CD} "
  ${silent} || msg="    ${msg}symlink ${clr}${msg_ok}${CD}"
  if ${do_test}; then
    test_out="$(${dst} "${test_args}" | head -n1)"
    if [ $? ]; then
      msg+=" ${C0}pass${CD}: ${test_out}"
    else
      msg+=" ${CR1}failed${CD}"
      ret=1
      do_export=false
    fi
  fi
  if ${do_export} && [ -f "${export_file}" ] && [ -n "${export_val}" ]; then
    echo "export ${var^^}=\"${export_val}\"" >>"${export_file}" 
  fi
  ${showlink} && msg+=" ${src} -> ${dst}"
  ${silent} || msg+="\n"
  echo -ne "${msg}"
  return ${ret}
}

# do_wrapper --dst "${dst_bin}/clang" --cmd "clang ${wrapper_args} \"$@\"" --test "-dumpversion" --export "${env_file}" "CC"
function do_wrapper {
  local dst cmd msg var silent ret do_show do_test test_args test_out do_export export_file export_var
  silent=false
  do_test=false
  do_export=false
  do_show=false
  ret=1

  # parse option
  while [ "${1}" ]; do
    case "${1}" in
      --dst|--dest)
        shift; dst="${1}"
        ;;
      --cmd|--command)
        shift; cmd="${1}"
        ;;
      --show)
        do_show=true
        ;;
      --test|-t)
        shift; test_args="${1}"
        do_test=true
        ;;
      --export|--exp|-e)
        shift; export_file="${1}"
        shift; export_var="${1}"
        do_export=true
        ;;
      --silent|--quiet|-q)
        silent=true
        ;;
    esac
    shift
  done
  
	cat <<-eof | sudo tee "${dst}" >/dev/null
		#!/bin/bash
		${cmd}
		eof
  sudo chmod +x "${dst}" && ret=0
  
  # if error set color and message
  if [ ${ret} -eq 1 ]; then
    clr="${CR1}"
    msg_ok='failed'
    do_test=false
    do_export=false
  else
    clr="${C0}"
    msg_ok='ok'
  fi
  msg="${clr}$(basename "${dst}")${CD} "
  ${silent} || msg="    ${msg}wrapper ${clr}${msg_ok}${CD}"
  ${do_show} && msg+=" ${cmd}"
  if ${do_test}; then
    test_out="$(${dst} "${test_args}" | head -n1)"
    if [ $? ]; then
      msg+=" ${C0}${test_args} pass${CD}: ${test_out}"
    else
      msg+=" ${CR1}${test_args} fails${CD}"
      ret=1
      do_export=false
    fi
  fi
  if ${do_export} && [ -f "${export_file}" ] && [ -n "${export_var}" ]; then
    echo "export ${export_var}=\"${dst}\"" >>"${export_file}" 
  fi
  ${silent} || msg+="\n"
  echo -ne "${msg}"
  return ${ret}
}





clear

# load first time .common helper
test -z ${vsh+x} && source .common

splash

if [ -n "$(command -v sudo)" ]; then
  sudo echo
  apt_install="sudo ${apt_install}"
fi

: "${verbose:=false}"

CH=${CC0}       # theme mnain color
XBTAB="%-25s"   # tab lenght

XB_GCC_PKGLIST='gcc g++'
XB_GCC_I686_PKGLIST='gcc-i686-linux-gnu g++-i686-linux-gnu'
XB_GCC_X86_64_PKGLIST='gcc-x86_64-linux-gnu g++-x86_64-linux-gnu'
XB_GCC_ARM64_PKGLIST='gcc-aarch64-linux-gnu g++aarch64-linux-gnu
  libc6-dev-arm64-cross libc6-arm64-cross libstdc++6-arm64-cross'
XB_GCC_ARMHF_PKGLIST='gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf
  libc6-dev-armhf-cross libc6-armhf-cross libstdc++6-armhf-cross'

XB_CLANG_PKGLIST='clang-format clang-tidy clang-tools clang clangd libc++-dev
  libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1
  liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb
  llvm-dev llvm-runtime llvm python3-clang'

: "${build_arch:=$(uname -m)-${OSTYPE,,}}"
: "${build_os:=$(uname -s)}"
: "${build_cpu:=$(uname -m)}"

# Header
echo -e "\n${CC1}This Machine:"
printf "${CH}${XBTAB}: ${C0}%s\n" '  build arch' "${build_arch}"
printf "${CH}${XBTAB}: ${C0}%s\n" '  build os' "${build_os}"
printf "${CH}${XBTAB}: ${C0}%s\n" '  build cpu' "${build_cpu}"

echo -e "\n${CC1}${b} Basic tools${C0}"
: "${apt_install:='apt install'}"
printf "\n${CH}${XBTAB}: ${C0}%s\n" '  cmd install' "${apt_install}"
check_install curl patch jq lzip unzip

echo -e "\n${CC1}${b} Build tools${C0}"
check_install build-essential make pkg-config

echo -e "\n${CC1}${b} Assembly compilers${C0}"
check_install nasm yasm

echo -e "\n${CC1}${b} Cmake${C0}"
check_policy 'https://apt.kitware.com' 'cmake'
check_install cmake cmake-curses-gui

echo -e "\n${CC1}${b} Meson${C0}"
check_install meson ninja-build

echo -e "\n${CC1}${b} Autotools${C0}"
check_install automake autoconf autogen autopoint libtool-bin m4

echo -e "\n${CC1}${b} Repository tools${C0}"
check_install git subversion mercurial

echo -e "\n${CC1}${b} Other tools${C0}"
check_install gperf bison texinfo gettext



# Toolchains

# GNU gcc compiler

echo -e "\n${CC1}${b}Gnu compiler"
check_install "${XB_GCC_PKGLIST}"
XB_BUILD_GCC="$(command -v gcc)"
test -z "${XB_BUILD_GCC}" && exit_err "Unable to install gcc. Aborting."
XB_GCC_VERSION="$(${XB_BUILD_GCC} -dumpversion)"
printf "${CH}${XBTAB}: ${C0}%s\n\n" '  version' "${XB_GCC_VERSION}"

# gcc cross-compiler
gnu_cross_archlist="x86_64-linux-gnu i686-linux-gnu aarch64-linux-gnu arm-linux-gnueabihf"
# remove native arch from list
gnu_cross_archlist="${gnu_cross_archlist//$(gcc -print-multiarch)/}"

for gcross in ${gnu_cross_archlist}; do
  printf "${CC1} Gnu %s cross-compiler\n" "${gcross}"
  case "${gcross}" in
    aarch64*) check_install "${XB_GCC_ARM64_PKGLIST}";;
    arm*)     check_install "${XB_GCC_ARMHF_PKGLIST}";;
    i686*)    check_install "${XB_GCC_I686_PKGLIST}";;
    x86_64*)  check_install "${XB_GCC_X86_64_PKGLIST}";;
  esac
  printf "${CH}${XBTAB}: ${C0}%s\n\n" "  version" "$("${gcross}-gcc" -dumpversion)"
done

XB_GCC_TOP_VER=$(apt search gcc 2>/dev/null | grep -oP 'gcc-[0-9\.]+' | sed 's,gcc-,,' | sort -n |tail -n1)
if [ "${XB_GCC_VERSION}" != "${XB_GCC_TOP_VER}" ]; then
  printf "${CH}${XBTAB}: ${CY1}%s${C0}\n\n" "  gcc version ${XB_GCC_TOP_VER} is available." "Run 'xsetup --update gcc' to update"
fi





# LLVM-CLANG compiler

echo -e "\n${CC1}${b}Clang compiler"
XB_BUILD_CLANG="$(command -v clang)"
if [ -z "${XB_BUILD_CLANG}" ]; then
  PS3='LLVM not installed: '
  select o in 'Do not install' 'Install latest OS package' 'Install devel from llvm.org'; do
    case ${REPLY} in
      2) check_install "${XB_CLANG_PKGLIST}";;
      3) sudo bash -c "$(wget -O - https://apt.llvm.org/llvm.sh)";;
    esac
  done
fi

check_policy '//apt.llvm.org' 'llvm'
XB_BUILD_CLANG="$(command -v clang)"
if [ -n "${XB_BUILD_CLANG}" ]; then
  XB_BUILD_CLANG_VERSION=$(clang -dumpversion)
  XB_BUILD_CLANG_VERSION_MAJOR=${XB_BUILD_CLANG_VERSION%%\.*}
  printf "${CH}${XBTAB}: ${C0}%s\n" "  found at" "${XB_BUILD_CLANG}"
  printf "${CH}${XBTAB}: ${C0}%s\n\n" "  version" "$(${XB_BUILD_CLANG} -dumpversion)"
  echo -e "\n${CC1} Clang components"
  check_install "${XB_CLANG_PKGLIST} libllvmlibc-${XB_BUILD_CLANG_VERSION_MAJOR}-dev"

  # check symlinks
  echo -ne "\n${CC1} Clang symlinks"
  
  cl=(aarch64 arm i686 x86_64)
	ab=(arm64 armhf i386 x86_64)
	abi=(gnu gnueabihf gnu gnu)
  exe='ar as nm addr2line objcopy objdump ranlib readelf size strings strip windres'
	
  # check if llvm-windres symlink exists
  # do_symlink --src <source> --dst <dest-slink> [--var varname][--test cmd_args][--export envfile value][--silent][--link]
  do_symlink \
    --src "/usr/lib/llvm-${XB_BUILD_CLANG_VERSION_MAJOR}/bin/llvm-windres" \
    --dst "/usr/bin/llvm-windres" \
    --var "windres" \
    --show

  for a in 0 1 2 3; do

    # set toolchain triplet
    t="${cl[$a]}-linux-${abi[$a]}"
    # skip native arch
    test "${t}" = "${build_arch}" && continue

    env_file="${dir_root}/builds/toolchain/clang-${t}.env"
    echo "#!/bin/bash" >"${env_file}"
    
    dst_bin="/usr/${t}/bin"
    echo -e "\n${CH}  ${t}"
    
    # create cross arch dir at /usr
    [ -d "${dst_bin}" ] || sudo mkdir -p "${dst_bin}"

    # clang/clang++ wrapper
    wrapper_args="--target=${t}"
    # add fp flags to armhf arch
    test "${ab[${a}]}" = "armhf" && wrapper_args+=' -mfloat-abi=hard -mfpu=neon'
    do_wrapper \
      --dst "${dst_bin}/clang" \
      --cmd "clang ${wrapper_args} \"\$@\"" \
      --test "-dumpversion" \
      --export "${env_file}" "CC" \
      --show
    do_wrapper \
      --dst "${dst_bin}/clang++" \
      --cmd "clang++ ${wrapper_args} \"\$@\"" \
      --test "-dumpversion" \
      --export "${env_file}" "CXX" \
      --show
    # ld
    do_symlink \
      --src "/usr/bin/ld.lld" \
      --dst "${dst_bin}/ld.lld" \
      --var "ld" --export "${env_file}" "${dst_bin}/ld.lld"
    
    # symlinks for llvm utils
    echo -ne "    ${C0}binutils:${CD} "
    for e in ${exe}; do
      do_symlink --quiet \
        --src "/usr/bin/llvm-${e}" \
        --dst "${dst_bin}/llvm-${e}" \
        --var "${e}" --export "${env_file}" "${dst_bin}/llvm-${e}"
    done
    echo -e "\n    ${C0}env file at ${CH}${env_file}${C0}"
	done
fi


# Android NDK CLANG compiler

echo -e "\n${CC1}${b}Android NDK compiler"
if [ ! -d "${ANDROID_NDK_HOME}" ]; then
  echo -e "   ${CY1}ANDROID_NDK_HOME is not defined or has changed.${C0} Searching..."
  ndk_dir="$(find ~ -name 'ndk-lldb' | head -n1)"
  if [ -f "${ndk_dir}" ]; then
    ndk_dir="$(dirname "${ndk_dir}")"
    export ANDROID_NDK_HOME="${ndk_dir}"
  else
    echo -e "${CY1}Android NDK not found."
    echo -e "${CY0}Download latest version: $(ndk_url)"
  fi
fi

if [ -d "${ANDROID_NDK_HOME}" ]; then
  
  ANDROID_NDK_RELEASE="$(basename "${ANDROID_NDK_HOME}")"
  ndk_root="$(dirname "${ANDROID_NDK_HOME}")"
  sdk_root="$(dirname "${ndk_root}")"
  ndk_update=false
  ndk_download=false
  ndk_latest="$(curl -sL https://developer.android.com/ndk/downloads | grep -oP '(?<=ndkVersion..)\d+\.\d+\.\d+.*(?=")' | head -n1)"
  if [ "${ANDROID_NDK_RELEASE}" = "${ndk_latest}" ]; then
    status="(updated)"
  elif [ "$(ls -1 "${ndk_root}" | sort | tail -n1)" == "${ndk_latest}" ]; then
    status="${CY1} found ${ndk_latest}${C0} at ${ndk_root}/${ndk_latest}"
    ndk_update=true
  else
    status="${CY1} latest release is ${ndk_latest}${C0}"
    ndk_download=true
  fi

  ndk_build="$(uname -s)-$(uname -m)"
  ndk_build="${ndk_build,,}"
  XB_NDK_TOOLCHAIN="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/${ndk_build}"
  XB_NDK_SYSROOT="${XB_NDK_TOOLCHAIN}/sysroot"
  XB_NDK_CLANG="${XB_NDK_TOOLCHAIN}/bin/clang"
  XB_NDK_CLANG_VERSION="$(${XB_NDK_CLANG} -dumpversion)"
 
  cmake_platforms="${ANDROID_NDK_HOME}/build/cmake/platforms.cmake"
  XB_NDK_MIN_PLATFORM_LEVEL="$(grep -oP '(?<=NDK_MIN_PLATFORM_LEVEL ")[0-9]+' "${cmake_platforms}")"
  XB_NDK_MAX_PLATFORM_LEVEL="$(grep -oP '(?<=NDK_MAX_PLATFORM_LEVEL ")[0-9]+' "${cmake_platforms}")"
  ANDROID_NDK_API="${XB_NDK_MAX_PLATFORM_LEVEL}"
  
  printf "${CH}${XBTAB}: ${C0}%s\n" "  found at" "${ANDROID_NDK_HOME}"
  printf "${CH}${XBTAB}: ${C0}%s" "  release" "${ANDROID_NDK_RELEASE}"
  echo -e "${status}"
  printf "${CH}${XBTAB}: ${C0}%s\n" "  clang version" "${XB_NDK_CLANG_VERSION}"
  printf "${CH}${XBTAB}: ${C0}%s\n" "  api range" "${XB_NDK_MIN_PLATFORM_LEVEL} to ${XB_NDK_MAX_PLATFORM_LEVEL}"
  
  ndk_cmake="${sdk_root}/cmake"
  if [ -d "${ndk_cmake}" ]; then
    ndk_cmake_version="$(ls -1 "${ndk_cmake}" | sort | tail -n1)"
    if [ -f "${ndk_cmake}/${ndk_cmake_version}/bin/cmake" ]; then
      XB_NDK_CMAKE_EXE="${ndk_cmake}/${ndk_cmake_version}/bin/cmake"
      printf "${CH}${XBTAB}: ${C0}%s\n" "  sdk cmake" "${ndk_cmake_version} (${XB_NDK_CMAKE_EXE})"
    fi
  fi
  
  sdkmanager="${sdk_root}/cmdline-tools/latest/bin/sdkmanager"
  test -f "${sdkmanager}" && printf "${CH}${XBTAB}: ${C0}%s\n" "  sdk cmdline-tools" "$(${sdkmanager} --version 2>/dev/null | head -n1) (${sdk_root}/cmdline-tools)"
  
  ${ndk_download} && printf "${CH}${XBTAB}: ${CY1}%s${C0}\n" "  download link" "$(ndk_url)}"
  echo -e "\n${CC0} Check NDK symlinks"

  c_abi=('arm64-v8a' 'armeabi-v7a' 'x86' 'x86_64')
  c_clang=('aarch64-linux-android' 'armv7a-linux-androideabi' 'i686-linux-android' 'x86_64-linux-android')
  c_lib=('aarch64-linux-android' 'arm-linux-androideabi' 'i686-linux-android' 'x86_64-linux-android')

  for i in 0 1 2 3; do
    t="${c_lib[${i}]}"
    printf "  ${CH}%s${C0}\n" "${t}"
    dst_root="/usr/${t}"
    dst_bin="${dst_root}/bin"
    dst_lib="${dst_root}/lib"
    env_file="${dir_root}/builds/toolchain/${c_lib[${i}]}.env"

    echo "#!/bin/bash" >"${env_file}"
    echo "export PLATFORM='Android'" >>"${env_file}"
    echo "export TOOLCHAIN=\"/usr/${t}\"" >>"${env_file}"
    #echo "export SYSROOT=\"\${TOOLCHAIN}/sysroot\"" >>"${env_file}"
    echo "export CROSS_PREFIX=\"\${TOOLCHAIN}/bin/\"" >>"${env_file}"

    # create cross arch dir at /usr
    if [ ! -d "${dst_bin}" ]; then
      sudo mkdir -p "${dst_bin}"
      printf "    ${CD}created %s" "${dst_bin}"  
    fi

    # C/C++
    cmd_prefix="\${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/${c_clang[${i}]}\${API:=${ANDROID_NDK_API}}-"
    do_wrapper --dst "${dst_bin}/clang" \
      --cmd "${cmd_prefix}clang \"\$@\"" \
      --test "-dumpversion" \
      --export "${env_file}" "CC"
    do_wrapper --dst "${dst_bin}/clang++" \
      --cmd "${cmd_prefix}clang++ \"\$@\"" \
      --test "-dumpversion" \
      --export "${env_file}" "CXX"
    
    # LD
    do_symlink --src "${XB_NDK_TOOLCHAIN}/bin/ld" \
      --dst "${dst_bin}/ld" \
      --var "LD" --export "${env_file}" "\${CROSS_PREFIX}ld" \
      --test "--version"
    
    # YASM
    do_symlink --src "${XB_NDK_TOOLCHAIN}/bin/yasm" \
      --dst "${dst_bin}/yasm" \
      --var "YASM" --export "${env_file}" "\${CROSS_PREFIX}yasm" \
      --test "--version"
    test $? && echo "export ASM_NASM=\"${dst_bin}/yasm\"" >>"${env_file}"
    
    echo -ne "    ${C0}binutils:${CD} "
    do_symlink --quiet \
      --src "${XB_NDK_TOOLCHAIN}/bin/llvm-as" \
      --dst "${dst_bin}/as" \
      --var "as" --export "${env_file}" "\${CROSS_PREFIX}clang"
    for j in ar nm addr2line objcopy objdump ranlib readelf readobj size strings strip; do
      do_symlink --quiet \
        --src "${XB_NDK_TOOLCHAIN}/bin/llvm-${j}" \
        --dst "${dst_bin}/${j}" \
        --var "${j}" --export "${env_file}" "\${CROSS_PREFIX}${j}"
    done
    echo

    do_symlink \
      --src "${XB_NDK_SYSROOT}" \
      --dst "/usr/${t}/sysroot" \
      --var "SYSROOT" --export "${env_file}" "/usr/${t}/sysroot" \
      --showlink
    do_symlink \
      --src "${XB_NDK_SYSROOT}/usr/include" \
      --dst "/usr/${t}/include" \
      --showlink
    do_symlink \
      --src "${XB_NDK_SYSROOT}/usr/lib/${c_lib[${i}]}" \
      --dst "/usr/${t}/lib" \
      --var "lib" \
      --showlink
    do_symlink \
      --src "${dir_root}/builds/android/${c_abi[${i}]}" \
      --dst "${dst_root}/local" \
      --var "local" \
      --showlink

    echo "export CPPFLAGS=\"-I\${SYSROOT}/usr/include -I/usr/${t}/include -I/usr/${t}/local/include\"" >>"${env_file}"
    echo "export LT_SYS_LIBRARY_PATH=\"\${TOOLCHAIN}/lib:\${SYSROOT}/usr/lib/${t}:\${SYSROOT}/usr/lib/${t}/\${ANDROID_NDK_API}\"" >>"${env_file}"
    echo "export LDFLAGS=\"-Wl,-rpath,\${LT_SYS_LIBRARY_PATH} -L /usr/${t}/local/lib \${LDFLAGS}\"" >>"${env_file}"
    
    if [ ! -f "${dst_lib}/libpthread.a" ]; then
      sudo "${dst_bin}/ar" cr "${dst_lib}/libpthread.a"
    fi
    echo -e "    ${C0}libthread${CD} ${dst_lib}/libpthread.a"
    
    if [ ! -f "${dst_lib}/librt.a" ]; then
      sudo "${dst_bin}/ar" cr "${dst_lib}/librt.a"
    fi
    echo -e "    ${C0}librt${CD} ${dst_lib}/librt.a"
    echo -e "    ${C0}env file at ${CH}${env_file}${C0}\n"
  done
  printf "${CH}%-20s: ${C0}%s\n" '  all toolchain symlinks' "ok"
fi




# Mingw LLCM compiler

echo -e "\n${CC1}${b}LLVM-MINGW Clang compiler"
echo -ne "  ${C0}Checking remote repository..."
XB_LLVM_MINGW_JSON=$(curl -sL "https://api.github.com/repos/mstorsjo/llvm-mingw/releases/latest")
if [ -n "${XB_LLVM_MINGW_JSON}" ]; then
  echo "${XB_LLVM_MINGW_JSON}" >"${dir_root}/builds/llvm_mingw.json"
  XB_LLVM_MINGW_LATEST="$(jq -r .tag_name <<<"${XB_LLVM_MINGW_JSON}")"
  echo -e " latest version ${CH}${XB_LLVM_MINGW_LATEST}${C0}"
  export XB_LLVM_MINGW_JSON XB_LLVM_MINGW_LATEST
fi

if [ -z "${LLVM_MINGW_HOME}" ]; then
  w64clang=$(findname "aarch64-w64-mingw32-clang" "${HOME}" "/")
  if [ -z "${w64clang}" ]; then
    promptYN " not found. Install?" && install_llvm_mingw
  else
    LLVM_MINGW_HOME="$(dirname "$(dirname "${w64clang}")")"
  fi
fi 

if [ -n "${LLVM_MINGW_HOME}" ]; then
  printf "${CH}%-20s: ${C0}%s\n" "  found at" "${LLVM_MINGW_HOME}"
  [ -f "${LLVM_MINGW_HOME}/version" ] || echo "$XB_LLVM_MINGW_LATEST" >>"${LLVM_MINGW_HOME}/version"
  XB_LLVM_MINGW_LOCAL="$(cat "${LLVM_MINGW_HOME}/version")"
  printf "${CH}%-20s: ${C0}%s " '  release' "${XB_LLVM_MINGW_LOCAL}"
  if [ "${XB_LLVM_MINGW_LOCAL}" == "${XB_LLVM_MINGW_LATEST}" ]; then
      echo -e "(updated)"
  else
      echo -e "${CY1} latest is ${XB_LLVM_MINGW_LATEST}${C0}"
  fi
  XB_LLVM_MINGW_CLANG_VERSION=$("${LLVM_MINGW_HOME}/bin/clang" -dumpversion)
  XB_LLVM_MINGW_CLANG_VERSION_MAJOR="${XB_LLVM_MINGW_CLANG_VERSION%%\.*}"
  printf "${CH}%-20s: ${C0}%s\n" '  clang' "${XB_LLVM_MINGW_CLANG_VERSION}"  
 
  if [ -z "$(ls -A "${LLVM_MINGW_HOME}/include")" ]; then
      rm -r "${LLVM_MINGW_HOME}/include"
      ln -s "${LLVM_MINGW_HOME}/generic-w64-mingw32/include" "${LLVM_MINGW_HOME}/include"
  fi

  for cl in aarch64 arm i686 x86_64; do
    echo -ne "   ${CH}Checking symlinks for ${cl}-w64-mingw32"
    target_dir="/usr/${cl}-w64-mingw32"
    dst_bin="${target_dir}/bin"
    cl_abi=${cl/arm/armv7}
    source_dir="${LLVM_MINGW_HOME}/${cl_abi}-w64-mingw32"
    
    env_file="${dir_root}/builds/toolchain/clang-${cl}-w64-mingw32.env"

    echo "#!/bin/bash" >"${env_file}"
    echo "export PLATFORM='Windows'" >>"${env_file}"
    echo "export TOOLCHAIN=\"${target_dir}\"" >>"${env_file}"
    #echo "export SYSROOT=\"\${TOOLCHAIN}/sysroot\"" >>"${env_file}"
    echo "export CROSS_PREFIX=\"\${TOOLCHAIN}/bin/\"" >>"${env_file}"


    test -d "${target_dir}" || sudo mkdir -p "${target_dir}/bin"

    do_symlink \
      --src "${source_dir}/bin" \
      --dst "${target_dir}/dll" \
      --showlink
    do_symlink \
      --src "${source_dir}/include" \
      --dst "${target_dir}/include" \
      --showlink
    do_symlink \
      --src "${source_dir}/lib" \
      --dst "${target_dir}/lib" \
      --showlink
    do_symlink \
      --src "${source_dir}/share" \
      --dst "${target_dir}/share" \
      --showlink
    #check_ndk_symlink_dir "${target_dir}/dll" "${source_dir}/bin"
    #check_ndk_symlink_dir "${target_dir}/include" "${source_dir}/include"
    #check_ndk_symlink_dir "${target_dir}/lib" "${source_dir}/lib"
    #check_ndk_symlink_dir "${target_dir}/share" "${source_dir}/share"
    
    echo -ne "\n    ${C0}binutils:${CD} "
    for e in addr2line ar as dlltool llvm-ar llvm-ranlib nm objcopy objdump ranlib readelf size strings strip widl windres; do
      do_symlink --quiet \
        --src "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32-${e}" \
        --dst "${dst_bin}/${e}" \
        --var "${e^^}" --export "${env_file}" "${dst_bin}/${e}"
      #sudo ln -sfn "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32-${e}" "${dst_bin}/${j}"
      #test $? && echo -ne "${e} " || echo -ne "${CR1}${e}${CD} "   
      #create_symlink "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32uwp-${e}" "${target_dir}/bin/uwp-${e}"
    done
    echo
    cmd_bin=( clang clang++ ld)
    cmd_var=( CC CXX LD )
    cmd_test=( -dumpversion -dumpversion --version )
    for e in 0 1 2; do
      do_symlink \
        --src "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32-${cmd_bin[${e}]}" \
        --dst "${dst_bin}/${cmd_bin[${e}]}" \
        --var "${cmd_var[${e}]}" --export "${env_file}" "${dst_bin}/${cmd_bin[${e}]}" \
        --test "${cmd_test[${e}]}"
    done
    for e in c++ g++ gcc; do
      do_symlink \
        --src "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32-${e}" \
        --dst "${dst_bin}/${e}" \
        --test "-dumpversion"
    done
      #for e in c++ clang clang++ g++ gcc ld; do
      #  do_symlink \
      #    --src "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32-${e}" \
      #    --dst "${dst_bin}/${e}" \
      #    --var "${e}" --export "${env_file}" "${dst_bin}/${e}"
      #  #sudo ln -sfn "${LLVM_MINGW_HOME}/bin/${cl_abi}-w64-mingw32-${e}" "${dst_bin}/${j}"
      #  #test $? && status="$("${dst_bin}/${j}" --version | head -n1)"
      #  #st $? && echo -ne "\n    ${C0}${e} ${CD}symlink ${C0}ok${CD}: ${status}" || echo -ne "\n${CR1}${e} failed: not working${CD} "
      #done
    echo -e "\n    ${CH}ok${C0}"
    echo -e "    ${C0}env file at ${CH}${env_file}${C0}\n"
    
  done
  printf "${CH}%-20s: ${C0}%s\n" '  toolchain symlinks' ok
fi





# Write Config

echo -e "\n${CC1}${b}Writing Config file"

cat <<-EOF >"${dir_root}/.config"
#!/bin/bash
export config_lastupdate=$(date +%s) \\
  dir_root="$(pwd)" \\
  sudo=$(command -v sudo) \\
  apt_install="${apt_install}" \\
  build_arch="${build_arch}" \\
  MAKE_EXECUTABLE="$(command -v make)" \\
	CMAKE_EXECUTABLE="$(command -v cmake)" \\
	NASM_EXECUTABLE="$(command -v nasm)" \\
	PKG_CONFIG="$(command -v pkg-config)" \\
	HOST_NPROC="$(nproc)"

# GCC Toolchains
export XB_BUILD_GCC="${XB_BUILD_GCC}" \\
  XB_GCC_VERSION="${XB_GCC_VERSION}"

# Build LLVM Toolchain
export XB_BUILD_CLANG="${XB_BUILD_CLANG}" \\
  XB_BUILD_CLANG_VERSION="${XB_BUILD_CLANG_VERSION}" \\
  XB_BUILD_CLANG_VERSION_MAJOR="${XB_BUILD_CLANG_VERSION_MAJOR}"

# MINGW LLVM Toolchain
export LLVM_MINGW_HOME="${LLVM_MINGW_HOME}" \\
  XB_LLVM_MINGW_CLANG_VERSION="${XB_LLVM_MINGW_CLANG_VERSION}" \\
  XB_LLVM_MINGW_CLANG_VERSION_MAJOR="${XB_LLVM_MINGW_CLANG_VERSION_MAJOR}"

# Android NDK Toolchain
export ANDROID_NDK_HOME="${ANDROID_NDK_HOME}" \\
  XB_NDK_SYSROOT="${XB_NDK_SYSROOT}" \\
  XB_NDK_TOOLCHAIN="${XB_NDK_TOOLCHAIN}" \\
  XB_NDK_CMAKE_EXE="${XB_NDK_CMAKE_EXE}" \\
  ANDROID_NDK_API="${ANDROID_NDK_API}"
EOF

echo -ne "... ${CC1}Done!${C0}\n\n"









# symlink_exportenv [--export varname envfile][--silent|--test args] src dst
function symlink_exportenv {
  local silent=false
  local ctest=false
  local showlink=false
  local var_export=false
  local cargs
  local envfile
  case "${1}" in
    --export|-e)
      var_export=true; shift
      envfile="${1}"; shift
      ;;
  esac
  case "${1}" in
    --silent|-s) silent=true; shift;;
    --test|-t)   ctest=true; shift; cargs="${1}"; shift;;
    --link|-l)   showlink=true; shift;; 
  esac
  local src="${1}"
  local dst="${2}"
  local varname="${3}"
  local status=false
  local msg
  local msg_ok="ok"
  local req_ln=false
  
  if [ ! -L "${dst}" ]; then
    req_ln=true
    msg_ok="${CH}created${CD}"
    msg="${CH}"
  elif [ "$(readlink "${dst}")" == "${src}" ]; then
    status=true
    msg_ok="${C0}ok${CD}"
    msg="${C0}"
  else
    req_ln=true
    msg_ok="${CY0}updated${CD}"
    msg="${CY0}"
  fi
  if ${req_ln}; then
    sudo ln -sfn "${src}" "${dst}"
    if [ $? ]; then
      status=true
    else
      msg="${CR}"
      msg_ok="fail"
    fi
  fi
  msg+="${varname,,}${CD} "
  ${silent} || msg="    ${msg}symlink ${msg_ok}"
  if ${status}; then
    ${var_export} && echo "export ${varname}=${dst}" >>"${envfile}"
    if ${ctest}; then
      msg_ok="$("${dst}" "${cargs}" | head -n1)${CD}"
      test $? && msg+=": ${C0}${msg_ok}"|| msg+=" ${CR1}failed${CD}"
    elif ${showlink}; then
      msg+="${CD}${dst} -> ${src}"
    fi
  fi
  ${silent} || msg+="\n"
  echo -ne "${msg}"
  ${status} && return 0 || return 1
}